<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="3.1.9" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>"/blog/:date...": Component1, //for the default path in the line above, this route matches first!</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135234Z" creationid="shibukawa.yoshiki" creationdate="20150502T135234Z">
        <seg>"/blog/:date...": Component1, //上記のデフォルトパスはこのラウトに先にマッチします!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"/blog/archive/:year": Component2
});

m.route.param("date") === "archive/2014"

//the routes should be flipped around to get `m.route.param("year") == "2014"`</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135300Z" creationid="shibukawa.yoshiki" creationdate="20150502T135300Z">
        <seg>"/blog/archive/:year": Component2
});

m.route.param("date") === "archive/2014"

//`m.route.param("year") == "2014"`が成立するように、ラウト定義の順番を変えること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"/dashboard": Dashboard,
});

//re-route to dashboard
m.route("/dashboard"); // logs "unloading home"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135617Z" creationid="shibukawa.yoshiki" creationdate="20150502T135350Z">
        <seg>"/dashboard": Dashboard,
});

//dashboardに移動
m.route("/dashboard"); // 表示 "ホームをアンロード"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"name": "project-name-goes-here",</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150642Z" creationid="shibukawa.yoshiki" creationdate="20150412T150642Z">
        <seg>"name": "プロジェクト名はこちら",</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"version": "0.0.0", //must follow this format</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150613Z" creationid="shibukawa.yoshiki" creationdate="20150412T150613Z">
        <seg>"version": "0.0.0", //このsemver形式のフォーマットを必ず使用してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(An execution thread is basically any amount of code that runs before other asynchronous threads start to run.)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135558Z" creationid="shibukawa.yoshiki" creationdate="20150412T135548Z">
        <seg>(実行スレッドは基本的に、他の非同期スレッドが実行する前に、ある程度の量のコードを含んでいます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.then(function(value) {console.log(value)}); //logs "hello world" after 1 second</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135104Z" creationid="shibukawa.yoshiki" creationdate="20150415T135104Z">
        <seg>.then(function(value) {console.log(value)}); //1秒後に"hello world"と表示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.then(null, error) //handle the application error: bind to a getter-setter for diplaying it on the template</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173433Z" creationid="shibukawa.yoshiki" creationdate="20150415T173433Z">
        <seg>.then(null, error) //アプリケーションのエラーをテンプレートで表示するためにsetter-getterにバインド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.then(users, error); //on success, `users` will be populated, otherwise `error` will be populated
//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of User instances
//i.e. users()[0].name() == "John"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135118Z" creationid="shibukawa.yoshiki" creationdate="20150414T135118Z">
        <seg>.then(users, error); //成功時には`users`が変更され、それ以外では`error`が変更される
//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users()[0].name() == "John"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* draws stuff */
}

var view = [</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123532Z" creationid="shibukawa.yoshiki" creationdate="20150413T123532Z">
        <seg>/* 描画コード */
}

var view = [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Your tests here...
}</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161345Z" creationid="shibukawa.yoshiki" creationdate="20150416T161345Z">
        <seg>//テストはこちら
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//...so that Mithril autoredraws the view after calling the controller callback</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021758Z" creationid="shibukawa.yoshiki" creationdate="20150412T021758Z">
        <seg>//...Mithrilはコントローラのコールバックが呼ばれた後に再描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//Calling .map doesn't throw an error because we defined the initial value to be an empty array, instead of undefined</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001934Z" creationid="shibukawa.yoshiki" creationdate="20150415T001934Z">
        <seg>//初期値としてundefinedに代わりにからの配列を定義したため、この.mapはエラーにならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//Note that the '#' is not required in `href`, thanks to the `config` setting.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013325Z" creationid="shibukawa.yoshiki" creationdate="20150410T013325Z">
        <seg>//`config`の設定を使うことで、`href`内に'#'を書かなくてもよくなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//Select2 component (assumes both jQuery and Select2 are included in the page)
var Select2 = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045128Z" creationid="shibukawa.yoshiki" creationdate="20150502T045128Z">
        <seg>//Select2コンポーネント(jQueryとSelect2が両方読み込まれている)
var Select2 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//This is a simplication for the sake of the example.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062229Z" creationid="shibukawa.yoshiki" creationdate="20150502T062229Z">
        <seg>//これはサンプル用として単純化している</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//This view gets rendered before the request above completes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001852Z" creationid="shibukawa.yoshiki" creationdate="20150415T001852Z">
        <seg>//このビューはデータが利用可能人なる前にレンダリングされる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//Typically, values are modified via model methods,</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071245Z" creationid="shibukawa.yoshiki" creationdate="20150502T071245Z">
        <seg>//通常はモデルのメソッドを使って値を変更する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//`background` option example
var component = m.component({</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114008Z" creationid="shibukawa.yoshiki" creationdate="20150502T114008Z">
        <seg>//`background`オプションのサンプル
var component = m.component({</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a FP-friendly console.log
var log = function(value) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175127Z" creationid="shibukawa.yoshiki" creationdate="20150414T175127Z">
        <seg>//間姿プログラミングと相性の良いconsole.log
var log = function(value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a component without a controller
var MyComponent = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072107Z" creationid="shibukawa.yoshiki" creationdate="20150502T072107Z">
        <seg>//コントローラなしのコンポーネント
var MyComponent = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a contrived example of bi-directional data binding
var User = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125823Z" creationid="shibukawa.yoshiki" creationdate="20150502T125823Z">
        <seg>//双方向データバインディングのサンプル
var User = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a data store
var name = m.prop("")

//binding the data store in a view
m("input", {oninput: m.withAttr("value", name), value: name()})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014141Z" creationid="shibukawa.yoshiki" creationdate="20150413T014125Z">
        <seg>//データストア
var name = m.prop("")

//データをビューにバインド
m("input", {oninput: m.withAttr("value", name), value: name()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a menu template
var menu = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T134837Z" creationid="shibukawa.yoshiki" creationdate="20150413T134837Z">
        <seg>//メニューテンプレート
var menu = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a running list of todos</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161604Z" creationid="shibukawa.yoshiki" creationdate="20150407T161555Z">
        <seg>//アクティブなToDoのリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a sample component
var Dashboard = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135145Z" creationid="shibukawa.yoshiki" creationdate="20150502T135145Z">
        <seg>//サンプルコンポーネント
var Dashboard = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a sample module
var dashboard = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003122Z" creationid="shibukawa.yoshiki" creationdate="20150410T003122Z">
        <seg>//サンプルモジュール
var dashboard = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a simple MVC example

//a sample model that exposes a value
var model = {count: 0}

var MyComponent = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062209Z" creationid="shibukawa.yoshiki" creationdate="20150502T062135Z">
        <seg>//シンプルなMVCモデル

//値を公開するサンプルのモデル
var model = {count: 0}

var MyComponent = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//a slot to store the name of a new todo before it is created</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161736Z" creationid="shibukawa.yoshiki" creationdate="20150407T161736Z">
        <seg>//新しいToDoを作成する前の、入力中のToDoの名前を保持するスロット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//add one more user to the response</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175149Z" creationid="shibukawa.yoshiki" creationdate="20150414T175149Z">
        <seg>//レスポンスにユーザをもう一人追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//adds a todo to the list, and clears the description field for user convenience</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161944Z" creationid="shibukawa.yoshiki" creationdate="20150407T161944Z">
        <seg>//ToDoをリストに登録し、ユーザが使いやすいようにdescriptionフィールドをクリアする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//alerts the title of the body element when it's clicked</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140700Z" creationid="shibukawa.yoshiki" creationdate="20150414T140700Z">
        <seg>//bodyエレメントのタイトルがクリックされたらアラートを出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//an empty Mithril component
var myComponent = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040256Z" creationid="shibukawa.yoshiki" creationdate="20150502T040256Z">
        <seg>//空のMithrilコンポーネント
var myModule = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//an expensive-to-initialize DOM element</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T134955Z" creationid="shibukawa.yoshiki" creationdate="20150413T134955Z">
        <seg>//最初期化が非常に高価(つもり)のDOMエレメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//assume the file comes from an HTML5 drag-n-drop event
var file = e.dataTransfer.files[0]

var data = new FormData();
data.append("file", file)

m.request({</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175511Z" creationid="shibukawa.yoshiki" creationdate="20150414T175511Z">
        <seg>//ファイルはHTML5のドラッグアンドドロップイベントで渡されたとする
var file = e.dataTransfer.files[0]

var data = new FormData();
data.append("file", file)

m.request({</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//assume the variable `link` came from a web service
var link = {url: "http://google.com", title: "Google"}

m("a", {href: link.url}, link.title); //yields &lt;a href="http://google.com"&gt;Google&lt;/a&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002350Z" creationid="shibukawa.yoshiki" creationdate="20150413T002336Z">
        <seg>//この`link`変数の値はウェブサービスから返ってきた値という想定
var link = {url: "http://google.com", title: "Google"}

m("a", {href: link.url}, link.title); //&lt;a href="http://google.com"&gt;Google&lt;/a&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//assume this content comes from the server
var content = "Error: invalid user";

m.render("body", [</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015415Z" creationid="shibukawa.yoshiki" creationdate="20150416T015355Z">
        <seg>//サーバから送られてきたコンテンツとする
var content = "エラー: ユーザ名が違います";

m.render("body", [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//asynchronous service
var greetAsync = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135205Z" creationid="shibukawa.yoshiki" creationdate="20150415T135205Z">
        <seg>//非同期サービス
var greetAsync = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//avoid using this idiom
m("li", selected ?</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144408Z" creationid="shibukawa.yoshiki" creationdate="20150413T144340Z">
        <seg>//このイディオムは避けること
m("li", selected ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//binding a model value to an input in a template
m("input", {value: todo.vm.description()})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014920Z" creationid="shibukawa.yoshiki" creationdate="20150408T014920Z">
        <seg>//モデルの値と、テンプレート内のテキスト入力を結びつける
m("input", {value: todo.vm.description()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//by default `e` would be caught by Mithril's promise exception monitor and rethrown to the console</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181341Z" creationid="shibukawa.yoshiki" creationdate="20150414T181341Z">
        <seg>//デフォルトでは`e`はMithrilのpromiseの例外モニタがキャッチして、コンソールに向けて再度投げる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//controller
var controller = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124657Z" creationid="shibukawa.yoshiki" creationdate="20150410T124657Z">
        <seg>//コントローラ
var controller = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//declare a component
var MyComponent = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075737Z" creationid="shibukawa.yoshiki" creationdate="20150502T075737Z">
        <seg>//コンポーネント宣言
var MyComponent = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//define a getter-setter with initial value `John`
var a_name = m.prop("John");

//read the value
var a = a_name(); //a == "John"

//set the value to `Mary`
a_name("Mary"); //Mary

//read the value
var b = a_name(); //b == "Mary"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040805Z" creationid="shibukawa.yoshiki" creationdate="20150407T150547Z">
        <seg>//'John'を初期値として、getter-setterを定義する
var a_name = m.prop("John");

//値を取得する
var a = a_name(); //a == "John"

//値を`Mary`に設定する
a_name("Mary"); //Mary

//値を取得する
var b = a_name(); //b == "Mary"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//define a getter-setter with initial value `John`
var name = m.prop("John");

//read the value
var a = name(); //a == "John"

//set the value to `Mary`
name("Mary"); //Mary

//read the value
var b = name(); //b == "Mary"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134314Z" creationid="shibukawa.yoshiki" creationdate="20150414T134217Z">
        <seg>/`John`という値でgetter-setterを初期化
var name = m.prop("John");

//値を取得する
var a = name(); //a == "John"

//値を`Mary`に設定する
name("Mary"); //Mary

//値を取得する
var b = name(); //b == "Mary"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//define some helper functions to be called from the view</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081234Z" creationid="shibukawa.yoshiki" creationdate="20150502T081234Z">
        <seg>//ビューから呼ばれるヘルパー関数をいくつか定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//define the view-model
todo.vm = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161524Z" creationid="shibukawa.yoshiki" creationdate="20150407T161524Z">
        <seg>//ビュー・モデルの定義
todo.vm = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//diff when routing, instead of redrawing from scratch
//this preserves the `&lt;input&gt;` element and its 3rd party plugin after route changes, since the `&lt;input&gt;` doesn't change
var Component1 = m.component({</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114130Z" creationid="shibukawa.yoshiki" creationdate="20150502T114130Z">
        <seg>//ゼロから再描画するのではなく、ラウト変更時にも差分検知をする
//ラウト変更後も`&lt;input&gt;`エレメントと、それに追加されたサードパーティプラグインが維持される
var Component1 = m.component({</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//diff when routing, instead of redrawing from scratch
//this preserves the `&lt;input&gt;` element and its 3rd party plugin after route changes, since the `&lt;input&gt;` doesn't change
var Component1 = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130834Z" creationid="shibukawa.yoshiki" creationdate="20150502T130834Z">
        <seg>//ゼロから再描画するのではなく、ラウト変更時にも差分検知をする
//ラウト変更後も`&lt;input&gt;`エレメントと、それに追加されたサードパーティプラグインが維持される
var Component1 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//don't redraw if we did once already</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123518Z" creationid="shibukawa.yoshiki" creationdate="20150413T123518Z">
        <seg>//一度描画したら再描画はしない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//don't wait for this service; redraw right away</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135932Z" creationid="shibukawa.yoshiki" creationdate="20150415T135932Z">
        <seg>//サービスを待たずに即座に再描画する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//dynamic variables are not updated here</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124628Z" creationid="shibukawa.yoshiki" creationdate="20150416T124628Z">
        <seg>//ここの動的変数は更新されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//dynamic variables here still update on every redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124654Z" creationid="shibukawa.yoshiki" creationdate="20150416T124654Z">
        <seg>//ここの動的変数は再描画のたびに更新される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//end integration</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021809Z" creationid="shibukawa.yoshiki" creationdate="20150412T021809Z">
        <seg>//統合処理の完了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//here's the view
m("table", [</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152907Z" creationid="shibukawa.yoshiki" creationdate="20150408T152907Z">
        <seg>//これがビュー
m("table", [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//if the location bar is "http://example.com/?/foo/bar"
//and m.route.mode is `search`
//then `currentRoute == "/foo/bar"`
var currentRoute = m.route();</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172156Z" creationid="shibukawa.yoshiki" creationdate="20150414T172156Z">
        <seg>//もしロケーションバーが"http://example.com/?/foo/bar"
//で、m.route.modeが`search`の場合は、
//`currentRoute == "/foo/bar"`
var currentRoute = m.route();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//in the first redraw, there's no user, so ensure we don't throw an error</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134843Z" creationid="shibukawa.yoshiki" creationdate="20150502T134843Z">
        <seg>//最初の描画時はユーザがいないが、エラーにはならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//in this case, it simply assumes data has changed the first time, and never changes after that.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124552Z" creationid="shibukawa.yoshiki" creationdate="20150416T124552Z">
        <seg>//この場合、初回だけ変更されてその後は変更されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//initialize our view-model
todo.vm.init();

todo.vm.description(); //[empty string]

//try adding a to-do
todo.vm.add(todo.vm.description);
todo.vm.list.length; //0, because you can't add a to-do with an empty description

//add it properly
todo.vm.description("Write code");
todo.vm.add(todo.vm.description);
todo.vm.list.length; //1</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163852Z" creationid="shibukawa.yoshiki" creationdate="20150407T163731Z">
        <seg>//ビュー・モデルの初期化
todo.vm.init();

todo.vm.description(); //[空文字列]

//Todoを登録してみる
todo.vm.add(todo.vm.description);
todo.vm.list.length; //空のdescriptionは登録できないので、0

//正しく登録できた
todo.vm.description("コードを書く");
todo.vm.add(todo.vm.description);
todo.vm.list.length; //1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//integrate with the auto-redrawing system...</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021727Z" creationid="shibukawa.yoshiki" creationdate="20150412T021727Z">
        <seg>//再描画システムと統合...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//list of users to show</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021945Z" creationid="shibukawa.yoshiki" creationdate="20150412T021945Z">
        <seg>//ユーザ一覧のリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//model
var User = {}

User.listEven = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124209Z" creationid="shibukawa.yoshiki" creationdate="20150410T124209Z">
        <seg>//モデル
var User = {}

User.listEven = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//model
var saved = false
function save(e) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144851Z" creationid="shibukawa.yoshiki" creationdate="20150416T144851Z">
        <seg>//モデル
var saved = false
function save(e) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//model layer observer
Observable.on(["saveContact"], function(data) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031145Z" creationid="shibukawa.yoshiki" creationdate="20150502T031145Z">
        <seg>//モデルレイヤのオブザーバ
Observable.on(["saveContact"], function(data) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//nested component</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080106Z" creationid="shibukawa.yoshiki" creationdate="20150502T080106Z">
        <seg>//ネストされたコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//note how the controller does not handle the input arguments</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081219Z" creationid="shibukawa.yoshiki" creationdate="20150502T081216Z">
        <seg>//このコントローラは引数には触れない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//note that we are not updating the value of the `name` getter-setter via an event handler
//redraws will always overwrite the current UI value with the value of `name()`
m("input", {value: name()})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015357Z" creationid="shibukawa.yoshiki" creationdate="20150413T015357Z">
        <seg>//このサンプルではイベントハンドラが`name` getter-setterの値を変更することはない
//再描画があるたびに現在のUI上の値が`name()`の値を使って書き換えられる
m("input", {value: name()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//now `deferred.resolve` has been called</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135304Z" creationid="shibukawa.yoshiki" creationdate="20150415T135304Z">
        <seg>//ここで `deferred.resolve` が呼ばれた</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//only runs once, even if you move back and forth between `/` and `/contact`</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135135Z" creationid="shibukawa.yoshiki" creationdate="20150413T135135Z">
        <seg>// `/` と`/contact` の間を何度行き来しても、一度だけ実行される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//onunload's preventDefault was called</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092405Z" creationid="shibukawa.yoshiki" creationdate="20150502T092405Z">
        <seg>//onunloadのpreventDefaultが呼ばれた</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//pressing the button reverses the list</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080401Z" creationid="shibukawa.yoshiki" creationdate="20150502T080401Z">
        <seg>//ボタンを押すとリストの順序が逆転する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//private store
var description;

//public getter-setter
this.description = function(value) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002509Z" creationid="shibukawa.yoshiki" creationdate="20150409T002456Z">
        <seg>//プライベート変数
var description;

//パブリックなgetter-setter
this.description = function(value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//rather than modified directly</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071253Z" creationid="shibukawa.yoshiki" creationdate="20150502T071253Z">
        <seg>//ここでは直接変更している</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//redraw again</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135940Z" creationid="shibukawa.yoshiki" creationdate="20150415T135940Z">
        <seg>//再び再描画する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//refactor the binding to a simple helper
var binds = function(prop) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015537Z" creationid="shibukawa.yoshiki" creationdate="20150413T015537Z">
        <seg>//バインディングをヘルパ関数にリファクタリング
var binds = function(prop) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//refactor the binding to a simple helper
var input = function(prop) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015642Z" creationid="shibukawa.yoshiki" creationdate="20150413T015642Z">
        <seg>//バインディングをシンプルなヘルパにリファクタリング
var input = function(prop) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//render the todo component inside the document DOM node
m.mount(document, {controller: todo.controller, view: todo.view});</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041712Z" creationid="shibukawa.yoshiki" creationdate="20150502T041712Z">
        <seg>//todoコンポーネントはdocument DOMノードの中でレンダリングする
m.mount(document, {controller: todo.controller, view: todo.view});</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//select Mary</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021951Z" creationid="shibukawa.yoshiki" creationdate="20150412T021951Z">
        <seg>//Maryを選択する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//set up select2 (only if not initialized already)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021656Z" creationid="shibukawa.yoshiki" creationdate="20150412T021656Z">
        <seg>//初期化されていなければselect2を初期化します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//setting `background` allows the component to redraw immediately, without waiting for the request to complete</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114043Z" creationid="shibukawa.yoshiki" creationdate="20150502T114043Z">
        <seg>//`background`を設定すると、リクエストの完了を待たずにすぐに再描画を行う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//simply pass the FormData object intact to the underlying XMLHttpRequest, instead of JSON.stringify'ing it</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034320Z" creationid="shibukawa.yoshiki" creationdate="20150502T034320Z">
        <seg>//JSON.stringifyをしないで、FormDataをそのままバックエンドのXMLHttpRequestに渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//standalone usage
document.body.onclick = m.withAttr("title", function(value) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140641Z" creationid="shibukawa.yoshiki" creationdate="20150414T140641Z">
        <seg>//単独での使用
document.body.onclick = m.withAttr("title", function(value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//standalone usage
var greetAsync = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135043Z" creationid="shibukawa.yoshiki" creationdate="20150415T135043Z">
        <seg>//単体での利用
var greetAsync = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//swallow all errors
m.deferred.onerror = function() {}

//only log errors
m.deferred.onerror = function(e) {console.error(e)}</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174841Z" creationid="shibukawa.yoshiki" creationdate="20150415T174826Z">
        <seg>//すべてのエラーを無視する
m.deferred.onerror = function() {}

//エラーを単にログに出力する
m.deferred.onerror = function(e) {console.error(e)}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//tell Mithril to wait for this service to complete before redrawing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135537Z" creationid="shibukawa.yoshiki" creationdate="20150415T135537Z">
        <seg>//Mithrilにサービス呼び出しが終わるまで再描画を待つように伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//test a transformation function in the controller
var ctrl = new TemperatureConverter.controller();
assert(ctrl.kelvinToCelsius(273.15) == 0)

//test the template
var tpl = TemperatureConverter.view(null, {value: 273.15})
assert(tpl.children[1] == 0)

//test with real DOM
var testRoot = document.createElement("div")
m.render(testRoot, TemperatureConverter.view(null, {value: 273.15}))
assert(testRoot.innerHTML.indexOf("celsius:0") &gt; -1)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081642Z" creationid="shibukawa.yoshiki" creationdate="20150502T081557Z">
        <seg>//controller内の変換関数のテスト
var ctrl = new TemperatureConverter.controller();
assert(ctrl.kelvinToCelsius(273.15) == 0)

//テンプレートのテスト
var tpl = TemperatureConverter.view(null, {value: 273.15})
assert(tpl.children[1] == 0)

//実際のDOMのテスト
var testRoot = document.createElement("div")
m.render(testRoot, TemperatureConverter.view(null, {value: 273.15}))
assert(testRoot.innerHTML.indexOf("celsius:0") &gt; -1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//the key ensures the components aren't recreated from scratch, if they merely exchanged places</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080435Z" creationid="shibukawa.yoshiki" creationdate="20150502T080435Z">
        <seg>//キーがあると、場所の移動時にDOMが再生成されるのを防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//the service is done, tell Mithril that it may redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135600Z" creationid="shibukawa.yoshiki" creationdate="20150415T135600Z">
        <seg>//サービスが完了したら、Mithrilに再描画するように伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this allows config contexts to live across route changes, if its element does not need to be recreated by the diff</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143800Z" creationid="shibukawa.yoshiki" creationdate="20150416T143800Z">
        <seg>//これにより、エレメントの再生成が不要な時は、configコンテキストがラウト変更時にも破棄されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this causes a redraw, since event handlers active auto-redrawing by default</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144817Z" creationid="shibukawa.yoshiki" creationdate="20150416T144817Z">
        <seg>//デフォルトでイベントハンドラは自動再描画を起動するため再描画が行われる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this component will attempt to diff its template when routing, as opposed to re-creating the view from scratch.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130645Z" creationid="shibukawa.yoshiki" creationdate="20150502T130645Z">
        <seg>//このコンポーネントはラウトの変更時にもゼロからビューを作りなおすのではなく、差分検知を行う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this event handler updates the controller when the view changes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021716Z" creationid="shibukawa.yoshiki" creationdate="20150412T021716Z">
        <seg>//このイベントハンドラはビューが変更されたときにコントローラを更新します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this link can use any of Mithril's routing system modes
//(i.e. it can use either the hash, the querystring or the pathname as the router implementation)
//without needing to hard-code any syntax (`#` or `?`) in the `href` attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124305Z" creationid="shibukawa.yoshiki" creationdate="20150413T124131Z">
        <seg>//このリンクはどのMithrilのラウティングシステムのモードでも使用できる。
//ラウティングのモードにはhash, querystring, pathnameがあるが、
//`href`属性で、ラウティングの文法(`#`, `?`)をハードコードする必要はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this new error follows Promises/A+ specifications and triggers a rejection in the downstream promises without hitting the console.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181833Z" creationid="shibukawa.yoshiki" creationdate="20150414T181833Z">
        <seg>//このエラーはPromises/A+の仕様にしたがって下流のpromiseのリジェクトに渡される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this only runs once in order to boost performance</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124613Z" creationid="shibukawa.yoshiki" creationdate="20150416T124613Z">
        <seg>//パフォーマンスの最適化のために、一度しか実行されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this service waits 1 second, logs "hello" and then notifies the view that
//it may start redrawing (if no other asynchronous operations are pending)
var doStuff = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192927Z" creationid="shibukawa.yoshiki" creationdate="20150411T192927Z">
        <seg>//このサービスは1秒間待ってログに"hello"と出力し、その後ビューに
//再描画を行うように知らせています (他の非同期処理により延期されないかぎり)
var doStuff = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this view implements select2's `&lt;select&gt;` progressive enhancement mode</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045157Z" creationid="shibukawa.yoshiki" creationdate="20150502T045157Z">
        <seg>//このビューはselect2の`&lt;select&gt;`プログレッシブ拡張モードを実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//this view renders twice (once immediately, and once after the request above completes)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012109Z" creationid="shibukawa.yoshiki" creationdate="20150415T012109Z">
        <seg>//このビューは初回と上記のリクエストの完了後の2回再描画が行われる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//update the view with the latest controller value</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021827Z" creationid="shibukawa.yoshiki" creationdate="20150412T021827Z">
        <seg>//最新のコントローラの値を使ってビューを更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//usage demo 1: standalone multipart/form-data upload when files are dropped into the component
var Demo1 = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034723Z" creationid="shibukawa.yoshiki" creationdate="20150502T034723Z">
        <seg>//デモ1: コンポーネントにファイルがドロップされた時にmultipart/form-dataでアップロード
var Demo1 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//usage demo 2: upload as base-64 encoded data url from a parent form
var Demo2 = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034820Z" creationid="shibukawa.yoshiki" creationdate="20150502T034820Z">
        <seg>//デモ2: base64のデータURLとしてデータをアップロード
var Demo2 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//we don't care about other keys, so don't redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144836Z" creationid="shibukawa.yoshiki" creationdate="20150416T144836Z">
        <seg>//他のキーについては無視したいので、再描画も行わない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//we only want to make this call once</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084510Z" creationid="shibukawa.yoshiki" creationdate="20150502T084510Z">
        <seg>//このコードは一度しか呼ばれない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;!doctype html&gt;
&lt;script src="mithril.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
//this application only has one component: todo
var todo = {};

//for simplicity, we use this component to namespace the model classes

//the Todo class has two properties
todo.Todo = function(data) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041742Z" creationid="shibukawa.yoshiki" creationdate="20150502T041732Z">
        <seg>&lt;!doctype html&gt;
&lt;script src="mithril.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
//このアプリケーションは、todoコンポーネントを1つだけ持つ
var todo = {};

//コードをシンプルにするために、このコンポーネントをモデルクラスの名前空間としても流用する

//Todoクラスは2つのプロパティを持つ
todo.Todo = function(data) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;!doctype html&gt;
&lt;title&gt;Todo app&lt;/title&gt;
&lt;script src="mithril.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
//app goes here
&lt;/script&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142715Z" creationid="shibukawa.yoshiki" creationdate="20150407T142701Z">
        <seg>&lt;!doctype html&gt;
&lt;title&gt;ToDoアプリケーション&lt;/title&gt;
&lt;script src="mithril.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
//アプリケーションコードはここ
&lt;/script&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a href="/item1"&gt;item 1&lt;/a&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002523Z" creationid="shibukawa.yoshiki" creationdate="20150413T002523Z">
        <seg>&lt;a href="/item1"&gt;アイテム 1&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.mount (if your app only has one page)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071721Z" creationid="shibukawa.yoshiki" creationdate="20150502T071721Z">
        <seg>m.mount (ページを1つしか持たない場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.prop is a simple but surprisingly versatile tool: it's functionally composable, it enables uniform data access and allows a higher degree of decoupling when major refactoring is required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T001957Z" creationid="shibukawa.yoshiki" creationdate="20150409T001957Z">
        <seg>m.propはシンプルですが、とても幅広く使えるつーるです。関数型のパラダイムを使えるようにしたり、データアクセスの統一化をしたり、リファクタリングが必要になったときに簡単に行えるように高度な疎結合化をするのに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.prop is simply a factory for a getter-setter function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150505Z" creationid="shibukawa.yoshiki" creationdate="20150407T150505Z">
        <seg>m.propはgetter-setter関数を作るための、単純なファクトリです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.render (if you are integrating Mithril's rendering engine into a larger framework and wish to manage redrawing yourself).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071757Z" creationid="shibukawa.yoshiki" creationdate="20150502T071757Z">
        <seg>m.render (Mithrilのレンダリングエンジンを他のシステムに統合し、レンダリングを自分で制御したい場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.route (if you are building a single-page application that has multiple pages)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071657Z" creationid="shibukawa.yoshiki" creationdate="20150502T071657Z">
        <seg>m.route (複数ページ持つシングルページアプリケーションを作りたい場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>○ Mithril Guide API Community Learn Download Github</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T132024Z" creationid="shibukawa.yoshiki" creationdate="20150407T131933Z">
        <seg>○ Mithril ガイド API コミュニティ もっと知る ダウンロード Github</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bower is a package manager for NodeJS.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T170224Z" creationid="shibukawa.yoshiki" creationdate="20150407T170224Z">
        <seg>BowerはNodeJSのためのパッケージマネージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Component is another package manager for NodeJS.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235559Z" creationid="shibukawa.yoshiki" creationdate="20150407T235559Z">
        <seg>Componentも、NodeJS向けのパッケージマネージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ES5 Shim or Mozilla.org's Array::indexOf, Array::map and Object::keys</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014856Z" creationid="shibukawa.yoshiki" creationdate="20150417T014856Z">
        <seg>ES5 Shimもしくは、MozillaのArray::indexOf、Array::map、Object::keys</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read more</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135001Z" creationid="shibukawa.yoshiki" creationdate="20150407T135001Z">
        <seg>より詳しい説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IE9 and lower do not support this feature and will gracefully degrade to page refreshes instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015322Z" creationid="shibukawa.yoshiki" creationdate="20150417T015218Z">
        <seg>IE9とそれ以下のブラウザはこの機能をサポートしていないため、リフレッシュが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.redraw forces a redraw to happen in the next available frame (or optionally, it can redraw immediately for synchronous processing).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192020Z" creationid="shibukawa.yoshiki" creationdate="20150411T192020Z">
        <seg>m.redrawを呼び出すと次のフレーム更新時に強制的に再描画を行います。また、オプションで同期処理として再描画を行わせることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.redraw.strategy can change the way Mithril runs the next scheduled redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000533Z" creationid="shibukawa.yoshiki" creationdate="20150506T000533Z">
        <seg>m.redraw.strategyを使うと、Mithrilが次に再描画を計画する方法を変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;button onclick={app.vm.add}&gt;Add&lt;/button&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013912Z" creationid="shibukawa.yoshiki" creationdate="20150417T013912Z">
        <seg>&lt;button onclick={app.vm.add}&gt;追加&lt;/button&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;button&gt;Add&lt;/button&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013845Z" creationid="shibukawa.yoshiki" creationdate="20150408T013845Z">
        <seg>&lt;button&gt;追加&lt;/button&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"/grid?sortby=date" - here, m.route.param("sortby") returns "date"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170756Z" creationid="shibukawa.yoshiki" creationdate="20150414T170756Z">
        <seg>"/grid?sortby=date" - ここでは、m.route.param("sortby")は"date"を返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"/path/to/page/:id" - here, id is the name of the route parameter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170625Z" creationid="shibukawa.yoshiki" creationdate="20150414T170618Z">
        <seg>"/path/to/page/:id" - ここでは、idがラウトパラメータの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"all" - recreates the DOM tree from scratch</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152312Z" creationid="shibukawa.yoshiki" creationdate="20150416T152312Z">
        <seg>"all" - すべて破棄してDOMツリーを再構築する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"diff" - updates only DOM elements if needed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152326Z" creationid="shibukawa.yoshiki" creationdate="20150416T152326Z">
        <seg>"diff" - 必要があればDOMエレメントを更新する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"none" - leaves the DOM tree intact</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152341Z" creationid="shibukawa.yoshiki" creationdate="20150416T152341Z">
        <seg>"none" - DOMツリーを変更せずにそのままにする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ContactsWidget is the top level module being rendered to document.body, and it is the module that has the responsibility of talking to our Model entity Contact, which we defined earlier.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T001544Z" creationid="shibukawa.yoshiki" creationdate="20150502T001544Z">
        <seg>ContactsWidgetはdocument.bodyにレンダリングされる、最上位のモジュールです。また、これは先に定義していたContactモデルのエンティティと話をする責務を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hash mode uses the hash (i.e. #).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170025Z" creationid="shibukawa.yoshiki" creationdate="20150414T170025Z">
        <seg>hashモードはハッシュ(#以降)を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hash mode uses the hash.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005129Z" creationid="shibukawa.yoshiki" creationdate="20150410T005129Z">
        <seg>hashモードはハッシュを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.prop can also be used in conjunction with m.request and m.deferred to bind data on completion of an asynchronous operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134821Z" creationid="shibukawa.yoshiki" creationdate="20150414T134821Z">
        <seg>m.propは、m.requestやm.deferredと組み合わせて、非同期操作の結果に対してデータを束縛することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.redraw is a method that allows you to render a template outside the scope of Mithril's auto-redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015835Z" creationid="shibukawa.yoshiki" creationdate="20150421T015835Z">
        <seg>m.redrawを使うと、Mithrilの自動再描画システムのスコープ外から、再描画を行わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.render accepts a special low level SubtreeDirective object as a node in a virtual DOM tree: if a tree contains a node that looks exactly like the object below, Mithril will abort the diff algorithm for that node.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123617Z" creationid="shibukawa.yoshiki" creationdate="20150416T123617Z">
        <seg>m.renderは、特別なSubtreeDirectiveオブジェクトを仮想DOMツリーのノードとして受け取ることができます。もし、ツリーが次のようなオブジェクトを含んでいると、Mithrilはこのノードに対する差分検知アルゴリズムを中断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.route() - returns the currently active route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152813Z" creationid="shibukawa.yoshiki" creationdate="20150414T152813Z">
        <seg>m.route() - 現在アクティブなラウトの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.route(element) - an extension to link elements that unobtrusively abstracts away the routing mode</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153031Z" creationid="shibukawa.yoshiki" creationdate="20150414T153031Z">
        <seg>m.route(element) - ラウトのモードを抽象化し、現在のモードで利用可能なエレメントの実リンクを取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.route(path) - redirects to another route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152759Z" creationid="shibukawa.yoshiki" creationdate="20150414T152759Z">
        <seg>m.route(path) - 他のラウトへリダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.route(rootElement, defaultRoute, routes) - defines the available URLs in an application, and their respective components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135009Z" creationid="shibukawa.yoshiki" creationdate="20150502T135009Z">
        <seg>m.route(rootElement, defaultRoute, routes) - アプリケーションで使用できるURLとその時にロードされるコンポーネントの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pathname mode allows routing URLs that contain no special characters, however this mode requires server-side setup in order to support bookmarking and page refreshes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005430Z" creationid="shibukawa.yoshiki" creationdate="20150410T005430Z">
        <seg>pathnameモードは特別な文字を含まないURLを許可します。しかし、このモードでブックマークとページリフレッシュをサポートするためには、サーバ側にも手を加える必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pathname mode allows routing URLs that contains no special characters, however this mode requires server-side setup in order to support bookmarking and page refreshes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170054Z" creationid="shibukawa.yoshiki" creationdate="20150414T170054Z">
        <seg>pathnameモードは特別な文字を含まないURLを許可します。しかし、このモードでブックマークとページリフレッシュをサポートするためには、サーバ側にも手を加える必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>search mode uses the querystring (i.e. ?).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165825Z" creationid="shibukawa.yoshiki" creationdate="20150414T165825Z">
        <seg>searchモードはクエリー文字列 (?以降)を利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>search mode uses the querystring.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004858Z" creationid="shibukawa.yoshiki" creationdate="20150410T004858Z">
        <seg>searchモードはクエリー文字列を利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>select2.config is a factory that creates a config function based on a given controller.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133322Z" creationid="shibukawa.yoshiki" creationdate="20150412T133322Z">
        <seg>select2.configは、与えられたコントローラに対応するconfig関数を作成するファクトリー関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>update is the controller function itself, so defining it as a promise callback simply means that the controller is re-initialized after the previous asynchronous operation (Contact.save())</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T003837Z" creationid="shibukawa.yoshiki" creationdate="20150502T003837Z">
        <seg>updateはコントローラの関数そのものです。それをPromiseのコールバックとして定義するとということは、非同期操作(Contact.save())が完了したあとにコントローラを再初期化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{'/path/to/page/': pageComponent} - a route with a basic pathname</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135713Z" creationid="shibukawa.yoshiki" creationdate="20150502T135713Z">
        <seg>{'/path/to/page/': pageComponent} - 基本パス名のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{'/path/to/page/:id': pageComponent} - a route with a pathname that contains a dynamic parameter called id.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135725Z" creationid="shibukawa.yoshiki" creationdate="20150502T135725Z">
        <seg>{'/path/to/page/:id': pageComponent} - idと呼ばれる動的パラメータを含むパス名のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{'/user/:userId/book/:bookId': userBookComponent} - a route with a pathname that contains two parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135735Z" creationid="shibukawa.yoshiki" creationdate="20150502T135735Z">
        <seg>{'/user/:userId/book/:bookId': userBookComponent} - 2つのパラメータを含むパス名のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Home, Login and Dashboard are components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135125Z" creationid="shibukawa.yoshiki" creationdate="20150502T135125Z">
        <seg>home、login、dashboardはそれぞれコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>home, login and dashboard are modules.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002830Z" creationid="shibukawa.yoshiki" creationdate="20150410T002811Z">
        <seg>home、login、dashboardはそれぞれモジュールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error: invalid user</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015426Z" creationid="shibukawa.yoshiki" creationdate="20150416T015426Z">
        <seg>エラー: ユーザ名が違います</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;li&gt;&lt;a href="/item1"&gt;item 1&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121631Z" creationid="shibukawa.yoshiki" creationdate="20150502T121631Z">
        <seg>&lt;li&gt;&lt;a href="/item1"&gt;アイテム 1&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;li&gt;&lt;a href="/item2"&gt;item 2&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121634Z" creationid="shibukawa.yoshiki" creationdate="20150502T121634Z">
        <seg>&lt;li&gt;&lt;a href="/item2"&gt;アイテム 2&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;li&gt;&lt;a href="/item3"&gt;item 3&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121637Z" creationid="shibukawa.yoshiki" creationdate="20150502T121637Z">
        <seg>&lt;li&gt;&lt;a href="/item3"&gt;アイテム 3&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;li&gt;item 1&lt;/li&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000617Z" creationid="shibukawa.yoshiki" creationdate="20150413T000617Z">
        <seg>&lt;li&gt;アイテム 1&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;li&gt;item 2&lt;/li&gt;
&lt;/ul&gt;
*/</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000620Z" creationid="shibukawa.yoshiki" creationdate="20150413T000620Z">
        <seg>&lt;li&gt;アイテム 2&lt;/li&gt;
&lt;/ul&gt;
*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;script&gt;
//this application only has one component: todo
var todo = {};
&lt;/script&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040351Z" creationid="shibukawa.yoshiki" creationdate="20150502T040351Z">
        <seg>&lt;script&gt;
//このアプリケーションはtodoコンポーネントのみを含む
var todo = {};
&lt;/script&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;td&gt;task description&lt;/td&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013941Z" creationid="shibukawa.yoshiki" creationdate="20150408T013941Z">
        <seg>&lt;td&gt;タスクの説明&lt;/td&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Todo can be instantiated, and have its properties changed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151837Z" creationid="shibukawa.yoshiki" creationdate="20150407T151837Z">
        <seg>Todoは初期化をして、プロパティの変更を行うことができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A DOM element which will contain the template represented by children.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124732Z" creationid="shibukawa.yoshiki" creationdate="20150416T124732Z">
        <seg>childrenで表現されるテンプレートの結果が入るDOMエレメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A DOM element which will contain the view's template.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T020744Z" creationid="shibukawa.yoshiki" creationdate="20150414T020744Z">
        <seg>ビューのテンプレートの結果が作成されるDOMエレメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Javascript Framework for Building Brilliant Applications</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T132054Z" creationid="shibukawa.yoshiki" creationdate="20150407T132054Z">
        <seg>輝かしいアプリケーションを構築するためのJavaScriptフレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Knockout view model is an amalgamation of model and controller layers in a single class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105558Z" creationid="shibukawa.yoshiki" creationdate="20150420T105558Z">
        <seg>Knockoutのビュー・モデルはモデルとコントローラレイヤーを1つに融合させるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Promise aggregator</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153843Z" creationid="shibukawa.yoshiki" creationdate="20150412T153843Z">
        <seg>Promiseを集約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Promise factory</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153806Z" creationid="shibukawa.yoshiki" creationdate="20150412T153800Z">
        <seg>Promiseのファクトリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Simple Application</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142412Z" creationid="shibukawa.yoshiki" creationdate="20150407T142412Z">
        <seg>シンプルなアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A component can be re-initialized from scratch by changing the key associated with it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085454Z" creationid="shibukawa.yoshiki" creationdate="20150502T085454Z">
        <seg>コンポーネントを再初期化したい場合は、key属性を書き換えると行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A component is said to be stateless when it does not store data internally.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080503Z" creationid="shibukawa.yoshiki" creationdate="20150502T080503Z">
        <seg>コンポーネントは、内部にデータを保持しなければステートレスになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A component is supposed to be an Object with two keys: controller and view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100430Z" creationid="shibukawa.yoshiki" creationdate="20150502T100430Z">
        <seg>コンポーネントは、controllerとviewのキーを持つオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A component with arguments bound</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100704Z" creationid="shibukawa.yoshiki" creationdate="20150502T100704Z">
        <seg>引数が束縛されたコンポーネント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A contact has an id, a name and an email.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T224101Z" creationid="shibukawa.yoshiki" creationdate="20150501T224101Z">
        <seg>この連絡先には、id、名前、eメールが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A contrived example of bi-directional data binding</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140721Z" creationid="shibukawa.yoshiki" creationdate="20150414T140721Z">
        <seg>双方向データバインディングのサンプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A controller can also be used as a class constructor (i.e. it's possible to attach properties to the this object within the constructor, instead of returning a value).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072300Z" creationid="shibukawa.yoshiki" creationdate="20150502T072300Z">
        <seg>controllerはクラスコンストラクタとしても使用できます。その時は値を返すのではなく、コンストラクタ内でthisオブジェクトに値を追加していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A deferred is an asynchrony monad.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015925Z" creationid="shibukawa.yoshiki" creationdate="20150415T015925Z">
        <seg>deferredは非同時性モナドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A event handler factory utility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153211Z" creationid="shibukawa.yoshiki" creationdate="20150412T153211Z">
        <seg>イベントハンドラを生成するユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A flag that drives the rendering strategy for the next redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154128Z" creationid="shibukawa.yoshiki" creationdate="20150412T154128Z">
        <seg>次の再描画をどのような戦略で行うかを決定するフラグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A getter-setter method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135818Z" creationid="shibukawa.yoshiki" creationdate="20150414T135818Z">
        <seg>getter-setterメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A getter-setter utility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153150Z" creationid="shibukawa.yoshiki" creationdate="20150412T153150Z">
        <seg>getter-setterユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A high-level AJAX utility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153752Z" creationid="shibukawa.yoshiki" creationdate="20150412T153752Z">
        <seg>高レベルなAJAXユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A high-level explicit rendering method</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153952Z" creationid="shibukawa.yoshiki" creationdate="20150412T153952Z">
        <seg>高レベルな明示的なレンダリングメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key-value map of possible routes and their respective components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135659Z" creationid="shibukawa.yoshiki" creationdate="20150502T135659Z">
        <seg>利用可能なラウトと、そのラウトに対応するコンポーネントの対応が格納されたキー・バリュー・マップ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key/value map of attributes that gets bound as an argument to both the controller and view functions of the component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100617Z" creationid="shibukawa.yoshiki" creationdate="20150502T100617Z">
        <seg>コンポーネントのcontrollerとviewの両方の関数に束縛される属性のキー/バリューマップです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A list of promises to synchronize</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180752Z" creationid="shibukawa.yoshiki" creationdate="20150415T180718Z">
        <seg>同期を取りたいpromiseの配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A map of options for JSONP requests</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014502Z" creationid="shibukawa.yoshiki" creationdate="20150415T014502Z">
        <seg>JSONPリクエストのためのオプションのマップ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A map of options for the XMLHttpRequest</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002049Z" creationid="shibukawa.yoshiki" creationdate="20150415T002036Z">
        <seg>XMLHttpRequestに渡すオプションのマップ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A method to unescape HTML</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153905Z" creationid="shibukawa.yoshiki" creationdate="20150412T153905Z">
        <seg>エスケープしないHTMLのためのメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more intellectually interesting aspect of the framework is that event handling is encouraged to be done via functional composition (i.e. by using tools like m.withAttr, m.prop and the native .bind() method for partial application).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T022010Z" creationid="shibukawa.yoshiki" creationdate="20150409T015513Z">
        <seg>Mithril実装の中で、これよりも知的で面白い点としては、m.withAttr、m.propや、ネイティブの.bind()メソッドを使って部分適用させていくことで、イベントハンドリングが関数合成の文脈で行うことができる点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A noteworthy difference between Angular and Mithril is in framework complexity: Angular implements several subsystems that would seem more logical in programming language implementations (e.g. a parser, a dynamic scoping mechanism, decorators, etc).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095100Z" creationid="shibukawa.yoshiki" creationdate="20150420T095100Z">
        <seg>AngularとMithrilの大きな違いといえば、フレームワークの複雑さです。Angularは数々のサブシステムを持ち、パーサ、動的スコープシステム、デコレータなどより多くのプログラミング言語によるロジックを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A particularly nasty instance of this problem that sometimes occurs in "real-time" applications is when event triggering chains become circular due to a conditional statement bug, causing infinite loops and browser crashes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T021258Z" creationid="shibukawa.yoshiki" creationdate="20150420T021047Z">
        <seg>「リアルタイム」を標榜するアプリケーションでこの問題をこじらせると、条件判断を間違えてイベントのトリガーが循環し、無限ループができてしまってブラウザが応答しなくなることもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A password for HTTP authentication.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002357Z" creationid="shibukawa.yoshiki" creationdate="20150415T002357Z">
        <seg>HTTP認証のパスワード。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A preprocessor function to unwrap the data from a success response in case the response contains metadata wrapping the data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012651Z" creationid="shibukawa.yoshiki" creationdate="20150415T012651Z">
        <seg>レスポンス成功時に、レスポンスに含まれるメタデータなどからデータを取り出す時に使用するプリプロセッサです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A preprocessor function to unwrap the data from an error response in case the response contains metadata wrapping the data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013033Z" creationid="shibukawa.yoshiki" creationdate="20150415T013033Z">
        <seg>レスポンス失敗時に、レスポンスに含まれるメタデータなどからデータを取り出す時に使用するプリプロセッサです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A promise has a method called then which takes two computation callbacks as parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174919Z" creationid="shibukawa.yoshiki" creationdate="20150415T174919Z">
        <seg>promiseは、2つの計算のコールバックを持つthenメソッドを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A promise is also a getter-setter (see m.prop).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175059Z" creationid="shibukawa.yoshiki" creationdate="20150415T175059Z">
        <seg>promiseはgetter-setter (m.prop参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A route with parameters might look like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170600Z" creationid="shibukawa.yoshiki" creationdate="20150414T170600Z">
        <seg>パラメータ付きのラウトは次のような文字列です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A route without parameters looks like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170538Z" creationid="shibukawa.yoshiki" creationdate="20150414T170538Z">
        <seg>パラメータのないラウトは次のようなものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A routing utility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153221Z" creationid="shibukawa.yoshiki" creationdate="20150412T153221Z">
        <seg>ラウティングユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string containing HTML markup</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015438Z" creationid="shibukawa.yoshiki" creationdate="20150416T015438Z">
        <seg>HTMLマークアップを含む文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A user for HTTP authentication.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002342Z" creationid="shibukawa.yoshiki" creationdate="20150415T002331Z">
        <seg>HTTP認証のユーザ名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A utility to create virtual elements</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153122Z" creationid="shibukawa.yoshiki" creationdate="20150412T153122Z">
        <seg>仮想エレメントを作るためのユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A view-model is a model level entity that stores UI state.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152444Z" creationid="shibukawa.yoshiki" creationdate="20150407T152444Z">
        <seg>ビュー・モデルはモデルレベルのエンティティで、UIの状態を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aborting a request</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174655Z" creationid="shibukawa.yoshiki" creationdate="20150414T174655Z">
        <seg>リクエストの中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Above, dashboard is a component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135159Z" creationid="shibukawa.yoshiki" creationdate="20150502T135159Z">
        <seg>上記のサンプルのdashboardはコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Above, dashboard is a module.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003508Z" creationid="shibukawa.yoshiki" creationdate="20150410T003508Z">
        <seg>上記のサンプルのdashboardはモジュールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing the real DOM element</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T234151Z" creationid="shibukawa.yoshiki" creationdate="20150412T234151Z">
        <seg>本物のDOM要素へアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to the classic definition of the MVC pattern, the model layer is responsible for data storage, state management and business logic.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151156Z" creationid="shibukawa.yoshiki" creationdate="20150407T151156Z">
        <seg>昔ながらのMVCパターンの定義によると、モデルレイヤはデータの保持、状態の管理、ビジネスロジックについての責務を負っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to the specs, the &lt;html&gt;, &lt;head&gt; and &lt;body&gt; tags can be omitted, but their respective DOM elements will still be there implicitly when a browser renders that markup.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T144133Z" creationid="shibukawa.yoshiki" creationdate="20150407T144133Z">
        <seg>HTMLの規格によると、&lt;html&gt;、&lt;head&gt;、&lt;body&gt;タグは省略できますが、ブラウザがマークアップをレンダリングするときに暗黙的にそれぞれのDOMエレメントを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, calling m.redraw synchronously after calling m.redraw.strategy("none") resets the strategy to "diff".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150834Z" creationid="shibukawa.yoshiki" creationdate="20150416T150834Z">
        <seg>また、m.redraw.strategy("none")を呼んだ後にm.redrawを同期的に呼んだ場合には、戦略は"diff"にリセットされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Advanced Topics</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140749Z" creationid="shibukawa.yoshiki" creationdate="20150407T140749Z">
        <seg>上級トピック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After a call to either resolve or reject, it holds the result of the parent's computation (or the resolve/reject value, if the promise has no parent promises)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175418Z" creationid="shibukawa.yoshiki" creationdate="20150415T175418Z">
        <seg>resolveとrejectのどちらを呼んでも、promiseは親の計算結果の値 (もしくはpromiseが親を持っていなければresolve/reject)を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After that, Mithril resets the m.redraw.strategy flag to either "all" or "diff" depending on whether the redraw was due to a route change or whether it was triggered by some other action.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155843Z" creationid="shibukawa.yoshiki" creationdate="20150416T155843Z">
        <seg>再描画が完了すると、Mithrilは再描画がの原因が他のアクションにあるかどうかをを元にして、m.redraw.strategyの設定を"all"か"diff"に変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the redraw, Mithril resets the value of the flag to either "all" or "diff", depending on whether the redraw was due to a route change or not.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T140302Z" creationid="shibukawa.yoshiki" creationdate="20150416T140302Z">
        <seg>再描画が完了すると、Mithrilは再描画がラウトの変更に起因するものかどうかによって、この設定を"all"か"diff"に変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregating requests in a top-level component makes it easier to replay the request chain (i.e. fetching an updated list of items after you've saved something that changes that list), and it ensures the entire data set is loaded in memory before drilling down into nested components, avoiding redundant AJAX calls for sibling components that need the same data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084936Z" creationid="shibukawa.yoshiki" creationdate="20150502T084822Z">
        <seg>リクエストをトップレベルのコンポーネントに集約することは、リスト内のデータを変更した後などに再度リクエストを行うのが簡単になります。ネストされたコンポーネントをたどっていく前に必要なデータセットが確実に存在することを保証できますし、兄弟コンポーネントで同じデータを何度もリクエストするのを防げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregating responsibility in a top-level component allows the developer to manage multiple model entities easily: any given AJAX request only needs to be performed once regardless of how many components need its data, and refreshing the data set is simple.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T005427Z" creationid="shibukawa.yoshiki" creationdate="20150502T005427Z">
        <seg>責務とトップレベルのコンポーネントで統合するという方法は、複数のモデルエンティティを持つ場合の管理を楽にします。多くのコンポーネントがサーバ側のデータを必要としても、AJAXアクセスをまとめて通信をシンプルにしたり、データのリフレッシュが行い易くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregation of responsibility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180047Z" creationid="shibukawa.yoshiki" creationdate="20150501T180047Z">
        <seg>責務の集約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All API points are explained in prose, and have code examples.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114416Z" creationid="shibukawa.yoshiki" creationdate="20150417T114416Z">
        <seg>すべてのAPIは人間に読みやすいように書かれており、サンプルコードもたくさん書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that concatenating or splitting a trusted string removes the trust flag.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015655Z" creationid="shibukawa.yoshiki" creationdate="20150416T015655Z">
        <seg>また、文字列を結合したり、分割すると、信頼フラグは削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that the config callback only runs after a rendering lifecycle is done.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124801Z" creationid="shibukawa.yoshiki" creationdate="20150413T124801Z">
        <seg>また、configコールバックはレンダリングのライフサイクルが終わった時にしか呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that, unlike observable-based frameworks like Knockout.js, setting a value in a m.prop getter-setter does NOT trigger redrawing side-effects in Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014658Z" creationid="shibukawa.yoshiki" creationdate="20150408T014658Z">
        <seg>MithrilはKnockout.jsのようなObservableベースのフレームワークとは異なり、m.propのgetter-setterに値を設定しても、再描画が起動されるような副作用は発生しないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, keys must be either strings or numbers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142219Z" creationid="shibukawa.yoshiki" creationdate="20150413T142219Z">
        <seg>キーは文字列でも数値でも大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, notice that since these components are designed to encapsulate their behavior, they cannot easily affect other components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015346Z" creationid="shibukawa.yoshiki" creationdate="20150502T015346Z">
        <seg>また、それぞれのコンポーネントの動作はカプセル化されているため、他のモジュールを外部から操作することは簡単にはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can also explore other techniques in order to achieve better performance and expressiveness.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015842Z" creationid="shibukawa.yoshiki" creationdate="20150413T015842Z">
        <seg>バインディングに関してパフォーマンスと表現を改善する他の方法についてはブログの記事で学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An URI encoded querystring to be deserialized</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135935Z" creationid="shibukawa.yoshiki" creationdate="20150502T135935Z">
        <seg>デシリアライズするURIエンコーディングされたクエリー文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alert box will appear when the upload finishes"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034917Z" creationid="shibukawa.yoshiki" creationdate="20150502T034917Z">
        <seg>アップロードが完了するとアラートボックスが表示されます。"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An element is considered "different enough" if:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135347Z" creationid="shibukawa.yoshiki" creationdate="20150413T135347Z">
        <seg>「大きく異る」の判定基準は:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An execution thread is basically any amount of code that runs before other asynchronous threads start to run.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155935Z" creationid="shibukawa.yoshiki" creationdate="20150412T004720Z">
        <seg>実行スレッドは基本的に、他の非同期スレッドが実行する前に、ある程度の量のコードを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An initialization function that runs after open and before send.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013955Z" creationid="shibukawa.yoshiki" creationdate="20150415T013943Z">
        <seg>openとsendの間に呼ばれる初期化関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An initialization value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135822Z" creationid="shibukawa.yoshiki" creationdate="20150414T135712Z">
        <seg>初期値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance of the controller constructor</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T024717Z" creationid="shibukawa.yoshiki" creationdate="20150414T024717Z">
        <seg>コントローラコンストラクタのインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object that retains its state across redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155255Z" creationid="shibukawa.yoshiki" creationdate="20150413T155255Z">
        <seg>再描画間で状態を保持するオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object to be serialized</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170954Z" creationid="shibukawa.yoshiki" creationdate="20150414T170954Z">
        <seg>シリアライズしたいオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And because Mithril views are Javascript, the developer has full freedom to abstract common patterns - from bidirectional binding helpers to full blown components - using standard Javascript refactoring techniques.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021942Z" creationid="shibukawa.yoshiki" creationdate="20150409T015129Z">
        <seg>MithrilのビューがJavaScriptであることから、破壊的なコンポーネントに対する双方向バインディングヘルパーといった、抽象的な一般化のパターンから開発者が開放されます。一般的なJavaScriptのリファクタリングテクニックが利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if you really do want to use HTML syntax after all, you can use a package called MSX.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T014543Z" creationid="shibukawa.yoshiki" creationdate="20150409T014543Z">
        <seg>それでもHTMLの文法を使いたいということであれば、MSXと呼ばれるパッケージが使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And moving the responsibility of saving to the ContactForm component alleviates the need to send data back up the component tree, making the handling of non-idempotent operations less prone to pass-through argument noise.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031049Z" creationid="shibukawa.yoshiki" creationdate="20150502T031049Z">
        <seg>また、保存の責務をContactFormコンポーネントに移動したことで、コンポーネントツリーをさかのぼってデータを渡す必要は軽減されています。 引数を使ってパススルーするノイズも減らしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152205Z" creationid="shibukawa.yoshiki" creationdate="20150407T152205Z">
        <seg>他にもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And the data is [{name: "John"}, {name: "Mary"}], then the response will contain an array of two User instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013928Z" creationid="shibukawa.yoshiki" creationdate="20150415T013928Z">
        <seg>そして、サーバから[{name: "John"}, {name: "Mary"}]というデータが帰ってくると、レスポンスはUserクラスのインスタンスを2つ含む配列になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And this is for every list that needs to be displayed in some way.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014441Z" creationid="shibukawa.yoshiki" creationdate="20150420T014441Z">
        <seg>リストを表示するコードを実装するときは、毎回この作業が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And you can download Mithril by typing this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235523Z" creationid="shibukawa.yoshiki" creationdate="20150407T235523Z">
        <seg>このあと、次のようにタイプするとMithrilをダウンロードすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Angular is an MVC framework maintained by Google, and it provides a declarative view layer and an emphasis on testability.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025013Z" creationid="shibukawa.yoshiki" creationdate="20150420T025013Z">
        <seg>AngularはGoogleにより開発が行われているMVCフレームワークで、宣言的なビューとテストしやすさに重点が置かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another difference is that Mithril, being an MVC framework, rather than a templating engine, provides an auto-redrawing system that is aware of network asynchrony and that can render views efficiently without cluttering application code with redraw calls, and without letting the developer unintentionally bleed out of the MVC pattern.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105303Z" creationid="shibukawa.yoshiki" creationdate="20150420T105303Z">
        <seg>他に違う点といえば、Mithrilは単なるテンプレートエンジンではなく、MVCフレームワークとして統一的に動作するように作られているため、アプリケーションコードに再描画命令を挟み込んでMVCフレームワークのパターンを逸脱することなく、非同期通信のネットワークアクセスなどを探知して適切に再描画行う再描画エンジンを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another feature - the optional m() utility - allows writing terse templates in a declarative style using CSS shorthands, similar to popular HTML preprocessors from server-side MVC frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021918Z" creationid="shibukawa.yoshiki" creationdate="20150409T014927Z">
        <seg>m()ユーティリティが持つ他の機能としては、CSS的な記述方法で完結にテンプレートが記述できます。これは一般的なサーバサイドMVCフレームワークのHTML処理と似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another marking difference is that Backbone is workflow agnostic, providing no idiomatic way to organize applications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020252Z" creationid="shibukawa.yoshiki" creationdate="20150420T020252Z">
        <seg>他に異なる点としては、Backboneはワークフローに関しては関与しません。アプリケーションを組み立てていくための手順に関しては特に定めていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another point of comparison is documentation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113935Z" creationid="shibukawa.yoshiki" creationdate="20150417T113935Z">
        <seg>もう１つの比較ポイントはドキュメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another side-effect is that UI state like input focus is not tracked correctly if the focused element moves around, and likewise, state for 3rd party plugins that are added via config can also end up in the wrong element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141431Z" creationid="shibukawa.yoshiki" creationdate="20150413T141431Z">
        <seg>他の副作用としては、フォーカスを持ったエレメントが移動してしまったり、configを通じて追加されたサードパーティのプラグインが違うエレメントの内側に移動してしまう可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another significant difference between Backbone and Mithril is in their approach to familiarity: Backbone appeals to people familiar w/ jQuery; Mithril is designed to be familiar to people with server-side MVC framework experience.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T024834Z" creationid="shibukawa.yoshiki" creationdate="20150420T024834Z">
        <seg>それ以外の違いとしては、フレームワークがターゲットとしている層です。BackboneはjQueryに慣れている人にアプローチしています。MithrilはサーバサイドMVCフレームワークの経験を持っている人が親しみやすいように設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way of organizing code is to distribute concrete responsibilities across multiple modules.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013600Z" creationid="shibukawa.yoshiki" creationdate="20150502T013600Z">
        <seg>他のコードの構築方法としては、具体的な責務をモジュール間に分配する方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any code that is between a m.startComputation and its respective m.endComputation call is said to live in the context of its respective pair of function calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T185444Z" creationid="shibukawa.yoshiki" creationdate="20150411T185444Z">
        <seg>m.startComputation呼び出しと、対応するm.endComputation呼び出しにあるコードは、Mithrilの文脈では、「同じペアの関数呼び出しのコンテキスト内に存在する」と表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any time an exception is thrown inside a promise callback, Mithril calls m.deferred.onerror(e).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174241Z" creationid="shibukawa.yoshiki" creationdate="20150415T174241Z">
        <seg>promiseコールバックの中で例外が発生すると、Mithrilはm.deferred.onerror(e)を呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application architecture with components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180000Z" creationid="shibukawa.yoshiki" creationdate="20150501T180000Z">
        <seg>アプリケーションアーキテクチャとコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Architecture</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114907Z" creationid="shibukawa.yoshiki" creationdate="20150417T114907Z">
        <seg>アーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the controller runs again, the DOM is re-generated, and any applicable 3rd party plugins in configs are re-initialized.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090552Z" creationid="shibukawa.yoshiki" creationdate="20150502T090552Z">
        <seg>これにより、コントローラが再実行され、DOMが再生成されます。また、サードパーティのプラグインがconfigで設定されていた場合には、これも最初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a rule of thumb, controllers should not change model entity properties on an individual basis.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T031859Z" creationid="shibukawa.yoshiki" creationdate="20150421T014126Z">
        <seg>経験則として、コントローラがモデルのプロパティを直接変更すべきではない、というものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a rule of thumb, you should never implement performance optimizations if another solution is available.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142929Z" creationid="shibukawa.yoshiki" creationdate="20150412T142929Z">
        <seg>一般的な方針として、他のソリューションがある場合には、絶対にパフォーマンスの最適化を行わないほうが良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As it turns out, this design decision is actually a compromise: it offers the benefit of decreased application code complexity at the cost of some performance loss.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014911Z" creationid="shibukawa.yoshiki" creationdate="20150420T014911Z">
        <seg>通常、このような設計の決定は折衷案になりがちです。アプリケーションコードの複雑さを減らそうとすると、パフォーマンスのコストが必要になったりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as the event handler returns, the strategy is set back to "diff".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150525Z" creationid="shibukawa.yoshiki" creationdate="20150416T150525Z">
        <seg>イベントハンドラが完了すると、再び"diff"に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As summarized above, Mithril differs from jQuery by allowing DOM-related code to be written largely in a declarative style (thereby decreasing code complexity), in addition to providing an idiomatic way to structure applications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015629Z" creationid="shibukawa.yoshiki" creationdate="20150420T015629Z">
        <seg>言い換えると、MithrilとjQueryの書き方は大きく異なっています。Mithrilは宣言的なスタイルでDOM関連のコードを書くことが可能で、コードの複雑さは低減されています。それに加えて、共通のアプリケーションの構造を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with Angular, Knockout templates are written in HTML, and therefore have the same pros and cons as Angular templates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105833Z" creationid="shibukawa.yoshiki" creationdate="20150420T105833Z">
        <seg>また、Angularと同様にテンプレートがHTMLに書かれるため、Angularのテンプレートと同じ利点・欠点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with input focus, we can maintain referential integrity between data in a list and the respective DOM representation by using keys.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150247Z" creationid="shibukawa.yoshiki" creationdate="20150413T150247Z">
        <seg>入力のフォーカスと同様に、キーを使うとリスト内のデータとそのDOM表現間の参照の整合性を維持できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with jQuery, Mithril differs from Backbone by enforcing view code to be written in a declarative style.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020128Z" creationid="shibukawa.yoshiki" creationdate="20150420T020128Z">
        <seg>BackboneとjQueryとの組み合わせたスタイルを使う場合、Mithrilではビューコードの記述に宣言的なスタイルが強要されるため、大きくことなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, flow control is done with vanilla Javascript.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002654Z" creationid="shibukawa.yoshiki" creationdate="20150413T002559Z">
        <seg>このように、普通のJavaScriptの文法を利用してフロー制御を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, it paints a much less flattering picture for some frameworks than when we look at gzipped size alone.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113909Z" creationid="shibukawa.yoshiki" creationdate="20150417T113909Z">
        <seg>すでにご覧になられたとおり、大げさではなくて、gzipされたサイズ以上のパフォーマンスが出ている事がわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, we return a partial template with two &lt;td&gt;'s.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153237Z" creationid="shibukawa.yoshiki" creationdate="20150408T153237Z">
        <seg>このメソッドは、ご覧のとおりに、2つの&lt;td&gt;タグを持つ、部分テンプレートを返しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, you can use CSS selectors to specify attributes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004324Z" creationid="shibukawa.yoshiki" creationdate="20150408T004324Z">
        <seg>CSSセレクタを使って要素を選択することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you may recall, models are responsible for encapsulating business logic, and view-models encapsulate logic that pertains specifically to UI state, so there's really nothing else for a controller to abstract away, and all it needs to do is expose a slice of the model layer that pertains to the UI that is currently in view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004036Z" creationid="shibukawa.yoshiki" creationdate="20150408T004036Z">
        <seg>ここで今まで出てきたロールを思い出してみてください。モデルはビジネスロジックのカプセル化、ビュー・モデルは特定のUI状態に関するロジックのカプセル化を行います。抽象化された役割の中でコントローラが行うべきものは、モデルの中から、現在の表示されているものを切り出して表示するという役割以外は残っていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you saw, you can chain operations that act on the response data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125423Z" creationid="shibukawa.yoshiki" creationdate="20150410T125423Z">
        <seg>これまで見てきたとおり、レスポンスで返されたデータに対して処理のオペレーションをいくつもチェーンさせて追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming NodeJS is already installed, run the following command to install GruntJS:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150453Z" creationid="shibukawa.yoshiki" creationdate="20150412T150453Z">
        <seg>NodeJSがすでにインストールされているとすると、次のコマンドをタイプするとGruntJSがインストールされます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming a document has an empty &lt;body&gt; element, the code below:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123317Z" creationid="shibukawa.yoshiki" creationdate="20150416T081357Z">
        <seg>ドキュメントは空の&lt;body&gt;エレメントを持っているとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming you have NodeJS installed, you can download Mithril by typing this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235211Z" creationid="shibukawa.yoshiki" creationdate="20150407T170054Z">
        <seg>NodeJSがインストールされているものとすると，次のようにタイプすることでMithrilをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming you have NodeJS installed, you can install Bower by typing this in the command line:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235149Z" creationid="shibukawa.yoshiki" creationdate="20150407T235149Z">
        <seg>NodeJSがインストールされているものとすると，次のようにタイプすることでBowerをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming you have NodeJS installed, you can install Component by typing this in the command line:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000021Z" creationid="shibukawa.yoshiki" creationdate="20150408T000021Z">
        <seg>NodeJSがインストールされているものとすると，次のようにタイプすることでComponentをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming your templates have appropriate null checks in place, m.redraw is useful for transient DOM state such as loading indicators and to commit state to the DOM for the purposes of reading back computed values (for example, offsetWidth or scrollHeight)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130458Z" creationid="shibukawa.yoshiki" creationdate="20150502T130458Z">
        <seg>テンプレートでは適切にnullチェックが行われていると仮定すると、m.redrawはローディングのインジケータ表示したり、 offsetWidthやscrollHeightの値を元にDOMの状態を変更しにいく時には便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At a glance it may seem like we're doing something very expensive by redrawing, but as it turns out, calling the todo.view method multiple times does not actually re-render the entire template.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015426Z" creationid="shibukawa.yoshiki" creationdate="20150408T015426Z">
        <seg>一見すると、このコードは再描画を何度も行っていて、とても実行コストが高そうに見えますが、todo.viewメソッドを何度呼び出しても、実際にはテンプレート全体が再描画されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to unwrap its value early will likely result in errors.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015311Z" creationid="shibukawa.yoshiki" creationdate="20150410T015311Z">
        <seg>そのため、データを早期にアンラップしようとするとおそらくエラーになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatic HTML-to-Mithril Template Converter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013614Z" creationid="shibukawa.yoshiki" creationdate="20150417T013614Z">
        <seg>自動HTML→Mithirilテンプレートコンバータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automating Compilation</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150242Z" creationid="shibukawa.yoshiki" creationdate="20150412T150242Z">
        <seg>自動コンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backbone was originally designed as a way to structure jQuery-based applications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015758Z" creationid="shibukawa.yoshiki" creationdate="20150420T015758Z">
        <seg>Backboneは当初、jQueryベースのアプリケーションの構造化をする目的で設計されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic usage</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014521Z" creationid="shibukawa.yoshiki" creationdate="20150410T014521Z">
        <seg>基本的な使い方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be aware that by using the native Array class, we're making an implicit statement that we are going to support all of the standard Array methods as part of our API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002837Z" creationid="shibukawa.yoshiki" creationdate="20150409T002837Z">
        <seg>ネイティブのArrayクラスを使ったお陰で、標準のArrayクラスのメソッドを自分自身のAPIとして暗黙的に使えるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be aware that even though Mithril has tests running in a continuous integration environment, the bleeding edge version might occasionally break.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000533Z" creationid="shibukawa.yoshiki" creationdate="20150408T000533Z">
        <seg>Mithrilは継続的インテグレーション環境を使ってテストされていますが、最先端のバージョンは頻繁に機能しなくなる可能性がありますので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be sure to read the Application Architecture section to learn more about organizing componentized code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085142Z" creationid="shibukawa.yoshiki" creationdate="20150502T085142Z">
        <seg>コンポーネント化されたコードの構成については、アプリケーションアーキテクチャのセクションをお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Mithril encourages all entity logic to be done in the model layer, it's idiomatic to create modules with model-level classes that deal specifically with relationships between entities, when there isn't already a model entity that can logically hold the relational business logic.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033306Z" creationid="shibukawa.yoshiki" creationdate="20150421T033306Z">
        <seg>Mithrilでは、エンティティのロジックはすべてモデルレイヤ内に置かれるのが推奨されます。エンティティ間の関係を取り扱う必要が出てきたら、コントローラのレイヤーにコードを足すのではなく、新たに専門のモデルレベルのクラスを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the DOM is by far the largest bottleneck in rendering engines, Mithril's approach of running a diff against a virtual representation of the DOM and only batching changes to the real DOM as needed is surprisingly performant.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184338Z" creationid="shibukawa.yoshiki" creationdate="20150411T184338Z">
        <seg>DOMはレンダリングエンジンにとって最大のボトルネックであるため、MithrilのDOMの仮想表現に対して差分をとり、必要に応じてバッチで実際のDOMを変更するアプローチは、驚くべきパフォーマンスを達成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the entire documentation is hand-crafted, you get the benefit of actually having explanations for things that documentation-generator tools don't support well (for example, interfaces and callback parameter documentation).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114600Z" creationid="shibukawa.yoshiki" creationdate="20150417T114600Z">
        <seg>すべてのドキュメントが人の手で書かれているため、ドキュメントに知りたい情報がきちんとかかれているというメリットがあります。ドキュメント生成ツールではインタフェースやコールバックのパラメータなどが抜けがちです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this handler is not created using Mithril's templating engine (i.e. we're not defining an attribute in a virtual element), we must manually integrate it to the auto-redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134225Z" creationid="shibukawa.yoshiki" creationdate="20150412T134225Z">
        <seg>仮想エレメントの中でこの属性を使用しなかった場合など、もしこのハンドラがMithrilのテンプレートで作成されていない場合は、手動で自動再描画システムに統合する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Below are some examples of consuming the Uploader component:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034534Z" creationid="shibukawa.yoshiki" creationdate="20150502T034534Z">
        <seg>次のコードはUploaderコンポーネントの使用例です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Below is an example where various methods implemented with a third party library can be integrated in layered fashion: any of the methods can be used in isolation or in combination.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T005157Z" creationid="shibukawa.yoshiki" creationdate="20150412T005157Z">
        <seg>次のサンプルは、多くのメソッドがサードパーティ製ライブラリを使っているコードを、階層に分けて統合したコードになります。メソッドの中には個別に使われるものもあれば、組み合わせて使われるものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Benchmarks</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141004Z" creationid="shibukawa.yoshiki" creationdate="20150407T141004Z">
        <seg>ベンチマーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bind redirection code</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124256Z" creationid="shibukawa.yoshiki" creationdate="20150410T124256Z">
        <seg>リダイレクトするコードのバインド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binding errors</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124707Z" creationid="shibukawa.yoshiki" creationdate="20150410T124707Z">
        <seg>エラーのバインド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binding to data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T160146Z" creationid="shibukawa.yoshiki" creationdate="20150412T160146Z">
        <seg>データへバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both can be compiled, but React's compiled code still has function calls for each virtual DOM element; Mithril templates compile into static Javascript data structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T100330Z" creationid="shibukawa.yoshiki" creationdate="20150420T100330Z">
        <seg>どちらもコンパイルは可能ですが、Reactのコンパイル済みのコードには仮想DOMエレメントごとの関数呼び出しが残っています。Mithrilのテンプレートは静的なJavaScriptのデータ構造になるため、関数呼び出しはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both components use a menu template, which contains links for navigation between the two components, and an expensive-to-reinitialize element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124841Z" creationid="shibukawa.yoshiki" creationdate="20150502T124841Z">
        <seg>どちらのコンポーネントもmenuテンプレートを使用しています。このテンプレーには2つのコンポーネント間をナビゲートするリンクがあります。そして、最初期化のコストが非常に高いエレメントだとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Browsers do, however, allow scripts to be run asynchronously via a number of execution points, such as the onload or onerror attributes in &lt;img&gt; and &lt;iframe&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014634Z" creationid="shibukawa.yoshiki" creationdate="20150416T014634Z">
        <seg>しかし、ブラウザが非同期でスクリプトの実行を行うポイントがいくつかあります。&lt;img&gt;と&lt;iframe&gt;に含まれるonload、onerror属性などです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Build a simple application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135538Z" creationid="shibukawa.yoshiki" creationdate="20150407T135538Z">
        <seg>小さなアプリケーションを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By bundling model methods in the component, we avoid hard-coding how files are handled once they're dropped in, and instead, we provide a useful library of functions that can be consumed flexibly to meet the demands on an application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034046Z" creationid="shibukawa.yoshiki" creationdate="20150502T034046Z">
        <seg>コンポーネントにモデルメソッドをバンドルするときは、どのようにファイルを取り扱うかをハードコーディングするのを避けます。アプリケーションの需要に応じて柔軟に使用できる関数ライブラリを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, m.request uses JSON to send and receive data to web services.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174901Z" creationid="shibukawa.yoshiki" creationdate="20150410T174901Z">
        <seg>デフォルトでは、m.requestはウェブサービスとのデータの送受信にJSONを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, serialize converts an object to JSON, but in the case of a FormData payload, you want to pass the object intact.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175449Z" creationid="shibukawa.yoshiki" creationdate="20150414T175449Z">
        <seg>デフォルトではserializeはオブジェクトをJSONに変換しますが、FormDataをペイロードとして使う場合には、オブジェクトをそのまま流します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril assumes both success and error responses are in JSON format, but some servers may not return JSON responses when returning HTTP error codes (e.g. 404)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175634Z" creationid="shibukawa.yoshiki" creationdate="20150414T175634Z">
        <seg>デフォルトでは、Mithrilは成功時も失敗時もレスポンスはJSONフォーマットで帰ってくるものとみなしてパースしようとしますが、サーバの中には404のようなエラーコードを返す時にJSONを返さないものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril does not swallow errors if these errors are subclasses of the Error class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T141042Z" creationid="shibukawa.yoshiki" creationdate="20150415T141042Z">
        <seg>デフォルトでは、MithrilはエラーがErrorクラスのサブクラスであれば、必ずフレームワーク外までそれを届けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril escapes HTML strings in order to help prevent XSS attacks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020908Z" creationid="shibukawa.yoshiki" creationdate="20150413T020908Z">
        <seg>デフォルトでは、MithrilはXSS攻撃を防ぐためにHTMLの文字列をエスケープします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril is configured to auto-redraw from scratch after component controllers are initialized, and it is configured to diff after event handlers are triggered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150505T234934Z" creationid="shibukawa.yoshiki" creationdate="20150505T234934Z">
        <seg>デフォルトでは、コンポーネントのコントローラが初期化されるとゼロから再描画を行う設定になっていて、イベントハンドラが起動されると差分描画が行われるように設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril sets this value to "all" before running controller constructors, and it sets it to "diff" before event handlers are triggered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T131100Z" creationid="shibukawa.yoshiki" creationdate="20150416T131055Z">
        <seg>Mithirlのデフォルト"all"で、コントローラのコンストラクタが実行される・イベントハンドラが起動される前に、差分を取得します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril uses window itself as the dependency.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161043Z" creationid="shibukawa.yoshiki" creationdate="20150416T161043Z">
        <seg>デフォルトではMithrilは依存先としてwindow自身を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Mithril waits for web service requests to complete before attempting a redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235712Z" creationid="shibukawa.yoshiki" creationdate="20150414T235712Z">
        <seg>デフォルトでは、Mithrilはウェブサービスへのリクエストが完了するまでは再描画を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, event handlers schedule redraws to be done asynchronously in order to allow simultaneous events to run before redrawing (for example, the keypress and input are often used together for inputs).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152141Z" creationid="shibukawa.yoshiki" creationdate="20150416T152141Z">
        <seg>デフォルトでは、イベントハンドラは非同期で再描画を行うようにスケジュールします。これにより、同じ入力フォームに対して同時に使われるkeypressとinputなどの複数のイベントを再描画前にまとめて実行し、再描画の回数を減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, it assumes server responses are in JSON format and optionally instantiates a class with the response data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174821Z" creationid="shibukawa.yoshiki" creationdate="20150414T174821Z">
        <seg>デフォルトではサーバのレスポンスはJSONとみなして解釈します。また、オプションでレスポンスデータを元にクラスのインスタンスを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, it rethrows to the console if an error is a subclass of Error (but not an instance of Error itself).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180334Z" creationid="shibukawa.yoshiki" creationdate="20150415T180334Z">
        <seg>デフォルトでは、このイベントハンドラはこのエラーがErrorのサブクラスの例外で、Errorそのもののインスタンスでなければコンソールにその例外を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, promises are not integrated to the Mithril auto-redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135332Z" creationid="shibukawa.yoshiki" creationdate="20150415T135332Z">
        <seg>デフォルトでは、promiseはMithrilの自動再描画システムとは統合しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the querystring is considered the URL component to test against the routes collection</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165457Z" creationid="shibukawa.yoshiki" creationdate="20150414T165457Z">
        <seg>デフォルトではラウト集に対してクエリー文字列がURLの構成要素として解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the spec requires that all thrown errors trigger rejection, which result in silent failures if the developer forgets to explicitly handle the failure case.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172608Z" creationid="shibukawa.yoshiki" creationdate="20150415T172355Z">
        <seg>デフォルトでは、Promise/A+の仕様ではすべての例外はrejectionを起動しますが、開発者がこの失敗時のコールバックを設定し忘れると、誰もエラーを受け取らずに例外は握りつぶされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, this event handler rethrows the exception to the console if an error is a subclass of Error (but not an instance of Error itself).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174340Z" creationid="shibukawa.yoshiki" creationdate="20150415T174340Z">
        <seg>デフォルトでは、このイベントハンドラはこのエラーがErrorのサブクラスの例外で、Errorそのもののインスタンスでなければコンソールにその例外を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By freezing APIs and swapping implementations, the developer can completely avoid touching other layers in the application while refactoring.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003758Z" creationid="shibukawa.yoshiki" creationdate="20150409T003758Z">
        <seg>APIをフリーズしたり実装を交換したりするだけであれば、リファクタリングを行う際に他のレイヤをまったく触る必要はなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By nature, optimizing performance make aggressive assumptions that can break in edge cases and it yields difficult to understand code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142625Z" creationid="shibukawa.yoshiki" creationdate="20150412T142625Z">
        <seg>パフォーマンスの最適化でやりがちなこととしては、特殊なケースですぐに成り立たなくなるような思い込みを行い、コードの理解が極めて難しいコードを書いてしまうということがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By strategically placing calls to this pair of functions, it is possible to stack asynchronous data services in any number of ways within a context without the need to pass state variables around the entire application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190231Z" creationid="shibukawa.yoshiki" creationdate="20150411T190231Z">
        <seg>この関数呼び出しのペアを戦略的に配置することで、アプリケーションコード全体で状態変数を管理する必要性をなくし、データを取得する非同期のサービスをいくつもスタックさせることが可能になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CDNs (Content Delivery Networks)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165147Z" creationid="shibukawa.yoshiki" creationdate="20150407T165147Z">
        <seg>CDN (コンテンツデリバリネットワーク)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call it at the beginning of your test file to supply a mock window:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161336Z" creationid="shibukawa.yoshiki" creationdate="20150416T161336Z">
        <seg>テストファイルの最初でこの関数を呼んで、モックのwindowを設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling e.preventDefault() from a component's onunload function aborts route changes, but it does not abort rollback or affect the current redraw in any way.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092934Z" creationid="shibukawa.yoshiki" creationdate="20150502T092934Z">
        <seg>コンポーネントのonunload関数からe.preventDefault()を呼ぶと、ラウターの変更を中断しますが、ロールバックしたり、現在の再描画への変更を辞めることはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling m.mount with a DOM element as the first argument and a component as the second argument will call the component's controller function, and then call the component's view function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125441Z" creationid="shibukawa.yoshiki" creationdate="20150502T125441Z">
        <seg>m.mountを呼ぶ時は、DOMエレメントを最初の引数に設定し、2つ目の引数にコンポーネントを設定します。まずコンポーネントのcontroller関数が呼ばれ、次にview関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling m.redraw triggers a redraw regardless of whether AJAX requests (and other asynchronous services) are completed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130115Z" creationid="shibukawa.yoshiki" creationdate="20150502T130115Z">
        <seg>m.redrawを呼ぶと、AJAXリクエストや他の非同期サービスが完了しているかどうかに関わらず、再描画処理を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the then method attaches the computations represented by successCallback and errorCallback to the promise, which will be called when either resolve or reject is called.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134626Z" creationid="shibukawa.yoshiki" creationdate="20150415T134626Z">
        <seg>thenメソッドを呼ぶと、 successCallbackと、 errorCallbackで表される計算表現をpromiseに追加します。これは、resolveかrejectが呼ばれると呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling this function without arguments returns the currently assigned redraw strategy.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152649Z" creationid="shibukawa.yoshiki" creationdate="20150416T152649Z">
        <seg>引数を渡さずにこの関数を呼ぶと、現在の再描画戦略を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling this method while using m.mount or m.route should only be done if you have recurring asynchronous view updates (i.e. something that uses setInterval).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045615Z" creationid="shibukawa.yoshiki" creationdate="20150502T045615Z">
        <seg>m.mountとm.routeを使っている場合は、このメソッド呼び出しはsetIntervalを使っている場合など、非同期にビューを繰り返し更新したい場合に限定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Casting the Response Data to a Class</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130540Z" creationid="shibukawa.yoshiki" creationdate="20150410T130440Z">
        <seg>ウェブサービスから帰ってきたデータをクラスにキャスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change log</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154309Z" creationid="shibukawa.yoshiki" creationdate="20150412T154309Z">
        <seg>変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes to controller and model values in this fashion will only render on the next m.render or m.mount call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121719Z" creationid="shibukawa.yoshiki" creationdate="20150502T121719Z">
        <seg>この方法でコントローラやモデルの値を変更しても、次のm.render呼び出しか、m.mount呼び出しがあるまでは描画されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing redraw strategy</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T125045Z" creationid="shibukawa.yoshiki" creationdate="20150416T125045Z">
        <seg>再描画戦略の変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the flag outside of a redrawable context does nothing since the flag gets reset when entering one of the documented redrawable contexts above.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T140537Z" creationid="shibukawa.yoshiki" creationdate="20150416T140537Z">
        <seg>上記の説明に書かれているように、再描画のコンテキストに入る時にこのフラグはリセットされるため、再描画コンテキスト外でこのフラグを設定しても無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the temperature value from the input updates the temperature value, which is passed to the TemperatureConverter view directly, and transformation functions are called from there.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081444Z" creationid="shibukawa.yoshiki" creationdate="20150502T081444Z">
        <seg>入力フォームから温度を入力すると、温度値が変更されてTemperatureConverterに直接渡されます。ここから変換関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classic MVC</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180205Z" creationid="shibukawa.yoshiki" creationdate="20150501T180205Z">
        <seg>クラシックなMVC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clever readers will probably notice that we can refactor the add method to make it much simpler:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152348Z" creationid="shibukawa.yoshiki" creationdate="20150408T152348Z">
        <seg>賢い読者の方は、addメソッドをもっとシンプルなコードにリファクタリングすることができることに気づいたかもしれません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code Size</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015915Z" creationid="shibukawa.yoshiki" creationdate="20150417T015915Z">
        <seg>コードサイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common reasons why one might need to change redraw strategy are:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143924Z" creationid="shibukawa.yoshiki" creationdate="20150416T143924Z">
        <seg>再描画戦略を変更する一般的な理由としては次のようなものがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiling Templates</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140943Z" creationid="shibukawa.yoshiki" creationdate="20150407T140943Z">
        <seg>テンプレートのコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiling a template transforms the nested function calls of a template into a raw virtual DOM tree (which is merely a collection of native Javascript objects that is ready to be rendered via m.render).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144245Z" creationid="shibukawa.yoshiki" creationdate="20150412T144245Z">
        <seg>テンプレートをコンパイルすると、ネストされた関数呼び出しを生の仮想DOMツリーに変換します。これはネイティブのJavaScriptオブジェクトの集合体で、m.renderを使って即座にレンダリングできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiling templates</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143611Z" creationid="shibukawa.yoshiki" creationdate="20150412T143611Z">
        <seg>テンプレートのコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Component views can include other components:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080057Z" creationid="shibukawa.yoshiki" creationdate="20150502T080057Z">
        <seg>コンポーネントのビューは他のコンポーネントを持つことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140744Z" creationid="shibukawa.yoshiki" creationdate="20150407T140744Z">
        <seg>コンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T180346Z" creationid="shibukawa.yoshiki" creationdate="20150410T180346Z">
        <seg>コンポーネント - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components can be stateful, but the purpose of component state is to prevent the pollution of the model layer with aspects that are inherently related to the component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T082912Z" creationid="shibukawa.yoshiki" creationdate="20150502T082912Z">
        <seg>コンポーネントはステートフルにすることもできますが、コンポーネントに状態を持たせる目的は、モデルレイヤーが、コンポーネント内の情報で汚染されるのを防ぐことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components are building blocks for Mithril applications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061139Z" creationid="shibukawa.yoshiki" creationdate="20150502T061139Z">
        <seg>コンポーネントはMithrilのアプリケーションを作成するのに使うブロックです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components are merely structures that represent a viewable "page" or a part of a page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040205Z" creationid="shibukawa.yoshiki" creationdate="20150502T040205Z">
        <seg>コンポーネントは見ることが可能な「ページ」もしくはページの一部を表す、単なる構造体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components are versatile tools to organize code and can be used in a variety of ways.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180342Z" creationid="shibukawa.yoshiki" creationdate="20150501T180342Z">
        <seg>コンポーネントはコードを組織化するのに使える多目的なツールで、さまざまな用途があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components can be placed anywhere a regular element can.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080202Z" creationid="shibukawa.yoshiki" creationdate="20150502T080202Z">
        <seg>コンポーネントは、通常のエレメントが置けるところであればどこにでも置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components can be rendered without enabling the auto-redrawing system, via m.render:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100144Z" creationid="shibukawa.yoshiki" creationdate="20150502T100144Z">
        <seg>コンポーネントは自動再描画システムを有効にせずに描画を行わせることができます。m.renderを使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components can have arguments "preloaded".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075023Z" creationid="shibukawa.yoshiki" creationdate="20150502T075023Z">
        <seg>コンポーネントは「事前にロードされた」引数を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components that are nested inside other components can also call onunload and its e.preventDefault() like top-level components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092543Z" creationid="shibukawa.yoshiki" creationdate="20150502T092510Z">
        <seg>トップレベルのコンポーネントと同様に、他のコンポーネント内にネストされたコンポーネントのonunloadを呼び出し、その中のe.preventDefault()を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comprehensive integration</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010403Z" creationid="shibukawa.yoshiki" creationdate="20150412T010403Z">
        <seg>統括的な統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comprehensive integration is recommended if integrating a monolithic series of asynchronous operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010451Z" creationid="shibukawa.yoshiki" creationdate="20150412T010451Z">
        <seg>非同期の操作が、常に同じ手順で使われている場合には、統括的な統合がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring the underlying XMLHttpRequest</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174649Z" creationid="shibukawa.yoshiki" creationdate="20150414T174649Z">
        <seg>バックエンドのXMLHttpRequestの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conforming to the spec requires either a setImmediate polyfill (which is a significantly large library), or setTimeout (which is required to take at least 4 milliseconds per call, according to its specs).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140848Z" creationid="shibukawa.yoshiki" creationdate="20150415T140848Z">
        <seg>仕様を満たすには、setImmediateポリフィル(将来のバージョンのJavaScriptと互換性を持たせるための、非常に巨大なライブラリ)か、setTimeout(仕様により、最低でも4ミリ秒の待ちが発生する)が要求されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contact.save(data.contact).then(Observable.trigger("updateContact"))
})

//ContactsWidget is the same as before
var ContactsWidget = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031258Z" creationid="shibukawa.yoshiki" creationdate="20150502T031258Z">
        <seg>Contact.save(data.contact).then(Observable.trigger("updateContact"))
})

//ContactsWidgetは以前と同じ
var ContactsWidget = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Content delivery networks allow the library to be cached across different websites that use the same version of the framework, and help reduce latency by serving the files from a server that is physically near the user's location.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165709Z" creationid="shibukawa.yoshiki" creationdate="20150407T165709Z">
        <seg>CDNを使うと、同じバージョンのフレームワーク使用する、さまざまなウェブサイト間でライブラリの共有が可能になります。また、ユーザの場所から物理的に近いサーバからダウンロードが行われるため、表示の遅延を減らすのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controller</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163857Z" creationid="shibukawa.yoshiki" creationdate="20150407T163857Z">
        <seg>コントローラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controller as a class constructor</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045949Z" creationid="shibukawa.yoshiki" creationdate="20150502T045949Z">
        <seg>クラスコンストラクタ形式のコントローラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controllers are deregistered when their onunload event is triggered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021025Z" creationid="shibukawa.yoshiki" creationdate="20150502T021025Z">
        <seg>onunloadイベントが起動されるとコントローラの登録は解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controllers may explicitly call m.redraw, but, if possible, it's preferable to abstract this into a service which integrates with Mithril's auto-redrawing system (see m.startComputation / m.endComputation).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033711Z" creationid="shibukawa.yoshiki" creationdate="20150421T033711Z">
        <seg>コントローラで明示的にm.redrawを呼び出すことも出来ますが、操作を抽象化してMithrilの自動再描画システムと統合する方が望ましいです(m.startComputation / m.endComputation参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153107Z" creationid="shibukawa.yoshiki" creationdate="20150412T153107Z">
        <seg>コア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core Topics</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140757Z" creationid="shibukawa.yoshiki" creationdate="20150407T140623Z">
        <seg>基本トピック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cross-communication in single-purpose components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180149Z" creationid="shibukawa.yoshiki" creationdate="20150501T180149Z">
        <seg>単一目的のコンポーネント間のコミュニケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom request rejections</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174633Z" creationid="shibukawa.yoshiki" creationdate="20150414T174633Z">
        <seg>カスタムリクエストのリジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DOM manipulation should be done in the view via m() and config.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T021348Z" creationid="shibukawa.yoshiki" creationdate="20150421T021246Z">
        <seg>DOM操作は、ビュー内のm()と、configでのみ行うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153741Z" creationid="shibukawa.yoshiki" creationdate="20150412T153741Z">
        <seg>データ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Bindings</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014703Z" creationid="shibukawa.yoshiki" creationdate="20150408T014703Z">
        <seg>データバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data bindings connect a DOM element to a Javascript variable so that updating one updates the other.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014842Z" creationid="shibukawa.yoshiki" creationdate="20150408T014842Z">
        <seg>データバインディングは、DOM要素とJavaScriptの変数変数を結びつけて、片方の変更をもう片方に反映させるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data manipulation should be done in model classes, such that controllers never have entities lying around in temporarily invalid states.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032029Z" creationid="shibukawa.yoshiki" creationdate="20150421T014232Z">
        <seg>データ操作はモデルクラス内で行われるべきです。コントローラが一時的にとはいえ、不完全な状態のモデルを取り扱うべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data to be deserialized</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013247Z" creationid="shibukawa.yoshiki" creationdate="20150415T013247Z">
        <seg>デシリアライズするデータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data to be sent.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002405Z" creationid="shibukawa.yoshiki" creationdate="20150415T002405Z">
        <seg>送信するデータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data to be serialized</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013135Z" creationid="shibukawa.yoshiki" creationdate="20150415T013135Z">
        <seg>シリアライズするデータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data-driven component identity</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050634Z" creationid="shibukawa.yoshiki" creationdate="20150502T050634Z">
        <seg>データ駆動コンポーネントの同一性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dealing with focus</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235035Z" creationid="shibukawa.yoshiki" creationdate="20150412T235035Z">
        <seg>フォーカスの操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dealing with sorting and deleting in lists</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235054Z" creationid="shibukawa.yoshiki" creationdate="20150412T235054Z">
        <seg>リスト内のソートと削除の操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dealing with state</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050550Z" creationid="shibukawa.yoshiki" creationdate="20150502T050550Z">
        <seg>状態の取り扱い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default value is "search".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165706Z" creationid="shibukawa.yoshiki" creationdate="20150414T165706Z">
        <seg>デフォルトは"search"です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to "callback"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014628Z" creationid="shibukawa.yoshiki" creationdate="20150415T014628Z">
        <seg>デフォルト値は"callback"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to false</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152156Z" creationid="shibukawa.yoshiki" creationdate="20150416T152156Z">
        <seg>デフォルト値はfalseです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to undefined</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002340Z" creationid="shibukawa.yoshiki" creationdate="20150415T002340Z">
        <seg>デフォルトはundefined。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to false.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171614Z" creationid="shibukawa.yoshiki" creationdate="20150414T171614Z">
        <seg>デフォルトはfalseです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defending against nullables can typically be achieved via the initialValue option in m.request and basic null checks (e.g. data ?</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121023Z" creationid="shibukawa.yoshiki" creationdate="20150502T121023Z">
        <seg>nullになる可能性がある場合の対処法としては、m.requestにinitialValueオプションを指定するか、基本的なnullチェック(例: data ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines the property of the DOM element whose value will be passed to the callback.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140830Z" creationid="shibukawa.yoshiki" creationdate="20150414T140830Z">
        <seg>この関数のコールバックに渡したい値を持つ、DOMエレメントのプロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines what routes exist</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153238Z" creationid="shibukawa.yoshiki" creationdate="20150412T153238Z">
        <seg>存在するラウトの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162438Z" creationid="shibukawa.yoshiki" creationdate="20150409T162432Z">
        <seg>ラウトの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Demo</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034741Z" creationid="shibukawa.yoshiki" creationdate="20150502T034741Z">
        <seg>デモ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deserializes an object from an URI encoded querystring representation, following the same deserialization conventions as URI.js</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135909Z" creationid="shibukawa.yoshiki" creationdate="20150502T135909Z">
        <seg>URI.jsのデシリアライズ規約を用いて、URIエンコードされたクエリー文字列表現されたオブジェクトをデシリアライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Destructors</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T234210Z" creationid="shibukawa.yoshiki" creationdate="20150412T234210Z">
        <seg>デストラクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Determines whether the m.request can affect template rendering.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002601Z" creationid="shibukawa.yoshiki" creationdate="20150415T002601Z">
        <seg>m.request中にテンプレートのレンダリング行うかどうかの設定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Difference between computation methods and m.redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T112333Z" creationid="shibukawa.yoshiki" creationdate="20150502T112333Z">
        <seg>computationメソッドとm.redrawの違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Differences from Other MVC Frameworks</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140957Z" creationid="shibukawa.yoshiki" creationdate="20150407T140957Z">
        <seg>他のMVCフレームワークとの違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Differences from Promises/A+</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015805Z" creationid="shibukawa.yoshiki" creationdate="20150415T015805Z">
        <seg>Promises/A+との違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Direct download</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164448Z" creationid="shibukawa.yoshiki" creationdate="20150407T164448Z">
        <seg>直接ダウンロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution of concrete responsibilities</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180130Z" creationid="shibukawa.yoshiki" creationdate="20150501T180130Z">
        <seg>具体的な責務の分担</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not create or manipulate trust flags manually.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015611Z" creationid="shibukawa.yoshiki" creationdate="20150416T015611Z">
        <seg>信頼するフラグを手で作成したり変更しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Docs and code samples for your reference</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135618Z" creationid="shibukawa.yoshiki" creationdate="20150407T135618Z">
        <seg>参照用のドキュメントとコードサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113916Z" creationid="shibukawa.yoshiki" creationdate="20150417T113916Z">
        <seg>ドキュメンテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing it in the controller level is also possible, but philosophically not recommended, because by tying logic to a controller, the code becomes harder to reuse due to unrelated controller dependencies.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124045Z" creationid="shibukawa.yoshiki" creationdate="20150410T124045Z">
        <seg>この処理をコントローラのレベルで行うことができますが、Mithrilの哲学としては推奨していません。コントローラと関係ない処理であったとしても、コントローラとロジックが結びついてしまうと再利用が難しくなるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing it in the model level is also possible, but generally leads to more code in order to connect all the dots.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125012Z" creationid="shibukawa.yoshiki" creationdate="20150410T125012Z">
        <seg>もちろん、モデルレベルで行うこともできますが、全ての関連する機能を正しく動かすためには、多くのコードを書く必要がああります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing it in the model level is also possible, but philosophically not recommended, because by tying redirection to the model, the code becomes harder to reuse due to overly tight coupling.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124425Z" creationid="shibukawa.yoshiki" creationdate="20150410T124425Z">
        <seg>この処理をモデル例やで行うことも出来ますが、Mithrilの哲学としては非推奨です。リダイレクト処理とモデルが結びついてしまうと、再利用が難しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing so will trigger another redraw, which will result in an infinite loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094851Z" creationid="shibukawa.yoshiki" creationdate="20150502T094851Z">
        <seg>再描画処理の中で再描画を行ってしまうと、無限ループになってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic parameters are wild cards that allow selecting a component based on a URL pattern.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135745Z" creationid="shibukawa.yoshiki" creationdate="20150502T135745Z">
        <seg>動的パラメータは、URLパターンに応じてコンポーネント選択する時に使用できるワイルドカードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic parameters are words preceded by a colon :</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T160002Z" creationid="shibukawa.yoshiki" creationdate="20150414T160002Z">
        <seg>動的パラメータはコロン(:)で始まっている単語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each m() call creates a virtual DOM element, that is, a Javascript object that represents a DOM element, and which is eventually converted into one.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000527Z" creationid="shibukawa.yoshiki" creationdate="20150413T000527Z">
        <seg>それぞれのm()呼び出して作成される仮想DOM要素は、DOMエレメントに対応する情報を持つJavaScriptオブジェクトで、最終的にDOMエレメントに変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each computation function takes a value as a parameter and is expected to return another value, which in turns is forwarded along to the next computation function (or functions) in the tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T133903Z" creationid="shibukawa.yoshiki" creationdate="20150415T133903Z">
        <seg>それぞれの計算関数はその値を引数として受け取り、他の値を返すことが期待されています。その値は、木の中の次の計算関数に渡されていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of these should point to a Javascript function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100447Z" creationid="shibukawa.yoshiki" creationdate="20150502T100447Z">
        <seg>それぞれ、JavaScriptの関数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of those should point to a Javascript function</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125556Z" creationid="shibukawa.yoshiki" creationdate="20150502T125556Z">
        <seg>このどちらの属性も、JavaScriptの関数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements are recreated if either their node name changes, or if the list of attribute names change, or if the ID attribute changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144131Z" creationid="shibukawa.yoshiki" creationdate="20150413T144131Z">
        <seg>ノード名が変更されたり、属性名のリストが変更されたり、ID属性が変更されれば、エレメントは再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ember is a highly comprehensive MVC framework, providing a large API that covers not only traditional MVC patterns, but also a vast range of helper utilities as well.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095246Z" creationid="shibukawa.yoshiki" creationdate="20150420T095246Z">
        <seg>Emberは伝統的なMVCフレームワークだけではなく、さまざまな大量のヘルパーコードを含む、非常に大きなAPIセットを提供する広範囲に渡るMVCフレームワークです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ember is also more opinionated in terms of how application architecture should look, and as a result, tends to be less transparent in terms of what is actually happening under the hood.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095555Z" creationid="shibukawa.yoshiki" creationdate="20150420T095555Z">
        <seg>Emberはまた、アプリケーションのアーキテクチャがどうあるべきかを厳しく規定しています。そのため、裏で何が起こっているのかが不透明で見通しにくくなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error binding is meant to be done in the controller layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124907Z" creationid="shibukawa.yoshiki" creationdate="20150410T124907Z">
        <seg>Mithrilではエラーのバインディングはコントローラレベルで行われることを想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example URL: http://server/#/path/to/page</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005232Z" creationid="shibukawa.yoshiki" creationdate="20150410T005232Z">
        <seg>サンプルURL: http://server/#/path/to/page</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example URL: http://server/?/path/to/page</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005115Z" creationid="shibukawa.yoshiki" creationdate="20150410T005115Z">
        <seg>サンプルURL: http://server/?/path/to/page</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example URL: http://server/path/to/page</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005502Z" creationid="shibukawa.yoshiki" creationdate="20150410T005502Z">
        <seg>サンプルURL: http://server/path/to/page</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example: HTML5 drag-n-drop file uploader component</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031809Z" creationid="shibukawa.yoshiki" creationdate="20150501T180240Z">
        <seg>サンプル: HTML5ドラッグ・アンド・ドロップでファイルアップロードするコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153334Z" creationid="shibukawa.yoshiki" creationdate="20150413T153334Z">
        <seg>サンプル:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressiveness can be achieved using standard refactoring techniques:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015459Z" creationid="shibukawa.yoshiki" creationdate="20150413T015459Z">
        <seg>一般的なリファクタリングのテクニックを使うと、表現力を向上させることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extracting Metadata from the Response</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174624Z" creationid="shibukawa.yoshiki" creationdate="20150414T174624Z">
        <seg>レスポンス中のメタデータの分解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Falls back to window.setTimeout/window.clearTimeout</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T162112Z" creationid="shibukawa.yoshiki" creationdate="20150416T162112Z">
        <seg>利用できないときは代わりにwindow.setTimeout/window.clearTimeout</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fast</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133849Z" creationid="shibukawa.yoshiki" creationdate="20150407T133849Z">
        <seg>高速</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File Separation</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015007Z" creationid="shibukawa.yoshiki" creationdate="20150421T015007Z">
        <seg>ファイル分割</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File uploads with FormData</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174538Z" creationid="shibukawa.yoshiki" creationdate="20150414T174538Z">
        <seg>FormDataによるファイルのアップロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the low-level m.render can also be used if a developer chooses to opt out of rest of the framework altogether.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000546Z" creationid="shibukawa.yoshiki" creationdate="20150506T000546Z">
        <seg>また、開発者が再描画の仕組みを完全に止める選択をした場合にも、m.render関数を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First and foremost, you should think hard about whether performance optimization is truly your last resort.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142408Z" creationid="shibukawa.yoshiki" creationdate="20150412T142408Z">
        <seg>まず第一に、パフォーマンスの最適化が自分にとって最後の手段であるかどうかを真剣に考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For developer convenience, Mithril makes an exception for the class attribute: if there are classes defined in both parameters, they are concatenated as a space separated list.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153249Z" creationid="shibukawa.yoshiki" creationdate="20150413T153249Z">
        <seg>開発者の利便性のために、Mithrilはclass属性は特別扱いをします。もし両方で定義されていた場合には、スペース区切りのリストとして2つのパラメータを統合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each m.startComputation call a library makes, it MUST also make one and ONLY one corresponding m.endComputation call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193257Z" creationid="shibukawa.yoshiki" creationdate="20150411T193257Z">
        <seg>ライブラリ内のそれぞれのm.startComputation呼び出しに対して、「かならず」「１回だけ」m.endComputationを呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example a form might have an input and a cancel button.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T160654Z" creationid="shibukawa.yoshiki" creationdate="20150407T153100Z">
        <seg>例えば、テキスト入力とキャンセルのボタンを持っているフォームがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an autocompleter component may need to internally store a flag to indicate whether the dropdown is visible, but this kind of state is not relevant to an application's business logic.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T083342Z" creationid="shibukawa.yoshiki" creationdate="20150502T083342Z">
        <seg>例えば、自動補完コンポーネントはドロップダウンが表示されているかどうかのフラグを持っています。しかしこの種の状態はアプリケーションのビジネスロジックは関係ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, both class and className are valid.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153529Z" creationid="shibukawa.yoshiki" creationdate="20150413T153529Z">
        <seg>classもclassNameも使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if type is the following class:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013847Z" creationid="shibukawa.yoshiki" creationdate="20150415T013847Z">
        <seg>もしtypeとして次のクラスが渡されたとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the response is {data: [{name: "John"}, {name: "Mary"}]} and the unwrap function is function(response) {return response.data}, then the response will be considered to be [{name: "John"}, {name: "Mary"}] when processing the type parameter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012946Z" creationid="shibukawa.yoshiki" creationdate="20150415T012946Z">
        <seg>もし返り値が{data: [{name: "John"}, {name: "Mary"}]}というJSONで、unwrap関数としてfunction(response) {return response.data}という関数が渡された場合には、typeパラメータの評価時に[{name: "John"}, {name: "Mary"}]というデータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if todo descriptions needed to always be uppercased, one could simply change the description getter-setter:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002402Z" creationid="shibukawa.yoshiki" creationdate="20150409T002402Z">
        <seg>例えば、ToDoの説明(description)が大文字でなければならないとしたら、description getter-setterだけを置き換えればこれが実現できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if we wanted to change the application to make the list be persisted, a native Array would most certainly not be a suitable class to use.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003136Z" creationid="shibukawa.yoshiki" creationdate="20150409T003136Z">
        <seg>例えば、リストを永続化させる機能をアプリケーションに追加したくなったとすると、ネイティブのArrayクラスはもっとも適切なクラスとは言えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are building a table with thousands of rows and finding that the template is slow, you should first consider making the table show less items, because from a user experience perspective, no one is realistically going to scan through thousands of records.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143359Z" creationid="shibukawa.yoshiki" creationdate="20150412T143359Z">
        <seg>もし、数千行の行を持つテーブルの構築を行っていて、そのテンプレートの動作が遅いことが分かったとしても、まずはユーザビリティの観点から表示行数を少なくすることを検討すべきです。だれも数千行のレコードを実際に読み込もうとする人などいないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you were to call a web service using m.request, you would not need to add more calls to m.startComputation / m.endComputation (you would still need the first pair in the event handler, though).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134719Z" creationid="shibukawa.yoshiki" creationdate="20150412T134719Z">
        <seg>例えば、もし非同期のウェブサービス呼び出しにm.requestを使っていれば、これ以上m.startComputation / m.endComputation呼び出しを追加する必要はありませんが、イベントハンドラには追加しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, let's say that you're generating a link from an entry that comes from a web service:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002254Z" creationid="shibukawa.yoshiki" creationdate="20150413T002254Z">
        <seg>ウェブサービスから帰ってきたエントリーを元に、動的にリンクが書き換わるようなリンクを作成するには次のようにします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the value for className should be a string.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153641Z" creationid="shibukawa.yoshiki" creationdate="20150413T153641Z">
        <seg>例えば、classNameの値は文字列である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the value for the onclick attribute should be a function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153914Z" creationid="shibukawa.yoshiki" creationdate="20150413T153914Z">
        <seg>例えば、onclick属性は関数を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, there is simply never a case where a developer would want to programmatically handle the error of accessing the property of a nullable entity without first checking for its existence.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172742Z" creationid="shibukawa.yoshiki" creationdate="20150415T172742Z">
        <seg>開発者は、最初にその存在を把握しなければ、nullになる可能性のあるオブジェクトのプロパティのアクセスエラーのハンドリングをしたいとは思わないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you might have a UserForm component that lives alongside other unrelated components on a bigger page, but it probably doesn't make sense for the parent page to be aware of the unsaved user data stored within the UserForm component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084102Z" creationid="shibukawa.yoshiki" creationdate="20150502T084102Z">
        <seg>例えば、大きなページ内に、他の関係ないコンポーネントと一緒にUserFormコンポーネントがあったとします。UserFormコンポーネント内に未保存のデータがあった場合は、親ページに知らせる必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you might only be interested in running a redraw if a user presses the space bar, and you might not want to waste a redraw if the user presses any other key.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150203Z" creationid="shibukawa.yoshiki" creationdate="20150416T150203Z">
        <seg>例えば、ユーザがスペースバーを推した時だけ再描画を行い、そうでない場合は再描画はムダなのでやりたいくない、ということもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013232Z" creationid="shibukawa.yoshiki" creationdate="20150410T013232Z">
        <seg>サンプル:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on components, see m.component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125538Z" creationid="shibukawa.yoshiki" creationdate="20150502T125538Z">
        <seg>より詳細な情報はm.componentを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information see this page:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014234Z" creationid="shibukawa.yoshiki" creationdate="20150417T014234Z">
        <seg>詳細についてはこのページを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For simplicity, our application will have only one component, and we're going to use it as the namespace for our application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040232Z" creationid="shibukawa.yoshiki" creationdate="20150502T040232Z">
        <seg>サンプルを簡単にするために、これから作るアプリケーションにはコンポーネントを1つだけ作ることにします。そしてそれをアプリケーションの名前空間として使っていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the most part, Mithril promises behave as you'd expect a Promise/A+ promise to behave, but have one difference: Mithril promises attempt to execute synchronously if possible.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140147Z" creationid="shibukawa.yoshiki" creationdate="20150415T140022Z">
        <seg>ほとんどの部分で、MithrilのpromiseはPromise/A+の仕様通りの動作をしますが1つ異なる点があります。Mithrilのpromiseは、可能であれば同期で処理を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purposes of testing out our code so far, the view can be rendered using the m.render method:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013558Z" creationid="shibukawa.yoshiki" creationdate="20150408T013537Z">
        <seg>コードをテストする目的で表示したい場合は、m.renderメソッドを呼ぶことでビューをレンダリングすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, m.trust will not auto-run &lt;script&gt; tags from trusted strings.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014430Z" creationid="shibukawa.yoshiki" creationdate="20150416T014430Z">
        <seg>このため、m.trustが自動的に&lt;script&gt;タグを実行することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forcing redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T125110Z" creationid="shibukawa.yoshiki" creationdate="20150416T125110Z">
        <seg>強制再描画</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, bindings can also be bi-directional: that is, they can be coded in such a way that, in addition to setting the DOM value, it's also possible to read it as a user types, and then update the description getter-setter in the view-model.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T110549Z" creationid="shibukawa.yoshiki" creationdate="20150408T020207Z">
        <seg>幸い、バインディングは双方向で行うように設定することができます。双方向になると、DOMの値を設定するだけでなく、ユーザが入力した内容を読み込んで、ビューモデル内のdescription setter-getterの内容を更新することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, with Mithril, it's possible for developers to attach an identity key to elements so that array operations like shift, splice and sort only affect the minimum amount of elements required, leaving the rest of the DOM elements untouched when a redraw happens.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141643Z" creationid="shibukawa.yoshiki" creationdate="20150413T141643Z">
        <seg>幸い、Mithrilでは、開発が各エレメントに識別子のキーを付与できるため、シフト、スプライス、ソートといった配列操作が行われても、再描画時に最小のエレメントだけを変更し、残りのDOMエレメントは変更されないようにする、といったことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the get-go, Mithril's build system produces archived versions of the code and documentation so that you'll never be stuck without docs for out-of-date versions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114752Z" creationid="shibukawa.yoshiki" creationdate="20150417T114752Z">
        <seg>Mithrilのビルドシステムは、過去のバージョンのコードとドキュメントをすべてアーカイブします。過去のバージョンの情報がなくて困ることもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getter-setters are JSON-serializable:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135617Z" creationid="shibukawa.yoshiki" creationdate="20150414T135617Z">
        <seg>getter-setterはJSONにシリアライズすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getter-setters work like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150526Z" creationid="shibukawa.yoshiki" creationdate="20150407T150526Z">
        <seg>getter-setterは次のように動作します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getting Started</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140635Z" creationid="shibukawa.yoshiki" creationdate="20150407T140635Z">
        <seg>はじめよう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getting Started - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140640Z" creationid="shibukawa.yoshiki" creationdate="20150407T140554Z">
        <seg>はじめよう - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given how young Mithril is, hopefully you can appreciate the level of commitment for providing good documentation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114904Z" creationid="shibukawa.yoshiki" creationdate="20150417T114904Z">
        <seg>Mithrilはまだまだ若いのですが、良いドキュメントを提供することに対してどれだけのコミットメントをしているかを理解してもらえれば幸いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the code above, the replacement class would only need to implement the .push() and .map() methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003616Z" creationid="shibukawa.yoshiki" creationdate="20150409T003616Z">
        <seg>上記のコードの場合は、新しいクラスに必要なメソッド.push()メソッドと.map()メソッドだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the example in the "Defining Routes" section:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013027Z" creationid="shibukawa.yoshiki" creationdate="20150410T013027Z">
        <seg>ラウトの定義のセクションのサンプルですでに使っています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go to mailing list</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135804Z" creationid="shibukawa.yoshiki" creationdate="20150407T135804Z">
        <seg>メーリングリストへ飛ぶ(英語)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good Practices</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141019Z" creationid="shibukawa.yoshiki" creationdate="20150407T141019Z">
        <seg>良いプラクティス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Guide</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135500Z" creationid="shibukawa.yoshiki" creationdate="20150407T135500Z">
        <seg>ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTML-to-Mithril Template Converter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013413Z" creationid="shibukawa.yoshiki" creationdate="20150417T013413Z">
        <seg>HTML→Mithrilテンプレートコンバータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are the highlights of the template above:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153647Z" creationid="shibukawa.yoshiki" creationdate="20150408T153647Z">
        <seg>このテンプレートの大事なポイントを個別に説明していきます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here we've moved Contact.save(contact).then(Observable.broadcast("updateContact")) out of the ContactForm component and into the model layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031438Z" creationid="shibukawa.yoshiki" creationdate="20150502T031438Z">
        <seg>このコードでは、Contact.save(contact).then(Observable.broadcast("updateContact"))をContactFormコンポーネントの中から、モデルレイヤの中に移動しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a less trivial example:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002409Z" creationid="shibukawa.yoshiki" creationdate="20150413T002409Z">
        <seg>ちょっと応用的なサンプルです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's a refactored version of the sample app above to illustrate:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013615Z" creationid="shibukawa.yoshiki" creationdate="20150502T013615Z">
        <seg>以下のコードは上記のコードをリファクタリングしたものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example of a more aggressive refactor:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015627Z" creationid="shibukawa.yoshiki" creationdate="20150413T015627Z">
        <seg>もっとアグレッシブなリファクタリングを行うとこうなります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example of a not-so-trivial component: a drag-n-drop file uploader.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031830Z" creationid="shibukawa.yoshiki" creationdate="20150502T031802Z">
        <seg>１つ面白いサンプルを紹介します。ドラッグ・アンド・ドロップでファイルをアップロードするコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example using the Q promise library:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135433Z" creationid="shibukawa.yoshiki" creationdate="20150414T135433Z">
        <seg>Qというpromiseライブラリを使うサンプルがこちらです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's one last, but relevant variation of the pattern above.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031135Z" creationid="shibukawa.yoshiki" creationdate="20150502T031135Z">
        <seg>次は最後のパターンです。上記で説明したものの変形バージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's one way to implement cross-communication between single purpose components:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015605Z" creationid="shibukawa.yoshiki" creationdate="20150502T015605Z">
        <seg>以下のコードは、上記の単一機能を提供するコンポーネント間のコミュニケーションを提供する方法です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's the application code in its entirety:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T162102Z" creationid="shibukawa.yoshiki" creationdate="20150408T162102Z">
        <seg>完全なアプリケーションのコードはこちらになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's the most basic way of implementing the view-to-model part of the binding:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021122Z" creationid="shibukawa.yoshiki" creationdate="20150408T020244Z">
        <seg>次のコードが、ビューからモデルへのバインディングを行う、最小限の実装になります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the data fetching is still centralized in the top-level component, so that we can avoid duplicate AJAX requests when fetching data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T030721Z" creationid="shibukawa.yoshiki" creationdate="20150502T030721Z">
        <seg>この場合データの取得コードはトップレーベルモジュールに集約されています。これによりAJAXリクエストを何度も行うことを避けられるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we've defined a class called Contact.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T224039Z" creationid="shibukawa.yoshiki" creationdate="20150501T224023Z">
        <seg>Contact(連絡先)クラスを定義しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hierarchical MVC via components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133844Z" creationid="shibukawa.yoshiki" creationdate="20150407T133844Z">
        <seg>コンポーネントによる階層型MVC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>History</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154247Z" creationid="shibukawa.yoshiki" creationdate="20150412T154247Z">
        <seg>履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hopefully by now, you're starting to see why Mithril encourages the usage of m.prop: Because Mithril getter-setters are functions, they naturally compose well with functional programming tools, and allow for some very powerful idioms.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152126Z" creationid="shibukawa.yoshiki" creationdate="20150408T152126Z">
        <seg>これまでの説明の中で、なぜMithrilがm.propを使うことを推奨しているのか、お気づきの方もいると思います。Mithrilのgetter-setterは関数です。それにより、関数型プログラミングの道具と、相性良く組みわせることができて、強力な書き方が使えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hopefully these examples give you an idea of ways requirements can change over time and how Mithril's philosophy allows developers to use standard OOP techniques to refactor their codebases, rather than needing to modify large portions of the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T012924Z" creationid="shibukawa.yoshiki" creationdate="20150409T012924Z">
        <seg>要件は時間とともに変化しますが、これらの例から、Mithrilがどのような哲学を持って、開発者がコードベースをリファクタリングする際に、どのように標準的なオブジェクト指向プログラミングのテクニックを使って欲しいと思っているか、アプリケーションを大きな塊にしないで小さくして欲しいと考えているのかが伝われば幸いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How Should Code Be Organized</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110751Z" creationid="shibukawa.yoshiki" creationdate="20150420T110751Z">
        <seg>推奨されるコード構成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How Should Code Be Organized - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110757Z" creationid="shibukawa.yoshiki" creationdate="20150420T110706Z">
        <seg>推奨されるコード構成 - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How auto-redrawing works</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152913Z" creationid="shibukawa.yoshiki" creationdate="20150416T152913Z">
        <seg>どのように再描画が行われるか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How is Mithril Different from Other Frameworks</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015649Z" creationid="shibukawa.yoshiki" creationdate="20150417T015649Z">
        <seg>Mithrilと他のフレームワークの違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How is Mithril Different from Other Frameworks - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015419Z" creationid="shibukawa.yoshiki" creationdate="20150417T015419Z">
        <seg>Mithrilと他のフレームワークの違い - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to read signatures</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150434Z" creationid="shibukawa.yoshiki" creationdate="20150413T150434Z">
        <seg>シグニチャの読み方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as I mentioned before, you can enable an auto-redrawing system, by initializing the todo component via m.mount.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041650Z" creationid="shibukawa.yoshiki" creationdate="20150502T041650Z">
        <seg>しかし、前に説明したとおり、m.mountを通じてtodoコンポーネントを初期化すると、自動再描画システムが有効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as the performance tests in the homepage show, this does not necessarily hurt Mithril in a meaningful way.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015016Z" creationid="shibukawa.yoshiki" creationdate="20150420T015016Z">
        <seg>しかし、ホームページのパフォーマンス比較が示す通り、Mithrilではこの両方を達成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, bindings can be implemented easily:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014119Z" creationid="shibukawa.yoshiki" creationdate="20150413T014119Z">
        <seg>しかし、簡単に実現できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's important to always write conditional tests in templates to account for the possibility of nullables, because redraws may come to occur more aggressively than data is available (perhaps because a newly introduced 3rd party library calls m.redraw, or because you might want a more aggressive redraw policy to implement a specific feature down the road).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T120834Z" creationid="shibukawa.yoshiki" creationdate="20150502T120834Z">
        <seg>しかし、テンプレート内でnullになりえる可能性がある場合は常にチェックコードを書くことが大切です。新しく導入したサードパーティライブラリがm.redrawを呼び出す可能性がありますし、何かしらの機能を実装する時に積極的な再描画を行う必要が出てくる可能性があるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's recommended that you aggregate all of your requests in a single place instead of scattering them across multiple components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084713Z" creationid="shibukawa.yoshiki" creationdate="20150502T084713Z">
        <seg>しかし、複数のコンポーネントに散らばっている複数のリクエストは一箇所にあつめるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, sometimes we do want to be able to redraw before a web service request completes, either because one web service out of many is slow, or because we don't need its response in order to redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T000147Z" creationid="shibukawa.yoshiki" creationdate="20150415T000147Z">
        <seg>しかし、時々ウェブサービスのリクエストが完了する前に再描画を行いたいと思うことがあります。多くのウェブサービスに並行でアクセスして、アクセスが遅いのがその中の１つだけだったり、もしくは再描画するのにレスポンスがいらない、といったこともありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this mode does not support named anchors and browser history lists.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005228Z" creationid="shibukawa.yoshiki" creationdate="20150410T005228Z">
        <seg>しかし、このモードでは名前付きアンカーが使えなくなりますし、ブラウザの履歴のリストがサポートされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this mode does not support named anchors.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170041Z" creationid="shibukawa.yoshiki" creationdate="20150414T170041Z">
        <seg>しかし、このモードでは名前付きアンカーが使えなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, using m.render is only recommended if you want to use Mithril as part of a larger framework that manages the rendering lifecycle on its own.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100251Z" creationid="shibukawa.yoshiki" creationdate="20150502T100218Z">
        <seg>m.renderを使用するのは、他のフレームワークを利用していて、描画の管理はそのシステムに従う場合にのみにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, using its entire toolset idiomatically can bring lots of benefits: learning to use functional programming in real world scenarios and solidifying good coding practices for OOP and MVC are just some of them.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142406Z" creationid="shibukawa.yoshiki" creationdate="20150407T142253Z">
        <seg>しかし、このツールセットのレールに乗ることで多くの利益を得ることができます。その中には、実用的なシナリオ上で関数型プログラミングを学んだり、しっかりとしたオブジェクト指向プログラミングやMVCの良いコーディングプラクティスを学ぶことも含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hybrid architecture</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180200Z" creationid="shibukawa.yoshiki" creationdate="20150501T180200Z">
        <seg>ハイブリッドアーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IE also allows running of Javascript via CSS behaviors in &lt;link&gt;/&lt;style&gt; tags and style attributes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014743Z" creationid="shibukawa.yoshiki" creationdate="20150416T014743Z">
        <seg>IEはCSSの処理の中でのJavaScriptの実行を認めています。&lt;link&gt;/&lt;style&gt; タグと、style属性です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IE7 and lower do not support cross-domain AJAX requests.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015040Z" creationid="shibukawa.yoshiki" creationdate="20150417T015040Z">
        <seg>IE7以下のブラウザは、クロスドメインのAJAXリクエストをサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ideally, temperature conversion functions (and any functions that deal strictly within the domain of the data) should go in the model layer, not in a component's controller.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081933Z" creationid="shibukawa.yoshiki" creationdate="20150502T081933Z">
        <seg>理想的には温度変換処理や、データの領域で行われるその他の処理はコンポーネントのコントローラではなく、モデルレイヤーに移動すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idiomatic Mithril code is meant to apply good programming conventions and be easy to refactor.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T234007Z" creationid="shibukawa.yoshiki" creationdate="20150408T234007Z">
        <seg>Mithril風のコードとは、良いプログラミングの規約に従っていて、リファクタリングしやすいコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a component A contains another component B that calls asynchronous services, when component A is rendered, a &lt;placeholder&gt; tag is rendered in place of component B until B's asynchronous services resolve.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094529Z" creationid="shibukawa.yoshiki" creationdate="20150502T094529Z">
        <seg>もし、コンポーネントAが、非同期処理を行う他のコンポーネントBを含んでいて、Bの非同期タスクが完了する前であれば、描画時に&lt;placeholder&gt;タグがレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a component's controller contains the function onunload, it will be called under one of these circumstances:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090938Z" creationid="shibukawa.yoshiki" creationdate="20150502T090938Z">
        <seg>コンポーネントのコントローラがonunload関数を持っていた場合は、以下の状況のどれかに当てはまった時に呼ばれます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a component's controller implements an instance method called onunload, this method will be called when a route changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135316Z" creationid="shibukawa.yoshiki" creationdate="20150502T135310Z">
        <seg>コンポーネントのコントローラがonunloadインスタンスメソッドを定義している場合、ラウトが変更されるとこのメソッドが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a component's root element is a subtree directive on its first rendering pass, undefined behavior will occur.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100058Z" creationid="shibukawa.yoshiki" creationdate="20150502T100058Z">
        <seg>初回レンダリング時に、コンポーネントのルートのエレメントがサブツリーディレクティブを返した場合は未定義の動作になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a contoller is not specified, Mithril will automatically create an empty controller function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100517Z" creationid="shibukawa.yoshiki" creationdate="20150502T100517Z">
        <seg>もしコントローラが指定されなければ、Mithrilは自動的に空のコントローラ関数を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a promise is passed into m.prop(), a Mithril promise is returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135230Z" creationid="shibukawa.yoshiki" creationdate="20150414T135230Z">
        <seg>promiseがm.prop()Mithrilのpromiseが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an attribute has the same name in Javascript and in HTML, then Mithril assumes you're setting the Javascript property.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T012442Z" creationid="shibukawa.yoshiki" creationdate="20150413T012442Z">
        <seg>JavaScriptとHTMLで同じ名前の属性があった場合は、MithrilはJavaScript側の属性を優先します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If calls are more expensive than a repaint window, the browser may drop frames, resulting in choppy animations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020504Z" creationid="shibukawa.yoshiki" creationdate="20150421T020504Z">
        <seg>もし、このメソッドの呼び出しコストがウィンドウの再描画よりも重くなると、フレーム落ちが発生して、アニメーションがなめらかに実行されなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If doing such operations, the final string needs to be flagged as trusted.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015721Z" creationid="shibukawa.yoshiki" creationdate="20150416T015721Z">
        <seg>このような操作を行う場合には、最終的な文字列に対してこの関数を呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a SubtreeDirective with the value "retain", it will retain the existing DOM tree in place, if any.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160432Z" creationid="shibukawa.yoshiki" creationdate="20150413T160432Z">
        <seg>SubtreeDirectiveの値が"retain"だった場合は、もしあれば既存のDOMツリーをその場で保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a VirtualElement, it will be rendered as a DOM Element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155613Z" creationid="shibukawa.yoshiki" creationdate="20150413T155613Z">
        <seg>もし仮想エレメントが指定された場合には、DOMエレメントとしてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a list, its contents will recursively be rendered as appropriate and appended as children of the root element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124825Z" creationid="shibukawa.yoshiki" creationdate="20150416T124825Z">
        <seg>配列だった場合には、配列の要素も再帰的にレンダリングされて、rootエレメントの子供として追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a list, its contents will recursively be rendered as appropriate and appended as children of the element being created.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160227Z" creationid="shibukawa.yoshiki" creationdate="20150413T160227Z">
        <seg>配列だった場合には、配列の要素も再帰的にレンダリングされて、生成されたエレメントの子供として追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not provided, return the current internally stored value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135923Z" creationid="shibukawa.yoshiki" creationdate="20150414T135923Z">
        <seg>もし渡されなければ、現在の内部ストアの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not provided, the value of the getter-setter's internal store defaults to undefined.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135745Z" creationid="shibukawa.yoshiki" creationdate="20150414T135745Z">
        <seg>もし初期値が与えられなければ、getter-setterの内部ストアのデフォルト値はundefinedになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If provided, it updates the getter-setter's internal store to the provided value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135908Z" creationid="shibukawa.yoshiki" creationdate="20150414T135908Z">
        <seg>もし引数が渡された場合には、getter-setterの内部ストアの値を、渡された値に更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If set to true, forces the redraw to be synchronous.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151738Z" creationid="shibukawa.yoshiki" creationdate="20150416T151738Z">
        <seg>もしこれがtrueに設定されると、同期的に再描画を行う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If set to true, rendering a new virtual tree will completely overwrite an existing one without attempting to diff against it</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124954Z" creationid="shibukawa.yoshiki" creationdate="20150416T124954Z">
        <seg>もしこれがtrueに設定されると、差分検知せずに新しい仮想ツリーの完全なレンダリングが行われます。st it</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If set to true, replaces the current history entry, instead of adding a new one.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171606Z" creationid="shibukawa.yoshiki" creationdate="20150414T171606Z">
        <seg>もしこのパラメータがtrueに設定されると、新しいページを追加するのではなく、現在のヒストリのエントリーを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the context object that is passed to a config function has a property called onunload, this function will be called when the element gets detached from the document by Mithril's diff engine.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130246Z" creationid="shibukawa.yoshiki" creationdate="20150413T130246Z">
        <seg>config関数に渡されるcontextオブジェクトには、onunloadと呼ばれるプロパティがあります。この関数は、Mithirilの差分検出エンジンによって対象のエレメントがドキュメントから切り離される時に呼ばされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the URL is not in the same domain as the application, the target server must be configured to accept cross-domain requests from the application's domain, i.e. its responses must include the header Access-Control-Allow-Origin: *.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002310Z" creationid="shibukawa.yoshiki" creationdate="20150415T002310Z">
        <seg>もしURLが違うドメインであれば、対象となるサーバは Access-Control-Allow-Origin: *ヘッダを付与するなど、クロスドメインのリクエストを許可する設定になっている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the controller doesn't already have a success callback to run after a request resolves, you can still bind errors like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125324Z" creationid="shibukawa.yoshiki" creationdate="20150410T125324Z">
        <seg>もしコントローラが、サーバアクセスが成功した時に実行すべき処理がない場合でも、次のように書くことでエラー処理のバインドが行えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current page URL matches a route, its respective component is activated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135805Z" creationid="shibukawa.yoshiki" creationdate="20150502T135805Z">
        <seg>現在のページのURLが、設定されたラウトにマッチした場合には、対応するコンポーネントがアクティブになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the currently active route is /dashboard/:userID and the current URL is /dashboard/johndoe, then calling m.route.param("userID") returns "johndoe"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170711Z" creationid="shibukawa.yoshiki" creationdate="20150414T170711Z">
        <seg>もし、現在アクティブなラウトが/dashboard/:userIDで、現在のURLが/dashboard/johndoeだとすると、m.route.param("userID")は"johndoe"を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the method is run more than once with the same root element, it diffs the new tree against the existing one and intelligently modifies only the portions that have changed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T020105Z" creationid="shibukawa.yoshiki" creationdate="20150416T020105Z">
        <seg>もしこのメソッドが、同じルートエレメントに対して2回以上呼ばれた場合には、このメソッドは新しいツリーと既存のツリーの差分を取り、変更のあった箇所だけ賢く更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the tag selector is omitted, it defaults to div.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150640Z" creationid="shibukawa.yoshiki" creationdate="20150413T150640Z">
        <seg>もしタグセレクタが省略されると、divがデフォルトで設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this argument is a string, it will be rendered as a text node.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155516Z" creationid="shibukawa.yoshiki" creationdate="20150413T155516Z">
        <seg>この属性が文字列の場合は、テキストノードとしてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this function returns undefined, then it passes the value argument to the next step in the thennable queue, if any</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175859Z" creationid="shibukawa.yoshiki" creationdate="20150415T175859Z">
        <seg>もしこの関数がundefinedを返してきたら、値がどんなでものであろうと、value引数がthennableキューの次のキューに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this option is set to true, then the request does NOT call m.startComputation / m.endComputation internally, and therefore the completion of the request does not trigger an update of the view, even if data has been changed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134319Z" creationid="shibukawa.yoshiki" creationdate="20150502T134319Z">
        <seg>このオプションがtrueであれば、requestメソッドはm.startComputation / m.endComputationを呼びません。そのため、リクエストの完了がビュー更新のトリガーにはならず、データ更新があってもビューが更新されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this parameter is falsy, the default value is a function that returns xhr.responseText.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013502Z" creationid="shibukawa.yoshiki" creationdate="20150415T013502Z">
        <seg>この設定がfalsyな値だったときのデフォルトの動作は、xhr.responseTextを返す関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this parameter is falsy, the deserialized data will not be wrapped.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013825Z" creationid="shibukawa.yoshiki" creationdate="20150415T013825Z">
        <seg>もしこのパラメータがfalxyな値だった時は、デシリアライズされたデータはそのまま渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you already have your HTML written and want to convert it into a Mithril template, you can use the tool below for one-off manual conversion.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013549Z" creationid="shibukawa.yoshiki" creationdate="20150417T013549Z">
        <seg>もしすでにHTMLを作成済みで、それをMithirlのテンプレートに変換したい場合は、一度だけマニュアルの変換しかできませんが、下記のツールを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are developing an asynchronous model-level service and finding that Mithril is not redrawing the view after your code runs, you should consider using m.startComputation and m.endComputation to integrate with Mithril's auto-redrawing system instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130208Z" creationid="shibukawa.yoshiki" creationdate="20150502T130208Z">
        <seg>もし非同期のモデルレベルのサービスを開発しているとします。コードが実行されていても、Mithrilがビューを更新しないことに気づきました。この場合は、m.startComputationとm.endComputationを呼んで、Mithrilの自動再描画システムと統合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you call this method more often than that, Mithril may ignore calls or defer them to the next browser repaint cycle.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020407Z" creationid="shibukawa.yoshiki" creationdate="20150421T020407Z">
        <seg>もしこれよりも早いペースで呼び出すと、Mithrilは関数呼び出しを無視して、次のブラウザの再描画のサイクルまで実行を遅らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do use it, you are responsible for determining what constitutes a scenario where the virtual DOM tree is changed/unchanged.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124157Z" creationid="shibukawa.yoshiki" creationdate="20150416T124157Z">
        <seg>この機能を使う場合は、仮想DOMツリーのどこに変更があったか/なかったかについて、開発者が決定する責任を持つことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you find yourself needing to redraw before the browsers normal redraw cycle, you can force a synchronous redraw by passing a boolean true as a parameter to m.redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151336Z" creationid="shibukawa.yoshiki" creationdate="20150416T151336Z">
        <seg>もしブラウザの通常の再描画サイクルよりも前に再描画を行わせたい場合は、m.redrawのオプションとしてtrueを渡すと、強制的に同期再描画を行わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a hierarchy of components, you can recursively call onunload on all the components in the tree or use a pubsub library to unload specific components on demand.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T020118Z" creationid="shibukawa.yoshiki" creationdate="20150414T020118Z">
        <seg>コンポーネントが階層化されている場合は、階層の中のモジュールのすべてのonunloadを呼ぶこともできますし、特定のコンポーネントをアンロードするときにはpubsubライブラリを呼ぶこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have components inside a sortable list, you should add key attributes to your components to ensure that DOM elements are not recreated from scratch, but merely moved when possible.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080315Z" creationid="shibukawa.yoshiki" creationdate="20150502T080315Z">
        <seg>もしソート可能なリストの中にコンポーネントを置く場合には、key 属性をコンポーネントに追加して、単なる移動時にDOM要素が再生成されないようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to add separate widgets to different places on a same page, you can simply initialize each widget as you would a regular Mithril application (i.e. use m.render, m.mount or m.route).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045357Z" creationid="shibukawa.yoshiki" creationdate="20150502T045357Z">
        <seg>もし、個別のウィジェットを同じページ内の異なる場所に置きたい場合には、通常のMithrilアプリケーションと同じように、m.render、m.mount、m.routeなどを使ってそれぞれのウィジェットを初期化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to change how Mithril performs a redraw, you can change the value of the m.redraw.strategy getter-setter to either "all", "diff" or "none".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T130801Z" creationid="shibukawa.yoshiki" creationdate="20150416T130801Z">
        <seg>Mithrilの再描画の実行パターンを変更する必要があれば、m.redraw.strategy getter-setterを、"all"、"diff"、"none"のどれかに設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to do custom asynchronous calls without using Mithril's API, and find that your views are not redrawing automatically, you should consider using m.startComputation / m.endComputation so that Mithril can intelligently auto-redraw once your custom code finishes running.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000610Z" creationid="shibukawa.yoshiki" creationdate="20150506T000610Z">
        <seg>MithrilのAPIを使わないで、カスタムの非同期呼び出しを行った時に、ビューが更新されていない時は、m.startComputation / m.endComputationを使用することを検討してください。カスタムコードの処理が終わった時にMithrilが賢く自動再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to do custom asynchronous calls without using Mithril's API, and find that your views are not redrawing, you should consider using m.startComputation / m.endComputation so that Mithril can intelligently auto-redraw once your custom code finishes running.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T113931Z" creationid="shibukawa.yoshiki" creationdate="20150502T113931Z">
        <seg>MithrilのAPIを使わないで、カスタムの非同期呼び出しを行った時に、ビューが更新されていない時は、m.startComputation / m.endComputationを使用することを検討してください。カスタムコードの処理が終わった時にMithrilが賢く自動再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to persist DOM state across route changes, it's recommended that you use the ctx.retain flag instead of m.redraw.strategy("diff").</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T133349Z" creationid="shibukawa.yoshiki" creationdate="20150502T133349Z">
        <seg>ラウト間でDOMの状態を維持する必要があるときは、m.redraw.strategy("diff")ではなく、ctx.retainフラグを使うのが推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to read DOM values, try to read them all at once, because alternating reading and writing to the DOM causes multiple browser repaints, and repaints are expensive.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151714Z" creationid="shibukawa.yoshiki" creationdate="20150416T151714Z">
        <seg>もしDOMの値を読む必要が出てきた場合は、すべての必要なDOMの値を一度に読むようにしてください。少しずつ読み書きすると、高価なブラウザの再描画が何度も発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to sort lists, or delete items from them, or splice them in any way, you should use the key attribute to maintain referential integrity between the data and the DOM.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020944Z" creationid="shibukawa.yoshiki" creationdate="20150421T020944Z">
        <seg>リストをソートしたり、リストから要素を削除する場合や、スプライスを行う場合は、データとDOM間の参照を維持するために、 key属性を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you see an alert box, ensuring security with that framework is more work for you.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135415Z" creationid="shibukawa.yoshiki" creationdate="20150407T135415Z">
        <seg>もしアラートボックスが表示された場合には、そのフレームワーク上ではセキュリティを維持するための仕事がたくさんあるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you set strategy to "none" but then proceed to trigger a redraw asynchronously, either via start/endComputation, m.redraw or m.request, a redraw will occur, using the "diff" strategy.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152806Z" creationid="shibukawa.yoshiki" creationdate="20150416T150752Z">
        <seg>このメソッドを使って"none"に設定したにもかかわらず、start/endComputationやm.redraw、m.requestによって非同期での再描画のトリガーが引かれた場合は、 "diff" 戦略で再描画が先のフレームで行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to a recurring callback (such as setInterval or a web socket event handler) to trigger redraws, you should call m.startComputation at the beginning of the function, not outside of it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T175327Z" creationid="shibukawa.yoshiki" creationdate="20150501T175327Z">
        <seg>もし、setIntervalやウェブソケットのイベントハンドラなど、繰り返し呼ばれるコールバックから再描画を行わせたい場合は、コールバックの外ではなく、コールバック関数の先頭でm.startComputationを呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to automate compilation, you can use GruntJS, a task automation tool.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150401Z" creationid="shibukawa.yoshiki" creationdate="20150412T150401Z">
        <seg>テンプレートを自動コンパイルするには、タスク自動化ツールのGruntJSを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to be able to handle a condition as an error in a promise rejection handler, you can throw an Error from extract to reject the promise.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181142Z" creationid="shibukawa.yoshiki" creationdate="20150414T181142Z">
        <seg>もし、promiseのリジェクトハンドラ内でエラー条件のハンドリングを行いたい場合は、extractの中から、promiseのリジェクトに向けてErrorを投げることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to keep a DOM element intact across a route change, you can set the retain flag in the config's context object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130751Z" creationid="shibukawa.yoshiki" creationdate="20150413T130751Z">
        <seg>もし、ラウトの変更前後で、DOMエレメントを破棄せずに残しておきたい場合には、configのコンテキストオブジェクト内のretainフラグを設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to repeatedly redraw the view without necessarily waiting for user input, you should manually call m.redraw within the repeatable context.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193557Z" creationid="shibukawa.yoshiki" creationdate="20150411T193557Z">
        <seg>もし、ユーザの入力を待つことなく、繰り返し再描画を行いたい場合は、繰り返し可能なコンテキストの中で、手動でm.redrawを呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use the bleeding edge version, you can fork the development repository.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000353Z" creationid="shibukawa.yoshiki" creationdate="20150408T000353Z">
        <seg>もし、最先端のバージョンを使いたいのであれば、開発版のリポジトリをフォークすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to support IE6, you'll need a shim for it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015011Z" creationid="shibukawa.yoshiki" creationdate="20150417T015011Z">
        <seg>もしIE6をサポートするには、そのクラスのシミュレートコードが必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to use third party asynchronous libraries (for example, jQuery.ajax), you should also consider using m.startComputation / m.endComputation if you want views to redraw after requests complete.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135033Z" creationid="shibukawa.yoshiki" creationdate="20150415T135033Z">
        <seg>もし、jQuery.ajax)などのサードパーティの非同期ライブラリと一緒に使って、リクエストの完了時に再描画をさせたい時はm.startComputation / m.endComputationを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're integrating other non-recurring services (e.g. calling setTimeout), you should use m.startComputation / m.endComputation instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020049Z" creationid="shibukawa.yoshiki" creationdate="20150421T020049Z">
        <seg>setTimeoutなどの、繰り返し行われないサービスと統合する場合は、m.startComputation / m.endComputationの方が推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're interested in helping improve Mithril, you're welcome to use the bleeding edge version and report any bugs that you find.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000614Z" creationid="shibukawa.yoshiki" creationdate="20150408T000614Z">
        <seg>もし、Mithrilを改善することに興味があるのであれば、最先端バージョンを使用して、見つけたバグを報告してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're not familiar with GruntJS, you can find a tutorial on their website.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150430Z" creationid="shibukawa.yoshiki" creationdate="20150412T150430Z">
        <seg>もしGruntJSについて馴染みがなければ、GruntJSのウェブサイト上にチュートリアルがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're using NodeJS already or planning on using Grunt to create a build system, you can use NPM to conveniently keep up-to-date with Mithril versions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165958Z" creationid="shibukawa.yoshiki" creationdate="20150407T165842Z">
        <seg>もしすでにNodeJSを使っていていたり、Gruntを使ったビルドシステムを作ろうとしているのであれば、NPMを使うとMithrilを最新に保つのが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're using NodeJS already or planning on using Grunt to create a build system, you can use Bower to conveniently keep up-to-date with Mithril versions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235636Z" creationid="shibukawa.yoshiki" creationdate="20150407T235056Z">
        <seg>もしすでにNodeJSを使っていていたり、Gruntを使ったビルドシステムを作ろうとしているのであれば、Bowerを使うとMithrilを最新に保つのが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're using NodeJS already or planning on using Grunt to create a build system, you can use Component to conveniently keep up-to-date with Mithril versions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235953Z" creationid="shibukawa.yoshiki" creationdate="20150407T235932Z">
        <seg>もしすでにNodeJSを使っていていたり、Gruntを使ったビルドシステムを作ろうとしているのであれば、Componentを使うとMithrilを最新に保つのが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're writing a template for a view, use m() instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013520Z" creationid="shibukawa.yoshiki" creationdate="20150416T013520Z">
        <seg>もしビューのためにテンプレートを作成しているのであれば、m()を代わりに使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you've been interested in learning or using Functional Programming in the real world, Mithril provides very pragmatic opportunities to get into it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015625Z" creationid="shibukawa.yoshiki" creationdate="20150409T015613Z">
        <seg>もし関数型プログラミングを学習したり、実世界で使ってみたいと考えているのであれば、Mithrilがとても実践的な場を提供してくれるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Apache, this URL rewriting can be achieved using mod_rewrite.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012855Z" creationid="shibukawa.yoshiki" creationdate="20150410T012855Z">
        <seg>Apacheを使っている場合は、mod_rewriteを使用してURLの書き換えを行うことでできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Apache, this URL rewriting can be achieved using ModRewrite.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170200Z" creationid="shibukawa.yoshiki" creationdate="20150414T170200Z">
        <seg>Apacheを使っている場合は、mod_rewriteを使用してURLの書き換えを行うことでできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, UI state is understood to be model data, even though it doesn't necessarily map to a database ORM entity.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152904Z" creationid="shibukawa.yoshiki" creationdate="20150407T152904Z">
        <seg>Mithrilでは、UIの状態というのはデータベースのORMエンティティにマップされる必要はないが、モデルデータとなるべきもの、と考えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, a component is an object that contains two functions: controller and view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040244Z" creationid="shibukawa.yoshiki" creationdate="20150502T040244Z">
        <seg>Mithrilでは、コンポーネントは、controllerとviewの2つの関数を含むオブジェクトです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, a component is nothing more than an object that has a view function and, optionally, a controller function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061341Z" creationid="shibukawa.yoshiki" creationdate="20150502T061341Z">
        <seg>Mithrilのコンポーネントは、view関数と、オプションのcontroller関数を持つ以外のルールはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, an application typically lives in a namespace and contains components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040153Z" creationid="shibukawa.yoshiki" creationdate="20150502T040153Z">
        <seg>Mithrilでは基本的に、アプリケーションは名前空間の中に作り、コンポーネントをその中に格納していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Mithril, views are plain Javascript.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040855Z" creationid="shibukawa.yoshiki" creationdate="20150502T040855Z">
        <seg>MithrilではビューはプレーンなJavaScriptコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a command line, type:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150201Z" creationid="shibukawa.yoshiki" creationdate="20150412T150201Z">
        <seg>コマンドラインで次のようにタイプします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to being aware of data availability when deciding to redraw, Mithril is also aware of browser availability: if several redraws are triggered in a short amount of time, Mithril batches them so that at most only one redraw happens within a single animation frame (around 16ms).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T191406Z" creationid="shibukawa.yoshiki" creationdate="20150411T191406Z">
        <seg>このように、再描画の決定にデータの可用性を判断基準にしていますが、これ以外にも、ブラウザの可用性についても考慮しています。もし、短時間で何度も再描画が行われようとしている場合には、Mithrilはこれらの再描画をまとめて、単一のアニメーションフレーム(16ミリ秒)に最大1回のみ再描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to bi-directional data binding, we can also bind parameterized functions to events:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151223Z" creationid="shibukawa.yoshiki" creationdate="20150408T151223Z">
        <seg>双方向バインディング以外の機能では、パラメータ付き関数をイベントにバインドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to holding a controller and a view, a component can also be used to store data that pertains to it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040327Z" creationid="shibukawa.yoshiki" creationdate="20150502T040327Z">
        <seg>コンポーネントはコントローラとビューを保持するだけではなく、関連するデータを格納するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to route parameters, it's possible to pass arbitrary data to m.route.param using the querystring</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T154349Z" creationid="shibukawa.yoshiki" creationdate="20150414T154349Z">
        <seg>ラウトパラメータ以外にも、クエリー文字列を使って任意のデータをm.route.paramに渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the controller and view properties that make the Uploader object usable as a component, it also has an upload convenience function that provides a basic upload model method, and a serialize function that allows files to be serialized as JSON in regular requests encoded as application/x-www-form-urlencoded.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034456Z" creationid="shibukawa.yoshiki" creationdate="20150502T032543Z">
        <seg>Uploaderオブジェクトをそのままコンポーネントとして使えるようにcontrollerとviewプロパティを提供しています。また、それに追加して基本的なアップロードの機能を提供するupload関数もモデルのメソッドとして提供しています。また、通常はJSONでシリアライズされるサーバリクエストで、application/x-www-form-urlencodedエンコードでファイル送信ができるようにするserialize関数も提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, Mithril attempts to intelligently redraw only when it is appropriate in an application lifecycle.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184427Z" creationid="shibukawa.yoshiki" creationdate="20150411T184427Z">
        <seg>これに加えて、Mithrilはアプリケーションのライフサイクルを考え、適切なタイミングでのみ再描画を実行するようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, an application can be organizationally divided into three major layers: Model, Controller and View.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T145325Z" creationid="shibukawa.yoshiki" creationdate="20150407T144808Z">
        <seg>アプリケーションはModel、Controller、Viewの大きく3つのレイヤーにきれいに分割することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, components can be reused in different contexts.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T005453Z" creationid="shibukawa.yoshiki" creationdate="20150502T005453Z">
        <seg>それに加えて、さまざまなコンテキストでコンポーネントを再利用しやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, having a deeply nested tree of components can result in a lot of intermediate "pass-through" arguments and event handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013517Z" creationid="shibukawa.yoshiki" creationdate="20150502T013517Z">
        <seg>それに加えて、ツリーのネストが深くなると、コンポーネント間の引数のパススルーや、イベントハンドラが増えることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, it stores the unsaved contact entity internally within the component (this.contact = m.prop(args.contact || new Contact())).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002318Z" creationid="shibukawa.yoshiki" creationdate="20150502T002318Z">
        <seg>それに加えて、未保存の連絡先情報をコンポーネント内に保管しています(this.contact = m.prop(args.contact || new Contact()))。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, it's possible for non-Mithril asynchronous callbacks to trigger auto-redrawing by calling m.startComputation and m.endComputation in appropriate places (see below).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T185216Z" creationid="shibukawa.yoshiki" creationdate="20150411T185216Z">
        <seg>これに加えて、Mithril外の非同期のコールバックからも、m.startComputation関数とm.endComputation関数を適切な場所に配置することで(あとで説明します)、再描画のシステムを起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, note that most m.route modes rely on history.pushState in order to allow moving from one page to another without a browser refresh.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015141Z" creationid="shibukawa.yoshiki" creationdate="20150417T015141Z">
        <seg>また、多くのm.routeモードは、ブラウザをリフレッシュしないで他のページにジャンプするためにhistory.pushStateを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, note that template performance, both in Mithril templates as well as in general, is dependent on markup complexity.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020742Z" creationid="shibukawa.yoshiki" creationdate="20150421T020742Z">
        <seg>また、Mithrilだけではなく他のテンプレートにも共通することとして、マークアップの複雑性がテンプレートのパフォーマンスに影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, setting context.retain = false will also cause the element to be recreated, even if it is not considered different enough.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135454Z" creationid="shibukawa.yoshiki" creationdate="20150413T135435Z">
        <seg>context.retain = falseが設定された場合は、変更が小さくてもエレメントは破棄されて再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, this guide section covers topics related to how to fit all the pieces together.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114636Z" creationid="shibukawa.yoshiki" creationdate="20150417T114636Z">
        <seg>また、ガイドのセクションでは、すべての部品をどのように組み合わせていくかという内容もカバーしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, you cannot call m.request from templates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094829Z" creationid="shibukawa.yoshiki" creationdate="20150502T094829Z">
        <seg>それに加えて、テンプレート内でm.requestは使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In classic MVC, the role of the controller is to dispatch actions from the view to the model layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163947Z" creationid="shibukawa.yoshiki" creationdate="20150407T163947Z">
        <seg>クラシカルなMVCでは、ビューからやってきたアクションを、モデルのレイヤーにディスパッチするのがコントローラの役割です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In client-side MVC, however, this dissonance doesn't exist, and controllers can be extremely simple.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T002248Z" creationid="shibukawa.yoshiki" creationdate="20150408T002248Z">
        <seg>クライアントサイドMVCではこのような定義との不一致は存在しないため、コントローラは極めてシンプルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to layered integration, it minimizes the number of m.startComputation / m.endComputation calls to avoid clutter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010544Z" creationid="shibukawa.yoshiki" creationdate="20150412T010544Z">
        <seg>階層に分けた統合と比べると、m.startComputation / m.endComputation呼び出しが最小限になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to layered integration, it minimizes the number of m.startComputation / m.endComputation to avoid clutter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160320Z" creationid="shibukawa.yoshiki" creationdate="20150416T160320Z">
        <seg>階層に分けた統合と比べると、m.startComputation / m.endComputation呼び出しが最小限になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, m.redraw is "aggressive": it redraws as many times as it is called (with the caveat that redraws are batched if they occur less than one animation frame apart in time).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114429Z" creationid="shibukawa.yoshiki" creationdate="20150502T114429Z">
        <seg>これとは対照的にm.redrawは「アグレッシブ」です。このメソッドは、呼ばれた回数だけ再描画を行おうとします(実際には、同一フレーム内の呼び出しはまとめます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, m.redraw is "aggressive": it redraws as many times as it is called (with the caveat that redraws are batched if they occur less than one animation frame apart in time).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130609Z" creationid="shibukawa.yoshiki" creationdate="20150502T130609Z">
        <seg>これとは対照的にm.redrawは「アグレッシブ」です。このメソッドは、呼ばれた回数だけ再描画を行おうとします(実際には、同一フレーム内の呼び出しはまとめます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, Mithril avoids "magic" types.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110513Z" creationid="shibukawa.yoshiki" creationdate="20150420T110513Z">
        <seg>Mithrilではこのように「魔法」の型を避ける実装になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, Mithril encourages you to develop applications using the patterns found throughout this guide, and discourages the use of "bastardized" MVC pattern variations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020610Z" creationid="shibukawa.yoshiki" creationdate="20150420T020610Z">
        <seg>Mithrilはこれとは対照的に、このガイドで示しているようなアプリケーション開発のパターンを共通言語として広めようとしています。それにより、「質の悪いMVCもどきのパターン」が広まるのを防ごうとしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, Mithril separates the two layers more distinctly.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105625Z" creationid="shibukawa.yoshiki" creationdate="20150420T105625Z">
        <seg>それに対して、Mithrilははっきりと2つのレイヤーを分離しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, Mithril is able to render a fully functional application - with working event handlers - before the "DOM ready" event fires!</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013547Z" creationid="shibukawa.yoshiki" creationdate="20150409T013547Z">
        <seg>実際に、Mithrilは完全に機能を持ちイベントハンドラができる状態になってから描画を行います。DOMの準備ができるというイベントが発生する前にです！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, unavoidable abstraction leaks (such as network-bound asynchrony) are laid out in such a way as to make idiomatic code organization elegant, and conversely, to make it so that the abstraction leak problems themselves discourage attempts to misplace entity logic in the controller.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032301Z" creationid="shibukawa.yoshiki" creationdate="20150421T014824Z">
        <seg>抽象化が漏れて、レイヤーを超えてコードが密結合してしまうコードというのはあります。例えばネットワークの非同期性を取り扱う場合にこのようなことがあります。この場合も、エンティティのロジックがコントローラの中に取り残されがちです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, when not using the MSX HTML syntax preprocessor, it's recommended that you embrace using CSS selectors (e.g. m(".modal-body")) to really benefit from their inherent semantic expressiveness.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041537Z" creationid="shibukawa.yoshiki" creationdate="20150502T041537Z">
        <seg>MSXHTML文法プリプロセッサを使っていなくても、本来のセマンティック表現の恩恵を受けられるため、m(".modal-body")のようなCSSセレクタ形式を使うことを推奨しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In functional programming, this is called partial application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151412Z" creationid="shibukawa.yoshiki" creationdate="20150408T151412Z">
        <seg>関数型プログラミングの世界では、これは部分適用(partial application)と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In it, the count is stored in the context object and re-accessed on each redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125936Z" creationid="shibukawa.yoshiki" creationdate="20150413T125936Z">
        <seg>このコードの中で、再描画のカウントはコンテキストオブジェクト内に格納されます。このオブジェクトは再描画のたびにアクセスができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its place, ContactForm merely emits an action, which is then handled by this model layer observer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031544Z" creationid="shibukawa.yoshiki" creationdate="20150502T031544Z">
        <seg>ContactFormでは単に、アクションを送信しています。これはモデルレイヤーのオブザーバが受け取って処理をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In jQuery it's common to use the DOM as a data storage mechanism, whereas Mithril encourages data to exist in an isolated model layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015734Z" creationid="shibukawa.yoshiki" creationdate="20150420T015734Z">
        <seg>jQueryはDOMをデータ構造のための箱として使いますが、Mithrilはデータをそれと分離したモデルレイヤーに分けようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many frameworks UI state is typically stored in a controller, but doing so makes the code harder to scale since controllers aren't designed to be data providers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152609Z" creationid="shibukawa.yoshiki" creationdate="20150407T152609Z">
        <seg>多くのフレームワークでは、UIの状態はコントローラの内部に保持されます。しかし、コントローラはデータプロバイダとしてデザインされていないため、このような構造にしてしまうと、コードをスケールさせるのが難しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In model-level methods if client-side processing is needed to make the data useful for a controller or view</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125646Z" creationid="shibukawa.yoshiki" creationdate="20150410T125646Z">
        <seg>モデルレベルのメソッド内で、コントローラやビューに対して処理しやすい形式のデータへの変換をクライアント側で行わなければならない場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to allow a user to navigate between different pages by loading and unloading components, consider using m.route instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125327Z" creationid="shibukawa.yoshiki" creationdate="20150502T125327Z">
        <seg>もし、複数のページ間でユーザをナビゲーションをして、その時にコンポーネントのロード/リロードを行いたい場合は、m.routeを代わりに使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to deal with that type of refactoring, one can explicitly decide to support only a subset of the Array API, and implement another class with the same interface as this subset API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003539Z" creationid="shibukawa.yoshiki" creationdate="20150409T003539Z">
        <seg>TodoListのようなクラスをリファクタリングする時は、ArrayクラスのAPIの一部だけをサポートするか、似た機能を持つまったく他のクラスを実装するか決定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to enable auto-redrawing, the todo component must be initialized by either calling m.mount or by creating a route definition with m.route.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041601Z" creationid="shibukawa.yoshiki" creationdate="20150502T041601Z">
        <seg>自動再描画システムを利用する場合は、 m.mountを使ってtodoコンポーネントを初期化するか、m.routeを使ってラウト(route)を定義する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to force a redraw after a background request, use m.redraw, or m.startComputation / m.endComputation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012022Z" creationid="shibukawa.yoshiki" creationdate="20150415T012022Z">
        <seg>バックグラウンドのリクエスト後に再描画を行わせたい場合は、m.redrawもしくはm.startComputation / m.endComputationを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to implement this principle, the rendering engine must run a redraw algorithm globally to ensure no parts of the UI are out of sync with the data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183754Z" creationid="shibukawa.yoshiki" creationdate="20150411T183754Z">
        <seg>この原則をきちんと実装するためには、データとの同期が漏れているUI部品がなくならないようにするために、再描画のアルゴリズムをビュー全体に対して漏れ無く実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to integrate an asynchronous code to Mithril's autoredrawing system, you should call m.startComputation BEFORE making an asynchronous call, and m.endComputation after the asynchronous callback completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153136Z" creationid="shibukawa.yoshiki" creationdate="20150416T153136Z">
        <seg>非同期のコードとMithrilの自動再描画システムを統合する時は、非同期処理を呼び出す「前に」m.startComputationを呼び出し、非同期のコールバックの最後でm.endComputationを呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to integrate asynchronous code to Mithril's autoredrawing system, you should call m.startComputation BEFORE making an asynchronous call, and m.endComputation at the end of the asynchronous callback.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192747Z" creationid="shibukawa.yoshiki" creationdate="20150411T192747Z">
        <seg>非同期のコードとMithrilの自動再描画システムを統合する時は、非同期処理を呼び出す「前に」m.startComputationを呼び出し、非同期のコールバックの最後でm.endComputationを呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to integrate non-trivial asynchronous code to Mithril's auto-redrawing system, you need to ensure all execution threads call m.startComputation / m.endComputation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155920Z" creationid="shibukawa.yoshiki" creationdate="20150416T155920Z">
        <seg>自明でない非同期処理のコードとMithrilの自動再描画システムを統合するときには、確実にすべてのスレッドでm.startComputation / m.endComputationを呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to integrate non-trivial asynchronous code with Mithril's auto-redrawing system, you need to ensure all execution threads call m.startComputation / m.endComputation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004625Z" creationid="shibukawa.yoshiki" creationdate="20150412T004625Z">
        <seg>自明でない非同期処理のコードとMithrilの自動再描画システムを統合するときには、確実にすべてのスレッドでm.startComputation / m.endComputationを呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to prevent redraws in some parts of an application, but not others, see subtree directives</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T145222Z" creationid="shibukawa.yoshiki" creationdate="20150416T145222Z">
        <seg>アプリケーション内の一部分の再描画だけを止めたい場合は、サブツリーディレクティブを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to retrieve the currently active route in a controller, you can use m.route().</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171909Z" creationid="shibukawa.yoshiki" creationdate="20150414T171909Z">
        <seg>コントローラ内で、現在アクティブなラウトを取得するには、m.route()を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to specify the name of the querystring parameter that indicates the callback function, use the callbackKey option:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235625Z" creationid="shibukawa.yoshiki" creationdate="20150414T235625Z">
        <seg>コールバック関数を表すクエリー文字列を指定するには、callbackKeyを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to stay flexible, Mithril doesn't provide helpers for bi-directional bindings out of the box.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014108Z" creationid="shibukawa.yoshiki" creationdate="20150413T014108Z">
        <seg>柔軟性を維持するために、Mithrilでは双方向バインディングを生成するヘルパーは提供していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to turn the virtual element into a real DOM element, you must call m.render().</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000156Z" creationid="shibukawa.yoshiki" creationdate="20150413T000156Z">
        <seg>仮想DOMを本物のDOMに変換するにはm.render()を呼ぶ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to update a forked version of Mithril, follow the instructions on this page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000743Z" creationid="shibukawa.yoshiki" creationdate="20150408T000743Z">
        <seg>フォークしたMithrilを更新したい場合は、このページの説明(英語).に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to use Mithril, extract it from the zip file and point a script tag to the .js file:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164806Z" creationid="shibukawa.yoshiki" creationdate="20150407T164806Z">
        <seg>Mithrilを使用する場合は、zipファイルを展開し、その中の.jsファイルをscriptタグを使って指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, all our controller needs to do is this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004121Z" creationid="shibukawa.yoshiki" creationdate="20150408T004109Z">
        <seg>Mithrilのコントローラが行うべきことは、次のコードがすべてです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, don't do this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100006Z" creationid="shibukawa.yoshiki" creationdate="20150502T100006Z">
        <seg>別の説明をすると、以下のようなことをしてはならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, since the whole application lives in one component, we're going to use the component as a namespace for our model entities.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040727Z" creationid="shibukawa.yoshiki" creationdate="20150502T040727Z">
        <seg>今回のサンプルではすべてのアプリケーションが1つのコンポーネントに収まっているため、コンポーネントを名前空間として使い、モデルの実体もその中にいれてしまいましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means performing operations like shifting an item from the beginning of a list would cause every element in the list to be diffed and potentially recreated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141226Z" creationid="shibukawa.yoshiki" creationdate="20150413T141226Z">
        <seg>例えば、リストの先頭に挿入するような操作は、すべての要素が変更されたとみなして、すべてが再生成されてしまう可能性もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that calling m.component(MyComponent, {foo: "bar"}) will return a component that behaves exactly the same as MyComponent, but {foo: "bar"} will be bound as an argument to both the controller and view functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075727Z" creationid="shibukawa.yoshiki" creationdate="20150502T075727Z">
        <seg>m.component(MyComponent, {foo: "bar"})という呼び出しをすると、MyComponentと同じコンポーネントを返しますが、{foo: "bar"}という引数がcontrollerとview関数に束縛されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that calling m.redraw may cause a redraw to happen before some AJAX calls have finished, which in turn, may cause null reference exceptions in templates that try to use the data from these requests without first checking that the data exists.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T115057Z" creationid="shibukawa.yoshiki" creationdate="20150502T115057Z">
        <seg>m.redrawを使うと、AJAX呼び出しの完了前に再描画を実行させることができます。データの存在のチェックを行わないと、null参照例外が発生する恐れがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that calling m.redraw may cause a redraw to happen before some AJAX calls have finished, which in turn, may cause null reference exceptions in templates that try to use the data from these requests without first checking that the data exists.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130619Z" creationid="shibukawa.yoshiki" creationdate="20150502T130619Z">
        <seg>m.redrawを使うと、AJAX呼び出しの完了前に再描画を実行させることができます。データの存在のチェックを行わないと、null参照例外が発生する恐れがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that if the two components were in a ContactsWidget component as before, saving a contact would not update the list without some extra code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015527Z" creationid="shibukawa.yoshiki" creationdate="20150502T015527Z">
        <seg>実際、ContactsWidget内にコンポーネントが2つあるとすると、何もコードを追加しなければリストが更新されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In real life, given a choice, you should always pick the simplest idiom for your use case.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152802Z" creationid="shibukawa.yoshiki" creationdate="20150408T152802Z">
        <seg>実際のコーディングでは、いくつか選択肢があった場合には、ユースケースを実現するもっともシンプルな方法を選択すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a case, it's the view-model's responsibility to track the current state of the input vs the original state and to apply a cancellation, if required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T160811Z" creationid="shibukawa.yoshiki" creationdate="20150407T160650Z">
        <seg>このケースでは、ビュー・モデルは、オリジナルの状態とテキスト入力の現在の状態の差のトラッキングと、キャンセル処理の提要に関する責任を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, simply omit the m.startComputation/m.endComputation calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135804Z" creationid="shibukawa.yoshiki" creationdate="20150415T135804Z">
        <seg>その場合は、単にm.startComputation/m.endComputation呼び出しを省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In terms of architecture, one of Mithril's main differences is that it does not provide base classes to extend from.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114958Z" creationid="shibukawa.yoshiki" creationdate="20150417T114958Z">
        <seg>アーキテクチャ面でみると、Mithrilが他のフレームワークと大きく異るのは、拡張する元となるベースクラスを提供していない点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, it's possible to skip redrawing altogether by calling m.redraw.strategy("none")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150228Z" creationid="shibukawa.yoshiki" creationdate="20150416T150228Z">
        <seg>この場合、m.redraw.strategy("none")を呼ぶことで、再描画をスキップできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the application above, notice how the Todo class can easily be moved to a different component if code re-organization is required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041831Z" creationid="shibukawa.yoshiki" creationdate="20150502T041831Z">
        <seg>上記のコードのTodoクラスは、もしコードを再構成する必要が出てきたとしても、とても簡単に他のコンポーネントに移動できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case above, Mithril only touches the value attribute of the input.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015644Z" creationid="shibukawa.yoshiki" creationdate="20150408T015644Z">
        <seg>上記の場合、Mithrilはテキスト入力のvalue属性しか変更しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of our todo application, the view-model needs a few things: it needs to track a running list of todos and a field for adding new todos, and it needs to handle the logic of adding to the todo and the implications of this action of the UI.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161612Z" creationid="shibukawa.yoshiki" creationdate="20150407T161441Z">
        <seg>われわれのToDoアプリケーションでは、ビュー・モデルに必要とされるものはそれほど多くありません。アクティブなToDoのリストと、新しいToDoを追加するためのフィールドの管理、ToDoを追加するロジックや、UIのアクションとの連携です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, todo.vm.list is an Array, and map is one of its native functional methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153022Z" creationid="shibukawa.yoshiki" creationdate="20150408T153022Z">
        <seg>上記のコードのtodo.vm.listはJavaScriptの配列です。mapは関数型プログラミング的な機能を提供する、標準の関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, the oninput event handler updates the name getter-setter, and the Mithril auto-redrawing system redraws the template in order to update the displayed value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014815Z" creationid="shibukawa.yoshiki" creationdate="20150413T014815Z">
        <seg>この上記のサンプルを実行すると、oninputイベントハンドラがname getter-setterを更新します。Mithrilの自動再描画システムが表示される値の更新にともなって再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, we are simply using the native Javascript Function::bind method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151318Z" creationid="shibukawa.yoshiki" creationdate="20150408T151318Z">
        <seg>上記のコードは、標準的なJavaScriptのFunction::bindメソッドを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the controller layer: to bind error messages</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123840Z" creationid="shibukawa.yoshiki" creationdate="20150410T123840Z">
        <seg>コントローラレイヤ内: エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the controller layer: to bind redirection code upon a condition</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123813Z" creationid="shibukawa.yoshiki" creationdate="20150410T123726Z">
        <seg>コントローラレイヤ内: 条件によって、リダイレクトするコードをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the controller, to bind error messages</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125741Z" creationid="shibukawa.yoshiki" creationdate="20150410T125741Z">
        <seg>コントローラ内で、エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the controller, to redirect after a model service resolves</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125727Z" creationid="shibukawa.yoshiki" creationdate="20150410T125727Z">
        <seg>コントローラ内で、モデルサービスが改良した後にリダイレクトさせたい場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the event the form was saved, then view-model would delegate saving to a more appropriate ORM model entity.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T160932Z" creationid="shibukawa.yoshiki" creationdate="20150407T160923Z">
        <seg>フォームが保存されるというイベントが発生したら、ビュー・モデルはより適切なORMモデルエンティティに保存処理を移譲します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, A+ promises are required to log 2 before logging 1, whereas Mithril logs 1 before 2.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140509Z" creationid="shibukawa.yoshiki" creationdate="20150415T140509Z">
        <seg>このサンプルを実行すると、A+ promisesの場合は、 1の前に2をログ出力しますが、Mithrilは2の前に1を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, input focus would be maintained correctly after a redraw even if items got sorted or reversed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142321Z" creationid="shibukawa.yoshiki" creationdate="20150413T142321Z">
        <seg>上記のサンプルでは、itemsがソートされたり、順序が逆転したあとに再描画されても、正しくフォーカスが維持されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, since the key is different, the ProjectList component is recreated from scratch.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085849Z" creationid="shibukawa.yoshiki" creationdate="20150502T085849Z">
        <seg>上記の例では、キーが異なるため、ProjectListのコンポーネントは一度破棄されて再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the text input is bi-directionally bound to a temp getter-setter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081318Z" creationid="shibukawa.yoshiki" creationdate="20150502T081318Z">
        <seg>上記のサンプルは、テキスト入力と、temp getter-setterが双方向のバインディングで接続されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the usage of m.prop allows the developer to change the implementation of the user name getter/setter without the need for code changes in the controller and view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134725Z" creationid="shibukawa.yoshiki" creationdate="20150414T134725Z">
        <seg>上記のサンプルでは、m.propを使うことで、コントローラとビュー内のコードを変更することなく、ユーザ名のgetter/setterの実装を変更できるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, there are 3 components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T001408Z" creationid="shibukawa.yoshiki" creationdate="20150502T001408Z">
        <seg>上記のサンプルには3つのコンポーネントが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, User.list returns a list of User instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170638Z" creationid="shibukawa.yoshiki" creationdate="20150410T170552Z">
        <seg>次のサンプルでは、User.listメソッドは、Userインスタンスのリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, clicking the button triggers the component's onunload event and logs "unloaded!".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092735Z" creationid="shibukawa.yoshiki" creationdate="20150502T092735Z">
        <seg>次のサンプルはボタンを押すとコンポーネントのonunloadイベントが呼ばれ、"アンロード!"とログに出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the listEven method returns a getter-setter that resolves to a list of users containing only users whose id is even.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124205Z" creationid="shibukawa.yoshiki" creationdate="20150410T124205Z">
        <seg>下記のサンプルのlistEvenメソッドは、IDが偶数のユーザを含むリストのみを返すgetter-setterを返しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, there are two routes, each of which loads a component when a user navigates to their respective URLs.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124551Z" creationid="shibukawa.yoshiki" creationdate="20150502T124551Z">
        <seg>下記のサンプルには、2つのラウトがあります。ユーザがどちらかのURLにアクセスすると、それぞれのコンポーネントをロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, we bind an error getter-setter to our previous controller so that the error variable gets populated if the server throws an error.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125140Z" creationid="shibukawa.yoshiki" creationdate="20150410T125140Z">
        <seg>下記のサンプルでは、error getter-setterと、前のサンプルで紹介したコントローラをバインドしています。error変数は、サーバアクセスがうまく行かなかった時に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, we take advantage of queuing to debug the AJAX response data prior to doing further processing on the user list</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175107Z" creationid="shibukawa.yoshiki" creationdate="20150414T175107Z">
        <seg>下記のサンプルはAJAXレスポンスが実際に処理される前に、デバッグ処理を差し込んでいます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, we take advantage of queuing to debug the AJAX response data prior to doing further processing on the user list:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130243Z" creationid="shibukawa.yoshiki" creationdate="20150410T125757Z">
        <seg>下記のサンプルはAJAXレスポンスが実際に処理される前に、デバッグ処理を差し込んでいます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, we use the previously defined listEven model method and queue a controller-level function that redirects to another page if the user list is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124651Z" creationid="shibukawa.yoshiki" creationdate="20150410T124651Z">
        <seg>下記の例では、前の例で定義したモデルのlistEvenメソッドを使用します。ユーザのリストが空の場合に他のページにリダイレクトするというコントローラレベルの機能をモデル完了後の操作としてキューイングしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the model layer: to process web service data in transformative ways (e.g. filtering a list based on a parameter that the web service doesn't support)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123731Z" creationid="shibukawa.yoshiki" creationdate="20150410T123712Z">
        <seg>モデルレイヤ内: ウェブサービスから受信したデータを変換処理をする場合。例えばウェブサービス側でサポートしていないフィルタリングをクライアント側で行う場合など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the view-model, we aliased the native Array class for TodoList.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002657Z" creationid="shibukawa.yoshiki" creationdate="20150409T002628Z">
        <seg>サンプルのビュー・モデルの中で、TodoListクラスを単なる配列のエイリアスとして定義しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, since there's only one route, the app redirects to the default route "/dashboard/johndoe" and, under the hood, it calls m.mount(document.body, dashboard).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140257Z" creationid="shibukawa.yoshiki" creationdate="20150502T140257Z">
        <seg>この場合、ひとつのラウトしかないため、アプリケーションはデフォルトのラウトの"/dashboard/johndoe"にリダイレクトして、フレームワーク内でm.mount(document.body, dashboard)が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, since there's only one route, the app redirects to the default route "/dashboard/johndoe".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153557Z" creationid="shibukawa.yoshiki" creationdate="20150414T153557Z">
        <seg>この場合、ひとつのラウトしかないため、アプリケーションはデフォルトのラウトの"/dashboard/johndoe"にリダイレクトされます。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, we're using them in a way that resembles C pointers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152219Z" creationid="shibukawa.yoshiki" creationdate="20150408T152219Z">
        <seg>上記の例の場合は、Cのポインタのような機能を実現しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this iteration, both the ContactForm and ContactList components are now children of the ContactsWidget component and they appear simultaneously on the same page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T020806Z" creationid="shibukawa.yoshiki" creationdate="20150502T020806Z">
        <seg>ここでは、ContactFormコンポーネントとContactListコンポーネントはContactsWidgetコンポーネントの子供になっていて、どちらも同じページ内で表示されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this sense, one could argue that Mithril isn't really a framework.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T142604Z" creationid="shibukawa.yoshiki" creationdate="20150417T142604Z">
        <seg>この意味では、Mithrilは本当はフレームワークではないと言われる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In those cases, you can call m.redraw instead of using m.startComputation/m.endComputation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135913Z" creationid="shibukawa.yoshiki" creationdate="20150415T135913Z">
        <seg>この場合は、m.startComputation/m.endComputationを呼ぶ代わりに、m.redrawを呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In traditional server-side frameworks, the controller layer is of large significance because the nature of HTTP requests, responses and the framework abstractions that are exposed to developers require that the controller act as an adapter layer to transform the serialized data from HTTP requests to something that can be passed to ORM model methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T002057Z" creationid="shibukawa.yoshiki" creationdate="20150408T002057Z">
        <seg>伝統的なサーバーサイドフレームワークでは、HTTPのリクエスト、レスポンスおよび、開発者に公開されているフレームワークの抽象化という性質を考えると、コントローラレイヤはとても大きな役割を持つレイヤです。コントローラはHTTPのリクエストからシリアライズされたデータを取り出して変換して、ORMのモデルのメソッドに渡したりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Installation</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140627Z" creationid="shibukawa.yoshiki" creationdate="20150407T140627Z">
        <seg>インストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Installation - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164330Z" creationid="shibukawa.yoshiki" creationdate="20150407T164330Z">
        <seg>インストール - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Installing NodeJS and SweetJS for one-off compilations</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150018Z" creationid="shibukawa.yoshiki" creationdate="20150412T150018Z">
        <seg>事前コンパイルのためのNodeJSとSweetJSのインストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of copying arguments to the controller object and then passing the controller object to the view (thereby creating internal state in the component), it is often desirable that views update based on the current value of arguments initially passed to a component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081032Z" creationid="shibukawa.yoshiki" creationdate="20150502T081032Z">
        <seg>コントローラオブジェクトに引数を渡して、コントローラオブジェクトからビューに渡すという実装の場合はコンポーネントの内部状態ができてしまいます。初期化時に渡される引数にもとづいてビューを更新するほうが望ましい場面が多いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of locking developers down to very specific implementations of design patterns, Mithril's approach is to provide an idiomatic pattern to follow, and tools to aid the developer when required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T144352Z" creationid="shibukawa.yoshiki" creationdate="20150417T144352Z">
        <seg>決まった設計のパターンでプログラマを拘束して、画一化された実装をさせるのではなく、Mithrilは従うべきイディオムのパターンを提供し、必要であればツールを提供するというアプローチをとっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Mithril relies on m.startComputation and m.endComputation calls to figure out when to redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154046Z" creationid="shibukawa.yoshiki" creationdate="20150416T154046Z">
        <seg>Mithrilは再描画のタイミングを、m.startComputationとm.endComputationの呼び出しで決めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Mithril's redrawing system relies on m.startComputation and m.endComputation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134021Z" creationid="shibukawa.yoshiki" creationdate="20150414T134021Z">
        <seg>Mithrilの再描画システムは、m.startComputationとm.endComputationの呼び出しをトリガーとして実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it's composed of pure functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080644Z" creationid="shibukawa.yoshiki" creationdate="20150502T080644Z">
        <seg>実際には、純粋関数の集合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating multiple execution threads</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T003701Z" creationid="shibukawa.yoshiki" creationdate="20150412T003701Z">
        <seg>複数実行スレッドの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating multiple execution threads can be done in a two different ways: in a layered fashion or in comprehensive fashion</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155947Z" creationid="shibukawa.yoshiki" creationdate="20150416T155947Z">
        <seg>複数の実行スレッドのコードと統合を行うには2つの方法があります。階層に分けて行う方法と、統括的に行う方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating multiple execution threads can be done in two different ways: in a layered fashion or in comprehensive fashion.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004835Z" creationid="shibukawa.yoshiki" creationdate="20150412T004835Z">
        <seg>複数の実行スレッドのコードと統合を行うには2つの方法があります。階層に分けて行う方法と、統括的に行う方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating to legacy code</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T140345Z" creationid="shibukawa.yoshiki" creationdate="20150412T140345Z">
        <seg>レガシーコードとの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating to the Mithril redrawing system</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014919Z" creationid="shibukawa.yoshiki" creationdate="20150415T014919Z">
        <seg>Mithrilの再描画システムへの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating with Other Libraries</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140911Z" creationid="shibukawa.yoshiki" creationdate="20150407T140911Z">
        <seg>他のライブラリとの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating with Other Libraries - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T013529Z" creationid="shibukawa.yoshiki" creationdate="20150412T013529Z">
        <seg>他のライブラリとの統合 - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating with The Auto-Redrawing System</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192317Z" creationid="shibukawa.yoshiki" creationdate="20150411T192317Z">
        <seg>自動再描画システムの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating with the Auto-Redrawing System</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015846Z" creationid="shibukawa.yoshiki" creationdate="20150409T015846Z">
        <seg>自動再描画システムの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integration with third party libraries or vanilla javascript code can be achieved via the config attribute of virtual elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T013900Z" creationid="shibukawa.yoshiki" creationdate="20150412T013900Z">
        <seg>サードパーティライブラリや、pure JavaScriptのコードと統合するには、仮想エレメントのconfig属性を使って行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Intelligent auto-redrawing system</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134217Z" creationid="shibukawa.yoshiki" creationdate="20150407T134217Z">
        <seg>インテリジェントな自動再描画システム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, Mithril keeps a virtual representation of the DOM in cache, scans for changes, and then only modifies the absolute minimum required to apply the change to the DOM. In practice, this results in surprisingly fast re-rendering.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015608Z" creationid="shibukawa.yoshiki" creationdate="20150408T015608Z">
        <seg>Mitril内部では、仮想的に表現されたDOMをキャッシュとして持っていて、変更を検知して変更に必要な最小限の更新だけどDOMに対して行います。そのため、極めて高速に再レンダリングを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, Mithril uses this data representation of the DOM to probe for data changes and update the DOM only where necessary.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072523Z" creationid="shibukawa.yoshiki" creationdate="20150502T072523Z">
        <seg>内部的にMithrilはこのDOMのデータ構造を使用して、データの変更を検知し、必要なところだけDOMを更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internet Explorer 8 lacks native support for some of these features.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014525Z" creationid="shibukawa.yoshiki" creationdate="20150417T014525Z">
        <seg>Internet Explorer 8では、これらの機能のうちのいくつかが使えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internet Explorer Compatibility</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014414Z" creationid="shibukawa.yoshiki" creationdate="20150417T014414Z">
        <seg>Internet Explorerの互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows us to iterate over the list and merge transformed versions of the list items into an output array.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153155Z" creationid="shibukawa.yoshiki" creationdate="20150408T153155Z">
        <seg>このメソッドを使うと、配列の全要素に対して変換処理を行い、その結果の要素で構成される配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also causes page refreshes in IE8.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005455Z" creationid="shibukawa.yoshiki" creationdate="20150410T005455Z">
        <seg>このモードも、IE8でページリフレッシュが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It always causes page refreshes in IE8.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170121Z" creationid="shibukawa.yoshiki" creationdate="20150414T170121Z">
        <seg>IE8上では、常にページリフレッシュが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be one of three values:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152254Z" creationid="shibukawa.yoshiki" creationdate="20150416T152254Z">
        <seg>これには次の3つの値のうちの1つを設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used in conjunction with m.withAttr to implement data binding in the view-to-model direction and to provide uniform data access for model entity properties.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134502Z" creationid="shibukawa.yoshiki" creationdate="20150414T134502Z">
        <seg>この関数をm.withAttrと一緒に使うことで、ビューとモデル間のデータバインディングを作成し、モデルエンティティのプロパティのデータアクセス方法を平準化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used to store instances of 3rd party classes that need to be accessed more than one time throughout the lifecycle of a page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155420Z" creationid="shibukawa.yoshiki" creationdate="20150413T155420Z">
        <seg>このオブジェクトはページのライフサイクルを通じて何度もアクセスする必要がある、サードパーティのクラスのインスタンスを保持するのにも使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can call model methods directly or from methods inside the resulting object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061620Z" creationid="shibukawa.yoshiki" creationdate="20150502T061620Z">
        <seg>オブジェクトから、モデルのメソッドを直接呼び出したり、あるいはオブジェクトのメソッド内部から呼び出すことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can contain methods meant to be called by a view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061539Z" creationid="shibukawa.yoshiki" creationdate="20150502T061539Z">
        <seg>viewと呼ばれるメソッドを持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can hold a reference to a view model.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061819Z" creationid="shibukawa.yoshiki" creationdate="20150502T061819Z">
        <seg>ビューモデルへの参照を持つことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can store contextual data returned from model methods (i.e. a promise from a request).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061807Z" creationid="shibukawa.yoshiki" creationdate="20150502T061807Z">
        <seg>requestが返すpromiseなどのモデルメソッドが返すデータを保持することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It contains controller and view properties.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003534Z" creationid="shibukawa.yoshiki" creationdate="20150410T003534Z">
        <seg>モジュールはcontrollerプロパティとviewプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It contains a controller and a view properties.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153622Z" creationid="shibukawa.yoshiki" creationdate="20150414T153622Z">
        <seg>モジュールはcontrollerプロパティとviewプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does not, however, de-dupe classes if the same class is declared twice.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153331Z" creationid="shibukawa.yoshiki" creationdate="20150413T153331Z">
        <seg>ただし、同じクラスが2度宣言されていたら、重複は取り除かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does this because people expect unexpected errors like null reference exceptions to be thrown to the console for debugging purposes, and these errors are always subclasses of Error.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174459Z" creationid="shibukawa.yoshiki" creationdate="20150415T174459Z">
        <seg>Mithrilがこのような動作をするのは、多くのプログラマにとって、null参照例外などの未知の例外はデバッグのためにコンソールに出力される方がうれしいからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It enables seamless navigability while preserving the ability to bookmark each page individually, and the ability to navigate the application via the browser's history mechanism.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T020245Z" creationid="shibukawa.yoshiki" creationdate="20150409T020245Z">
        <seg>この機能を使うと、各ページをブックマークしたり、ブラウザの履歴の機能はそのままに、シームレスなナビゲーションが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It exposes a promise property which can bind callbacks to build a computation tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T133727Z" creationid="shibukawa.yoshiki" creationdate="20150415T133512Z">
        <seg>deferredは、コールバックをバインドして、グラフ構造の計算木を構築するのに使えるpromiseプロパティを公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It exposes an event called onsave which is fired when the Save button is pressed on the form.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002029Z" creationid="shibukawa.yoshiki" creationdate="20150502T002029Z">
        <seg>このモジュールは、フォーム上の保存ボタンが押された時に起動されるonsaveイベントを公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has a method then which takes a successCallback and a errorCallback callbacks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134220Z" creationid="shibukawa.yoshiki" creationdate="20150415T134220Z">
        <seg>このプロパティは、successCallbackコールバックと、errorCallbackコールバックを受け取る、thenメソッドを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It includes support for the MSX HTML templating syntax from Jonathan Buchanan.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000150Z" creationid="shibukawa.yoshiki" creationdate="20150408T000150Z">
        <seg>これは、Jonathan Buchananが作成した、HTMLテンプレートの文法のMSXも含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is expected that such an error would bubble up to the console and display a developer-friendly error message and line number there.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172954Z" creationid="shibukawa.yoshiki" creationdate="20150415T172954Z">
        <seg>このようなエラーに対しては、例外が発生したときにエラーメッセージと行番号をコンソールに表示する方が開発者にやさしいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is modified internally by Mithril to the value "all" before running controller constructors, and to the value "diff" after all redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152628Z" creationid="shibukawa.yoshiki" creationdate="20150416T152628Z">
        <seg>コントローラの構築が行われると、Mithrilは内部的にこのフラグを"all"に設定し、再描画が行われると"diff"に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not a full MVC framework, but it is similar to Angular templates, and uses the same terminology for its features (e.g. directives and filters).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110014Z" creationid="shibukawa.yoshiki" creationdate="20150420T110014Z">
        <seg>これは完全なMVCフレームワークではありませんが、Angularのテンプレートと似ています。ディレクティブやフィルタなど、機能に対して同じ用語を使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not an MVC framework in the traditional sense, but idiomatic Knockout code uses the similar concept of view models.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105504Z" creationid="shibukawa.yoshiki" creationdate="20150420T105504Z">
        <seg>これは伝統的な意味でのMVCフレームワークではありませんが、Knockoutが推奨しているスタイルに従ったコードは、ビュー・モデルと似たコンセプトを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is simply a javascript object that has a init function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T162128Z" creationid="shibukawa.yoshiki" creationdate="20150407T162128Z">
        <seg>ビュー・モデルオブジェクトは、init関数を持つ、シンプルなJavaScriptのオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is strongly recommended that you always set this option to avoid future surprises.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012549Z" creationid="shibukawa.yoshiki" creationdate="20150415T012549Z">
        <seg>このオプションは将来落とし穴に落ちないように設定することを強く勧めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the developer's responsibility to ensure the input to m.trust cannot be maliciously modified by user-entered data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015328Z" creationid="shibukawa.yoshiki" creationdate="20150416T015328Z">
        <seg>悪意をもってユーザが入力したデータをm.trustに通す責任は開発者にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is useful for injecting a mock window dependency for the purposes of testing and for running Mithril in non-browser environments.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160736Z" creationid="shibukawa.yoshiki" creationdate="20150416T160736Z">
        <seg>このカンスを使うと、モックのwindowの依存性を注入できます。非ブラウザ環境でテストしたり、Mithrilを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is useful for teams where styling and functionality are done by different people, and for those who prefer to maintain templates in HTML syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013844Z" creationid="shibukawa.yoshiki" creationdate="20150417T013844Z">
        <seg>このツールは、スタイリングと機能の実装が異なるチームで行われていて、テンプレートのメンテナンスにHTML文法が使いたい場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It leverages developer experience with server-side MVC frameworks, and in many ways, is very similar in scope to Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025052Z" creationid="shibukawa.yoshiki" creationdate="20150420T025052Z">
        <seg>サーバサイドのMVCフレームワークのある人がすぐに使いこなせるように作られている点など、多くの面でMithrilと非常に似通っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may sound expensive to recompute an entire view any time there's a change to be displayed, but this operation actually turns out to be quite fast, compared to rendering strategies used by older frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T074725Z" creationid="shibukawa.yoshiki" creationdate="20150502T074725Z">
        <seg>一見、変更を表示するたびに、このビュー全体に対する再計算を行うのは高コストな処理に見えるかもしれませんが、以前からあったフレームワークが使うレンダリングの方法論に比べると極めて高速です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It pre-processes the m() call and replaces it with its output:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T145827Z" creationid="shibukawa.yoshiki" creationdate="20150412T145827Z">
        <seg>このマクロはm()関数の呼び出しを事前に処理してし次のような関数を生成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides a number of useful features out of the box:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014234Z" creationid="shibukawa.yoshiki" creationdate="20150410T014234Z">
        <seg>提供される便利な機能には次のようなものがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides a templating engine with a virtual DOM diff implementation for performant rendering, utilities for high-level modelling via functional composition, as well as support for routing and componentization.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141605Z" creationid="shibukawa.yoshiki" creationdate="20150407T141605Z">
        <seg>Mithrilは、ハイパフォーマンスなレンダリング速度を持つ、仮想DOMの差分更新機能を持ったテンプレートエンジンや、関数型によるハイレベルなモデリングのサポート、ルーティング機能、コンポーネント化をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides full Turing completeness: full control over evaluation eagerness/laziness and caching in templates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021616Z" creationid="shibukawa.yoshiki" creationdate="20150409T021616Z">
        <seg>Mithrilのテンプレートはチューリング完全です。先行評価と遅延評価を完全に制御できますし、テンプレートのキャッシュも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns a function that stores information.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133846Z" creationid="shibukawa.yoshiki" creationdate="20150414T133846Z">
        <seg>この関数は、情報を保持する関数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns a method that can be bound to a DOM element's event listener.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140211Z" creationid="shibukawa.yoshiki" creationdate="20150414T140211Z">
        <seg>この関数は、DOMエレメントのイベントリスナとして使えるメソッドを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a good idea to wrap exception-prone code in a try block and call m.endComputation from within the respective finally block, in order to prevent rendering from halting.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153521Z" creationid="shibukawa.yoshiki" creationdate="20150416T153521Z">
        <seg>例外が発生する可能性のあるコードをtryブロックで囲み、対応するm.endComputationをfinallyブロック内で呼ぶようにすると、再描画システムが停止することを防げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a good practice to always use the idiom above, instead of hardcoding ? or # in the href attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013514Z" creationid="shibukawa.yoshiki" creationdate="20150410T013514Z">
        <seg>href属性の中に?や#をハードコードするのではなく、常に上記のようなイディオムを使うのが良いプラクティスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a good practice to make components stateless because they are more predictable, and easier to reason about, test and troubleshoot.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080824Z" creationid="shibukawa.yoshiki" creationdate="20150502T080824Z">
        <seg>コンポーネントをステートレスにすると、挙動が予測しやすくなり、テストやトラブルシューティングがやりやすくなるため、良いプラクティスと言えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a modified version of the Thenable API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015847Z" creationid="shibukawa.yoshiki" creationdate="20150415T015847Z">
        <seg>これはthenable APIのカスタム版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also possible to modify the strategy that Mithril uses for any given redraw, by using m.redraw.strategy.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155613Z" creationid="shibukawa.yoshiki" creationdate="20150416T155613Z">
        <seg>m.redraw.strategyを使うと、任意で行う再描画の戦略を変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also possible to set values to Javascript-only properties, such as hash in a &lt;a&gt; element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T154808Z" creationid="shibukawa.yoshiki" creationdate="20150413T154808Z">
        <seg>&lt;a&gt;エレメントのhash属性のように、JavaScriptだけで使用できるプロパティの値も設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's automatically placed in the appropriate section of the request with the appropriate serialization based on method</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002503Z" creationid="shibukawa.yoshiki" creationdate="20150415T002503Z">
        <seg>設定されているmethodによって、適切な方法でシリアライズされて、適切なペイロードに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's of course possible to use both aggregation of responsibility and the observer pattern at the same time.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T030529Z" creationid="shibukawa.yoshiki" creationdate="20150502T030529Z">
        <seg>もちろん、責務の統合と、オブザーバパターンを同時に使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's often said that frameworks, in contrast to libraries, dictate how code should be written.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T112534Z" creationid="shibukawa.yoshiki" creationdate="20150417T142540Z">
        <seg>よく言われることは、ライブラリと異なり、フレームワークはどのようにコーディングをするかを指示してくるものであると言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's perfectly valid to define controllers and views separately, and only bring them together when mounting them:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071547Z" creationid="shibukawa.yoshiki" creationdate="20150502T071547Z">
        <seg>コントローラとビューを分割して定義しても問題ありません。マウントするときに統合することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to auto-cast a JSON response to a class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130512Z" creationid="shibukawa.yoshiki" creationdate="20150410T130512Z">
        <seg>JSON表現をクラスに自動変換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to defer a redraw by calling m.request or by manually nesting m.startComputation and m.endComputation contexts.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T185615Z" creationid="shibukawa.yoshiki" creationdate="20150411T185615Z">
        <seg>m.requestを呼び出したり、m.startComputationとm.endComputationのコンテキストをネストすることで、 再描画を遅らせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's possible to opt out of the redrawing schedule by using the background option for m.request, or by simply not calling m.startComputation / m.endComputation when calling non-Mithril asynchronous functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155241Z" creationid="shibukawa.yoshiki" creationdate="20150416T155143Z">
        <seg>m.requestのbackgroundオプションを使用したり、Mithril外の非同期関数を呼ぶ時は単にm.startComputation / m.endComputationの呼び出しをしなければ再描画のスケジューリングをやめ、再描画が積極的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's recommended that you encapsulate integration code in a component or a helper function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T013947Z" creationid="shibukawa.yoshiki" creationdate="20150412T013947Z">
        <seg>統合コードやヘルパー関数をコンポーネント内にカプセル化できるため、この方法が推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's recommended that you use the ctx.retain flag instead of changing the redraw strategy in controller constructors.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095840Z" creationid="shibukawa.yoshiki" creationdate="20150502T095840Z">
        <seg>再描画の戦略を変更する代わりに、ctx.retainフラグを使うのを推奨します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's relevant for comparison because it uses the same architecture as Mithril's templating engine: i.e. it acknowledges that DOM operations are the bottleneck of templating systems, and implements a virtual DOM tree which keeps track of changes and only applies diffs to the real DOM where needed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095952Z" creationid="shibukawa.yoshiki" creationdate="20150420T095952Z">
        <seg>ReactはMithrilと似たようなアーキテクチャを持っています。DOM操作がテンプレートシステムのボトルネックであるという考えを共有し、仮想DOMツリーを持って差分だけを実際のDOMに反映するという実装を持っています。この比較はしやすいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's strongly recommended that you set an initialValue option in ALL requests if you set the background option to true.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134351Z" creationid="shibukawa.yoshiki" creationdate="20150502T134351Z">
        <seg>backgroundをtrueに設定するリクエストの「全ての」リクエストに対してinitialValueオプションを設定するのを強く推奨します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's the only mode in which routing changes do not cause page refreshes in any browser.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005153Z" creationid="shibukawa.yoshiki" creationdate="20150410T005153Z">
        <seg>このモードは唯一、どのブラウザでもページリフレッシュが発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's worth mentioning that Mithril has built-in mechanisms elsewhere that take care of real bottlenecks like browser repaint management and DOM updating.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144619Z" creationid="shibukawa.yoshiki" creationdate="20150412T144619Z">
        <seg>Mithrilでは、ブラウザの再描画の管理やDOMの更新などの、本物のボトルネック以外をあまり気にする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's worth noting that the execution points listed above are commonly used for security attacks in combination with malformed markup, e.g. strings with mismatched attribute quotes like " onload="alert(1).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015120Z" creationid="shibukawa.yoshiki" creationdate="20150416T015120Z">
        <seg>このような実行ポイントを羅列することは、malformed(奇形)なタグと" onload="alert(1)のようなクオートが揃ってない属性文字列の組み合わせによる攻撃に対しては意味がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's your responsibility to make sure single iterations of animation rendering code don't take longer than 16ms (for a frequency of 60 frames-per-second).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020637Z" creationid="shibukawa.yoshiki" creationdate="20150421T020637Z">
        <seg>秒間60フレームを維持するために、この関数の単体の呼び出しのコストを16ミリ秒以下に抑えるのは開発者の責任です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its return value is used to diff against the previous virtual DOM tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T074544Z" creationid="shibukawa.yoshiki" creationdate="20150502T074544Z">
        <seg>この返り値は以前の仮想DOMのツリーに対する差分を検知するのに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its value can be set to either "search", "hash" or "pathname".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004833Z" creationid="shibukawa.yoshiki" creationdate="20150410T004833Z">
        <seg>このプロパティには、"search"、"hash"、"pathname"のいづれかの文字列を設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Jordan Humphreys created a gem to allow integration with Rails:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000054Z" creationid="shibukawa.yoshiki" creationdate="20150408T000054Z">
        <seg>Jordan Humphreysが、Railsと統合できるようにするgemを作成しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys are expected to be absolute pathnames, but can include dynamic parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T155928Z" creationid="shibukawa.yoshiki" creationdate="20150414T155928Z">
        <seg>キーは絶対パスを指定しますが、動的パラメータを含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys must be unique within a list of sibling DOM elements, and they must be either a string or a number:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080337Z" creationid="shibukawa.yoshiki" creationdate="20150502T080337Z">
        <seg>キーは兄弟のDOM要素の中でユニークである必要があります。キーの値は文字列でも数値でも大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Knockout is a library focused on data binding.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105414Z" creationid="shibukawa.yoshiki" creationdate="20150420T105414Z">
        <seg>Knockoutはデータバインディングにフォーカスしたライブラリです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lastly, be aware that if a user action triggers more than one event handler (for example, oninput and onkeypress, or an event bubbling up to event handlers in multiple ancestor elements), every event triggers a redraw by default.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151039Z" creationid="shibukawa.yoshiki" creationdate="20150416T151039Z">
        <seg>最後に、ユーザアクションがoninputとonkeypressなどの複数のイベントハンドラを起動したり、複数の祖先エレメントのイベントハンドラに対してバブリングした場合は、デフォルトではすべてのイベントが再描画を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Later in this guide, we'll pass the description property as the parameter to this function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163419Z" creationid="shibukawa.yoshiki" creationdate="20150407T163419Z">
        <seg>このガイドの後半では、descriptionプロパティをこの関数の引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Layered integration</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004902Z" creationid="shibukawa.yoshiki" creationdate="20150412T004844Z">
        <seg>階層に分けて統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Layered integration is recommended for modular code where many different APIs may be put together at the application level.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T005008Z" creationid="shibukawa.yoshiki" creationdate="20150412T005008Z">
        <seg>たくさんのさまざまなAPIがアプリケーションレベルで使われている時は、階層に分けて統合する方法がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Learn Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135632Z" creationid="shibukawa.yoshiki" creationdate="20150407T135632Z">
        <seg>Mithrilについて知る</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Learn More</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015637Z" creationid="shibukawa.yoshiki" creationdate="20150409T015637Z">
        <seg>より詳しく学ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Learn the ropes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135552Z" creationid="shibukawa.yoshiki" creationdate="20150407T135552Z">
        <seg>コツを覚えましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's create a component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040339Z" creationid="shibukawa.yoshiki" creationdate="20150502T040339Z">
        <seg>それではコンポーネントを作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's create a simple model entity which we'll use in a simple application, to illustrate different usage patterns for components:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T223633Z" creationid="shibukawa.yoshiki" creationdate="20150501T223633Z">
        <seg>まずはシンプルなモデルのエンティティを作ってみます。これはさまざまなコンポーネントの使用方法を説明するアプリケーションで使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's implement a data binding on the text input.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014731Z" creationid="shibukawa.yoshiki" creationdate="20150408T014731Z">
        <seg>次に、テキスト入力にデータバインディングを実装していきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Light-weight</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133256Z" creationid="shibukawa.yoshiki" creationdate="20150407T133256Z">
        <seg>軽量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, it intelligently waits for asynchronous services inside event handlers to complete before redrawing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161700Z" creationid="shibukawa.yoshiki" creationdate="20150408T161700Z">
        <seg>同様に、このシステムはイベントハンドラ内部の非同期サービスについても、再描画前にきちんと完了することを賢く待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Limitations and caveats</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050715Z" creationid="shibukawa.yoshiki" creationdate="20150502T050715Z">
        <seg>制限と制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Links to older versions can be found in the change log.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164634Z" creationid="shibukawa.yoshiki" creationdate="20150407T164634Z">
        <seg>変更履歴のページ内に、古いバージョンへのリンクがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loading</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135014Z" creationid="shibukawa.yoshiki" creationdate="20150407T135014Z">
        <seg>ロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mailing List</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135718Z" creationid="shibukawa.yoshiki" creationdate="20150407T135718Z">
        <seg>メーリングリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure to add null checks if your request value can be null</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134806Z" creationid="shibukawa.yoshiki" creationdate="20150502T134806Z">
        <seg>リクエスト値がnullになる可能性がある場合は、nullチェックを行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure to replace the project-name-goes-here and destination-folder-goes-here placeholders with appropriate values.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150801Z" creationid="shibukawa.yoshiki" creationdate="20150412T150713Z">
        <seg>サンプル中のプロジェクト名はこちらと、インストールフィルダはこちらは実際の設定と置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Manually throwing an instance of the Error class itself (or any other objects or primitives) does trigger the rejection callback path as per the Promises/A+ spec.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172438Z" creationid="shibukawa.yoshiki" creationdate="20150415T141210Z">
        <seg>Promises/A+の仕様通りであれば、例外クラスそのもののインスタンス、もしくは何らかのプリミティブなオブジェクトを手動で投げるとrejectionコールバックが呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method to use to deserialize the response data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013153Z" creationid="shibukawa.yoshiki" creationdate="20150415T013153Z">
        <seg>レスポンスデータをデシリアライズするメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method to use to extract the data from the raw XMLHttpRequest.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013314Z" creationid="shibukawa.yoshiki" creationdate="20150415T013314Z">
        <seg>XMLHttpRequest.からデータを取り出す時に使うメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method to use to serialize the request data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013102Z" creationid="shibukawa.yoshiki" creationdate="20150415T013102Z">
        <seg>リクエストデータをシリアライズするときに使用するメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Misc</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140947Z" creationid="shibukawa.yoshiki" creationdate="20150407T140947Z">
        <seg>その他</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril Template Compiler</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014148Z" creationid="shibukawa.yoshiki" creationdate="20150417T014148Z">
        <seg>Mithrilテンプレートコンパイラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril allows you to unwrap the relevant data, by providing two callback hooks: unwrapSuccess and unwrapError.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174329Z" creationid="shibukawa.yoshiki" creationdate="20150410T174329Z">
        <seg>MithrilはunwrapSuccess、unwrapErrorという2つのコールバックを提供しており、これらを使って、それぞれのデータをアンラアップすることが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril also does not auto-camel-case CSS properties on inline style attributes, so you should use the Javascript syntax when setting them via Javascript objects:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013653Z" creationid="shibukawa.yoshiki" creationdate="20150413T013653Z">
        <seg>Mithrilはまた、インラインのスタイル属性のCSSのプロパティ名を自動でcamel-caseに変換することはありません。そのため、JavaScriptのオブジェクトを経由してJavaScript文法を使って設定すべきです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril also has a dependency on XMLHttpRequest.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014921Z" creationid="shibukawa.yoshiki" creationdate="20150417T014921Z">
        <seg>MithrilはXMLHttpRequestにも依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril also provides several hooks to control its redrawing behavior with a deep level of granularity: m.startComputation and m.endComputation create redrawable contexts.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T191929Z" creationid="shibukawa.yoshiki" creationdate="20150411T191929Z">
        <seg>Mithrilはより深いレベルでエンジンの再描画の動作を制御できるように、いくつかのフックを提供しています。m.startComputationとm.endComputationは再描画のコンテキストを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril also uses certain methods on the DOM node object</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T162043Z" creationid="shibukawa.yoshiki" creationdate="20150416T162043Z">
        <seg>DOMノードオブジェクトの特定のメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril automatically figures out the correct XML namespaces when it sees an SVG island in the virtual DOM tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T140855Z" creationid="shibukawa.yoshiki" creationdate="20150413T140843Z">
        <seg>仮想のDOMツリーの中にSVGの要素が現れると、Mithrilは自動で正しいXML名前空間を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril controllers can be stripped down to a bare minimum, so that they only perform a single essential role: to expose a scoped set of model-level functionality.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T002426Z" creationid="shibukawa.yoshiki" creationdate="20150408T002426Z">
        <seg>Mithrilのコントローラは、モデルレベルの機能の中からいくつか限定したものだけを公開するという、最小限の機能にまで落とし込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril does not hook into the browser's onbeforeunload event.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092249Z" creationid="shibukawa.yoshiki" creationdate="20150502T092249Z">
        <seg>Mithrilはブラウザのonbeforeunloadイベントはフックしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril does not rely on unpolyfillable features, so developers can support browsers all the way back to IE6 and Blackberry by using shims if support for those older browsers is required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110248Z" creationid="shibukawa.yoshiki" creationdate="20150420T110248Z">
        <seg>MithrilはPolyfillで補完できない機能は使ってないので、もしIE6以降ののブラウザやBlackberryに対応させる必要があれば、足りない機能を補間して対応させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril employs a variety of mechanisms to decide the best time and the best strategy to redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184821Z" creationid="shibukawa.yoshiki" creationdate="20150411T184821Z">
        <seg>Mithrilは、再描画をいつどんな戦略で行うかを決定するメカニズムをいくつか提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril has an internal counter, which is incremented every time m.startComputation is called, and decremented every time m.endComputation is called.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154152Z" creationid="shibukawa.yoshiki" creationdate="20150416T154152Z">
        <seg>Mithrilは内部カウンタを持っています。このカウンタはm.startComputationが呼ばれるたびに増加し、m.endComputationが呼ばれると減少します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril has more documentation in its Github repo than source code, and none of the documentation is auto-generated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114341Z" creationid="shibukawa.yoshiki" creationdate="20150417T114341Z">
        <seg>Mithrilは、github上で見ても、ソースコードそのものよりもドキュメントの方が大量にあります。また、自動生成のドキュメントはひとつもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is a client-side Javascript MVC framework, i.e. it's a tool to make application code divided into a data layer (called Model), a UI layer (called View), and a glue layer (called Controller)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T110641Z" creationid="shibukawa.yoshiki" creationdate="20150407T141220Z">
        <seg>MithrilはクライアントサイドのJavaScript MVCフレームワークです。このツールを使うと、アプリケーションのコードはデータレイヤ(Model)、UIレイヤー(View)、接続レイヤー(Controller)に分割されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is a client-side MVC framework - a tool to organize code in a way that is easy to think about and to maintain.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133223Z" creationid="shibukawa.yoshiki" creationdate="20150407T133223Z">
        <seg>MithrilはクライアントサイドMVCフレームワークです。コードをきれいに構成して、構造について考えるのを簡単にしたり、メンテナンスしやすくします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is around 12kb gzipped thanks to its small, focused, API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T110536Z" creationid="shibukawa.yoshiki" creationdate="20150506T110536Z">
        <seg>小さく、ムダのないAPIのおかげで、Mithrilはgzipされた状態でたったの12kbしかありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is available from a variety of sources:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164441Z" creationid="shibukawa.yoshiki" creationdate="20150407T164441Z">
        <seg>Mithrilはさまざまなインストール手段を提供しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril is designed around the principle that data always flows from the model to the view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183448Z" creationid="shibukawa.yoshiki" creationdate="20150411T183448Z">
        <seg>Mithrilは、データは常にモデルからビューに流れる、という原則のもとに設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril promises are also getter-setter functions, which are populated with the resolved value if the promise is fulfilled successfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135338Z" creationid="shibukawa.yoshiki" creationdate="20150414T135338Z">
        <seg>Mithrilのpromiseもまたgetter-setter関数で、promiseが果たされると、解決された値が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril promises attempt to execute synchronously if possible.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140220Z" creationid="shibukawa.yoshiki" creationdate="20150415T140220Z">
        <seg>可能であればMithrilのpromiseは同期実行しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril provides a few more facilities that are not demonstrated in this page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015709Z" creationid="shibukawa.yoshiki" creationdate="20150409T015709Z">
        <seg>Mithrilには、このページ内で紹介しきれなかった機能がまだいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril provides a high-level utility for working with web services, which allows writing asynchronous code relatively procedurally.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014041Z" creationid="shibukawa.yoshiki" creationdate="20150410T014041Z">
        <seg>Mithrilは、ウェブサービスと協調するための高度なユーティリティを提供しています。この機能を使うと、非同期で動作するコードを、比較的手続き的に記述することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril provides utilities to handle three different aspect of routing:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162147Z" creationid="shibukawa.yoshiki" creationdate="20150409T162147Z">
        <seg>Mithrilは、ラウティングに関して、3種類の異なるサポートを提供します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril relies on some ECMAScript 5 features, namely: Array::indexOf, Array::map and Object::keys, as well as the JSON object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014511Z" creationid="shibukawa.yoshiki" creationdate="20150417T014511Z">
        <seg>MithrilはArray::indexOf、Array::map、Object::keys、JSONオブジェクトなどのECMAScript 5の機能を使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril takes some learnings from that and implements a templating redrawing system that renders less aggressively, is less complex and is easier to profile.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094919Z" creationid="shibukawa.yoshiki" creationdate="20150420T094919Z">
        <seg>MithrilはAngularからの学びにより、控えめな実装で複雑さを下げ、プロファイリングしやすい実装にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril templates are also more collision-proof than other component systems since there's no way to pollute the HTML tag namespace by defining ad-hoc tag names.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015301Z" creationid="shibukawa.yoshiki" creationdate="20150409T015301Z">
        <seg>Mithrilのテンプレートは他のコンポーネントシステムよりも衝突に対して安全です。アドホックにタグ名を決定してHTMLタグの名前空間を汚すことができないようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril templates are defended against these attacks by default, except when markup is injected via m.trust.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015237Z" creationid="shibukawa.yoshiki" creationdate="20150416T015237Z">
        <seg>Mithrilのテンプレートは、m.trustでマークアップを挿入するのを除けば、デフォルトではこのような攻撃を防ぐことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril templates are safe by default, i.e. you can't unintentionally create security holes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T161828Z" creationid="shibukawa.yoshiki" creationdate="20150407T135140Z">
        <seg>Mithrilのテンプレートはデフォルトで安全な動作をするようになっています。無理やり作ろうとしなければセキュリティホールを作ることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril thennables take two functions as optional parameters: the first parameter is called if the web service request completes successfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124829Z" creationid="shibukawa.yoshiki" creationdate="20150410T124829Z">
        <seg>Mithrilのthennableは、2つのオプションのパラメータを持っています。最初のパラメータはウェブサービスへのリクエストが問題なく完了した時に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril updates the native location object after rendering in order to allow the browser's history.pushState API to correctly show descriptive history entries (e.g. for Chrome's Ctrl+H page).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171822Z" creationid="shibukawa.yoshiki" creationdate="20150414T171822Z">
        <seg>Mithrilはレンダリングの後に、ネイティブのlocationを更新して、history.pushState APIが正しい履歴のエントリーが表示されるようにします(Chromeの場合はCtrl+H page)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril uses certain window methods that will need to be made available for complete test coverage, depending on your application:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161926Z" creationid="shibukawa.yoshiki" creationdate="20150416T161926Z">
        <seg>Mithrilは完全なテストのカバレッジを得たり、アプリケーションの機能の実現のために、特定のwindowのメソッドを呼んでいます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril uses them in other interesting ways elsewhere.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152259Z" creationid="shibukawa.yoshiki" creationdate="20150408T152248Z">
        <seg>Mithrilは、これ以外のさまざまなところでも、これらのテクニックを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril views can provide accurate and informative error reporting, with line numbers and meaningful stack traces.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013929Z" creationid="shibukawa.yoshiki" creationdate="20150409T013929Z">
        <seg>また、Mithrilのビューは、行番号と分かりやすいスタックトレース付きの正確で意味のあるエラーを出力できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's auto-redrawing system keeps track of controller stability, and only redraws the view once it detects that the controller has finished running all of its code, including asynchronous AJAX payloads.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161344Z" creationid="shibukawa.yoshiki" creationdate="20150408T161344Z">
        <seg>Mithrilの自動再描画システムはコントローラの安定性を崩しません。ビューの再描画はコントローラの処理がすべて終わったにのみ行われます。このコントローラの処理には、AJAXによるデータのロードも含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's design strongly encourages all entity logic to be handled in atomic model layer methods (in the sense of entity state stability).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032116Z" creationid="shibukawa.yoshiki" creationdate="20150421T014353Z">
        <seg>Mithrilの設計としては、エンティティの状態の安定性を鑑みて、エンティティのロジックはモデルレイヤーのアトミックなメソッドで行うことを推奨しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's diffing algorithm makes sure expensive DOM operations are performed only if absolutely necessary, and as an extra benefit, the global nature of the redraw makes it easy to reason about and troubleshoot the state of the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T074956Z" creationid="shibukawa.yoshiki" creationdate="20150502T074956Z">
        <seg>Mithrilは差分検知アルゴリズムを利用することで、高コストなDOM操作を本当に必要な箇所だけ実行することができます。また、全体を再描画するという仕組み上、アプリケーションの状態がビューとモデルの2つに存在するのではなく、モデルの状態によってのみ管理されるため、トラブルシューティングが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's on-demand tooling approach means there are no hidden performance costs when implementing core MVC patterns, and there's also no extra learning curve for framework-specific syntax for those patterns.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T145613Z" creationid="shibukawa.yoshiki" creationdate="20150417T145404Z">
        <seg>Mithrilの必要な時に必要なツールだけを提供するアプローチでは、コアのMVCパターンを実装するときに、隠れたパフォーマンスのコストを負わされることはありません。また、フレームワークに対して、特定のパターンに対する特殊なシンタックスを覚えさせるような無用なラーニングカーブはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril's view layer paradigm is designed be declarative, much like HTML, such that the same code implicitly does everything it needs to.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014616Z" creationid="shibukawa.yoshiki" creationdate="20150420T014616Z">
        <seg>Mithrilのビューレイヤーは宣言的なコードになるように設計されていて、よりHTMLに近くなっています。表示するコードを書くだけですべて完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril, on the other hand, purposely avoids the observer pattern in an attempt to abolish "come-from hell", a class of debugging problems where you don't know what triggers some code because of a long chain of events triggering other events.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T021100Z" creationid="shibukawa.yoshiki" creationdate="20150420T020944Z">
        <seg>Mithrilはこれとは対照的に、「どこから来たのか分からない」といった種類の問題を避けるために、オブザーバパターンをなるべく避ける実装になっています。イベントからイベントへ、長いチェーンになっていると、何がコードを起動しているトリガーになっているのか理解が難しくなることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mithril, on the other hand, tries to provide only features that support a more classic MVC paradigm.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095131Z" creationid="shibukawa.yoshiki" creationdate="20150420T095131Z">
        <seg>Mithrilはそれとは対照的に、よりクラシックなMVCをサポートするのに必要な機能だけを備えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mode abstraction</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013122Z" creationid="shibukawa.yoshiki" creationdate="20150410T013122Z">
        <seg>モードの抽象化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Model</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T144138Z" creationid="shibukawa.yoshiki" creationdate="20150407T144138Z">
        <seg>モデル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Models are also responsible for centralizing tasks such as filtering of entity lists and validation routines, so that access to these methods is available across the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033522Z" creationid="shibukawa.yoshiki" creationdate="20150421T033411Z">
        <seg>エンティティのリストのフィルタリングや、バリデーションもモデルの責務になります。モデルに定義することで、アプリケーション全体でこれらのメソッドが利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More documentation on the grunt-sweet.js task and its options can be found here</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150911Z" creationid="shibukawa.yoshiki" creationdate="20150412T150911Z">
        <seg>grunt-sweet.jsタスクと、オプションについては、こちら見ることがｄけいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most frameworks redraw aggressively and err on the side of redrawing too many times because, as it turns out, determining the best time to do a redraw is quite complicated if we want to be as efficient as possible.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184717Z" creationid="shibukawa.yoshiki" creationdate="20150411T184717Z">
        <seg>ほとんどのフレームワークでは、再描画を積極的に行いますが、やりすぎてしまうという間違いをおかしています。というのも、なるべく効率よくやろうとすると、再描画を行うベストなタイミングを決定するのはとても難しい問題だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the popular frameworks have at least a bare minimum amount of documentation nowadays, but many leave a bit to be desired: some lack usage examples, and some frameworks' communities need to rely heavily on third party sites for explanations of more advanced topics, and sometimes even for learning the basics.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114143Z" creationid="shibukawa.yoshiki" creationdate="20150417T114143Z">
        <seg>人気のフレームワークのほとんどは、最低限のドキュメントしか提供していませんが、多くの人は便利なサンプルが欠けていると感じていたり、上級のトピックは外部の情報まかせになっていたり、場合によっては基本的な情報すら外部の方が詳しかったりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mounting is the process of rendering a component into a DOM element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125046Z" creationid="shibukawa.yoshiki" creationdate="20150502T125046Z">
        <seg>マウントは、コンポーネントをDOMエレメントにレンダリングするプロセスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Must be either "GET", "POST", "PUT", "DELETE", "HEAD" or "OPTIONS"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002151Z" creationid="shibukawa.yoshiki" creationdate="20150415T002151Z">
        <seg>このオプションは、"GET"、"POST"、"PUT"、"DELETE"、"HEAD"、"OPTIONS"のどれかを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Must be the string "jsonp"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014512Z" creationid="shibukawa.yoshiki" creationdate="20150415T014512Z">
        <seg>"jsonp"でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NPM is the default package manager for NodeJS.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165756Z" creationid="shibukawa.yoshiki" creationdate="20150407T165756Z">
        <seg>NPMはNodeJS標準のパッケージマネージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither of these trade-offs are acceptable, given Mithril's focus on nimbleness and performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140945Z" creationid="shibukawa.yoshiki" creationdate="20150415T140945Z">
        <seg>Mithrilは敏捷性とパフォーマンスにフォーカスしているため、これらのトレードオフを受け入れることはできませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested asynchronous components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050651Z" creationid="shibukawa.yoshiki" creationdate="20150502T050651Z">
        <seg>非同期のネストされたコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested component views must return either a virtual element or another component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095635Z" creationid="shibukawa.yoshiki" creationdate="20150502T095635Z">
        <seg>ネストされたコンポーネントのビューは、仮想エレメントか他のコンポーネントを返さなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested components cannot change m.redraw.strategy from the controller constructor (but they can from event handlers).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095755Z" creationid="shibukawa.yoshiki" creationdate="20150502T095755Z">
        <seg>ネストされたコンポーネントはコントローラのコンストラクタからm.redraw.strategyを変更することはできません。ただしイベントハンドラからなら行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nesting components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050545Z" creationid="shibukawa.yoshiki" creationdate="20150502T050545Z">
        <seg>コンポーネントのネスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No flash-of-unbehaviored-content (FOUC).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013414Z" creationid="shibukawa.yoshiki" creationdate="20150409T013414Z">
        <seg>コンテンツが設定されていない内容が一瞬表示されていまう(flash-of-unbehaviored-content :FOUC)のを防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, calling m.mount will return the controller instance for that component, but there's one corner case: if e.preventDefault() is called from a controller's onunload method, then the m.mount call will not instantiate the new controller, and will return undefined.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092155Z" creationid="shibukawa.yoshiki" creationdate="20150502T092155Z">
        <seg>通常、m.mount呼び出しはコントローラのインスタンスを返します。しかし、コントローラのonunload内で、e.preventDefault()が呼ばれると、m.mountは新しいコントローラのインスタンスの生成をやめ、undefinedが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, you should only do this if you need to synchronously read a value from the DOM that requires a browser repaint (e.g. offsetTop or a CSS rule).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151551Z" creationid="shibukawa.yoshiki" creationdate="20150416T151551Z">
        <seg>通常は、offsetTopやCSSルールなど、ブラウザの再描画を必要とする、DOMの同期的な値読み込みが必要になった時だけにすべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not using keys still works in some cases, but might trigger more expensive code paths within the redrawing algorithm.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T021156Z" creationid="shibukawa.yoshiki" creationdate="20150421T021156Z">
        <seg>キーを使用しなくても期待通りの動作をすることがありますが、再描画のアルゴリズムの効率が下がってコストが高くなる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that, despite having a bigger scope, Mithril has a smaller file size than React.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105402Z" creationid="shibukawa.yoshiki" creationdate="20150420T105402Z">
        <seg>また、そのように広い範囲をスコープに入れているにもかかわらず、MithrilのファイルサイズはReactよりも小さくなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that m.render is a very low level method in Mithril that draws only once and doesn't attempt to run the auto-redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014121Z" creationid="shibukawa.yoshiki" creationdate="20150408T014121Z">
        <seg>m.renderはMithrilの提供する中で、とても低レベルなメソッドで、1回だけ描画するために使います。自動再描画システムを利用する場合は使用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Mithril always considers the model layer data to be canonical.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015108Z" creationid="shibukawa.yoshiki" creationdate="20150413T015108Z">
        <seg>Mithrilは、常にモデルレイヤのデータが正当なものであると判断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Mithril checks for route matches in the order the routes are defined, so you should put variadic routes at the bottom of the list to prevent them from matching other more specific routes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T154059Z" creationid="shibukawa.yoshiki" creationdate="20150414T154059Z">
        <seg>Mithrilはラウトのマッチを定義された順番に行っていきます。そのため、可変個の引数を持つラウトは末尾に書かないと、より範囲の狭いラウトのマッチが行われなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Mithril does not prescribe how the binding updates: you can bind it to onchange, onkeypress, oninput, onblur or any other event that you prefer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021740Z" creationid="shibukawa.yoshiki" creationdate="20150408T021740Z">
        <seg>Mithrilはどのイベントを監視して更新を受け取るかはユーザに任せています。onchange、onkeypress、oninput、onblurなど、好きなイベントを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Mithril only uses the mock object for browser APIs such as the DOM API and requestAnimationFrame, but relies on the environment for ECMAScript features like Object.keys.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161305Z" creationid="shibukawa.yoshiki" creationdate="20150416T161305Z">
        <seg>MithrilはDOM APIやrequestAnimationFrameなどのブラウザAPIのためにのみモックオブジェクトを使いますが、Object.keysなどのECMAScript環境にも依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Mithril promises are not automatically integrated to its automatic redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134929Z" creationid="shibukawa.yoshiki" creationdate="20150415T134929Z">
        <seg>Mithrilのプロミスは自動的に自動再描画システムと統合されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that browsers ignore &lt;script&gt; tags that have been inserted into the DOM via innerHTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014130Z" creationid="shibukawa.yoshiki" creationdate="20150416T014130Z">
        <seg>ブラウザは、innerHTML経由でDOMに挿入された&lt;script&gt;タグは無視します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that changing the redraw strategy only affects the next scheduled redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155643Z" creationid="shibukawa.yoshiki" creationdate="20150416T155643Z">
        <seg>再描画戦略の変更は次に計画されている再描画にのみ影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that compiled templates are meant to be generated by an automated build process and are not meant to be human editable.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T145920Z" creationid="shibukawa.yoshiki" creationdate="20150412T145845Z">
        <seg>このコンパイル済みのテンプレートは自動ビルドプロセスの結果作られたものであって、人間がこのように書くべきという意味ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that even if you set context.retain = true, the element will still be destroyed and recreated if it is different enough from the existing element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135305Z" creationid="shibukawa.yoshiki" creationdate="20150413T135305Z">
        <seg>context.retain = trueを設定しても、既存のエレメントと大きく異る場合はエレメントは破壊されて再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that failing to call endComputation after a respective startComputation call will halt the redrawing system.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153317Z" creationid="shibukawa.yoshiki" creationdate="20150416T153317Z">
        <seg>startComputationを呼んだ後に、対になるendComputation呼び出しをすると、再描画システム全体が動作しなくなるので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if the same attribute is defined in the both selector and attributes parameters, the value in attributes is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150803Z" creationid="shibukawa.yoshiki" creationdate="20150413T150803Z">
        <seg>もしselectorとattributesパラメータで同じ属性が定義されると、attributesが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you're changing this configuration value, you should change it before calling m.route.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165746Z" creationid="shibukawa.yoshiki" creationdate="20150414T165746Z">
        <seg>この設定を変更する場合には、m.routeを呼び出す前に行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in addition to the presence of the key attribute, diffing rules also apply in determining whether an element is recreated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144045Z" creationid="shibukawa.yoshiki" creationdate="20150413T144045Z">
        <seg>key属性があるかどうかに加えて、差分検知のルールもエレメントの再生成を行うかどうかの判定に使用される点は注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in order to keep the framework lean, Mithril does not auto-append units like px or % to any values.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013231Z" creationid="shibukawa.yoshiki" creationdate="20150413T013231Z">
        <seg>フレームワークは必要最低限の動作をするように設計されているため、どの属性名にも、px、%といった単位を付けることはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in order to support older versions of IE, you need to include some shims.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165104Z" creationid="shibukawa.yoshiki" creationdate="20150407T165019Z">
        <seg>古いバージョンのIEをサポートする場合は、互換性を向上させるライブラリをいくつか読み込む必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in order to use the pathname mode, the application must be run from the root URL.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170245Z" creationid="shibukawa.yoshiki" creationdate="20150414T170245Z">
        <seg>pathnameモードを使う場合は、アプリケーションがルートのURLで実行するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that modifying the values of m.prop getter-setters does not trigger redrawing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133945Z" creationid="shibukawa.yoshiki" creationdate="20150414T133945Z">
        <seg>m.propgetter-setterの値を変更しても、再描画が起動されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the Todo and TodoList classes we defined above are plain vanilla Javascript constructors.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150749Z" creationid="shibukawa.yoshiki" creationdate="20150407T150749Z">
        <seg>上記のサンプルで定義したTodoクラスとTodoListクラスは、混じりけのない、プレーンなJavaScriptのコンストラクタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the URL component used to resolve routes is dependent on m.route.mode.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165413Z" creationid="shibukawa.yoshiki" creationdate="20150414T165413Z">
        <seg>ラウトの解決に使うURLの部位は、m.route.modeによって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the default promise exception handling semantics can be modified.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173452Z" creationid="shibukawa.yoshiki" creationdate="20150415T173452Z">
        <seg>このように、デフォルトの例外処理のセマンティクスが変更されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the example above only sets the value of the input element in the DOM, but it never reads it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015822Z" creationid="shibukawa.yoshiki" creationdate="20150408T015822Z">
        <seg>このコードでは、DOMのテキスト入力エレメントの値に設定するだけで、読み込みは行わないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the output value from m() is not an actual DOM element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000134Z" creationid="shibukawa.yoshiki" creationdate="20150413T000134Z">
        <seg>m()関数が返す値は、実際のDOM要素ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the redraw strategy is a global setting that affects the entire template trees of all components on the page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130853Z" creationid="shibukawa.yoshiki" creationdate="20150502T130853Z">
        <seg>再描画の戦略は、ページ内の全コンポーネントのテンプレートツリーに影響を与えるグローバルな設定であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the sample component above is illustrative.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T082005Z" creationid="shibukawa.yoshiki" creationdate="20150502T081714Z">
        <seg>上記のサンプルは実際には役に立ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that there is no requirement to tightly couple a controller and view while organizing code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071455Z" creationid="shibukawa.yoshiki" creationdate="20150502T071455Z">
        <seg>このコードを組み立てるときに、コントローラとビューを密結合させる必要がない点がポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this getter-setter holds an undefined value until the AJAX request completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015221Z" creationid="shibukawa.yoshiki" creationdate="20150410T015221Z">
        <seg>getter-setterは、AJAXリクエストが完了するまではundefined値を返すことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that to redirect to a different page outside of the scope of Mithril's routing, you should use window.location</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171505Z" creationid="shibukawa.yoshiki" creationdate="20150414T171505Z">
        <seg>もし、Mithrilのラウティングで取り扱っている範囲外のページにリダイレクトする場合は、window.locationを使うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that using this feature is discouraged if you don't have visible performance problems.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123949Z" creationid="shibukawa.yoshiki" creationdate="20150416T123949Z">
        <seg>もし、ビューに関するパフォーマンス上の問題が何もなければ、この機能は使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when we construct the parameterized binding, we are passing the description getter-setter by reference, and not its value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151707Z" creationid="shibukawa.yoshiki" creationdate="20150408T151707Z">
        <seg>パラメータを束縛するときに、上記の例ではdescription getter-setterを参照で渡していて、直接値を渡しているわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that while a small gzipped size can look appealing, that number is often used to "hide the weight" of the uncompressed code: remember that the decompressed Javascript still needs to be parsed and evaluated on every page load, and this cost (which can be in the dozens of milliseconds range for some frameworks in some browsers) cannot be cached.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113412Z" creationid="shibukawa.yoshiki" creationdate="20150417T021951Z">
        <seg>gzipされたコードが小さいのがアピールポイントというのは、非圧縮時にとても大きくなることを隠しているように見えるかもしれません。非圧縮のJavaScriptはページロードのたびにパースと評価が行われます。いくつかのフレームワークでは環境によっては数10msにもなりますが、このコストはキャッシュできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you can use JSON syntax if the attribute name you are setting has non-alphanumeric characters:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013102Z" creationid="shibukawa.yoshiki" creationdate="20150413T013102Z">
        <seg>アルファベットと数値以外の文字列を持つ属性名を設定したいときは、JSON文法を使うことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you can use both Javascript property names and HTML attribute names to set values in the attributes argument, but you should pass a value of appropriate type.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T003008Z" creationid="shibukawa.yoshiki" creationdate="20150413T003008Z">
        <seg>attributes引数の中では、JavaScriptのプロパティ名とHTML属性名の両方を使って設定できますが、適切な型を使って渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, unlike many templating engines, this "smart diff" feature does not affect things like cursor placement in inputs and focus, and is therefore safe to call during user interactions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T020220Z" creationid="shibukawa.yoshiki" creationdate="20150416T020220Z">
        <seg>他のテンプレートエンジンとは異なり、この「賢い差分」機能は、入力フォームのカーソルやフォーカスに対して影響を与えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that since the code above is not valid Javascript, this syntax can only be used with a preprocessor build tool such as the provided Gulp.js script.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014025Z" creationid="shibukawa.yoshiki" creationdate="20150417T014025Z">
        <seg>上記のコードはJavaScriptとして正しい文法ではありませんが、このコードはGulp.jsなどで提供されているプリプロセッサのビルドツールから読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notes on Architecture</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163521Z" creationid="shibukawa.yoshiki" creationdate="20150408T163521Z">
        <seg>アーキテクチャに関するメモ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notes on the view function</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045959Z" creationid="shibukawa.yoshiki" creationdate="20150502T045959Z">
        <seg>view関数に関するメモ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how doBoth repeatedly calls m.startComputation since that method calls both doSomething and doAnother.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T005325Z" creationid="shibukawa.yoshiki" creationdate="20150412T005325Z">
        <seg>doBothはdoSomethingとdoAnotherから呼び出されるため、m.startComputationを何度も呼んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that now each component is self-contained: each has a separate route, and each component does exactly one thing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T014332Z" creationid="shibukawa.yoshiki" creationdate="20150502T014332Z">
        <seg>これらのコンポーネントは機能別にまとまっています。それぞれ異なったラウターを持ち、それぞれのコンポーネントは1つのタスクだけを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the ContactList does not care about whether args.contacts refers to all the contacts in the database, or just contacts that match some criteria.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T005556Z" creationid="shibukawa.yoshiki" creationdate="20150502T005556Z">
        <seg>ContactListリストはargs.contactsがデータベース内のすべての連絡先を参照しているか、フィルタリング条件でヒットしたものだけが渡されているのかどうかは知りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that we pass a root DOM element to attach our template to, as well as the template itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013700Z" creationid="shibukawa.yoshiki" creationdate="20150408T013700Z">
        <seg>renderメソッドを呼び出す時は、テンプレートそのものに加えて、ルートのDOM要素を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, web services return the relevant data wrapped in objects that contain metadata.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174025Z" creationid="shibukawa.yoshiki" creationdate="20150410T174025Z">
        <seg>少なくない数のウェブサービスが、それぞれのデータをメタデータ入りのオブジェクトでラップして返してきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, you will want to do some work before the component is unloaded (i.e. clear timers or unsubscribe event handlers):</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091614Z" creationid="shibukawa.yoshiki" creationdate="20150502T091614Z">
        <seg>コンポーネントをアンロードする前にタイマーをクリアしたり、イベントハンドラを削除したり、何か仕事をしたくなることがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the one hand, it's extremely easy to reason about the behavior of the components since they only serve a single purpose, but on the other hand they don't have the flexibility that the previous example did (e.g. in this iteration, ContactList can only list all of the contacts in the database, not an arbitrary subset.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015307Z" creationid="shibukawa.yoshiki" creationdate="20150502T015307Z">
        <seg>それぞれのコンポーネントは個別の目的のために提供されているため、動作を理解するのは簡単ですが、前述のサンプルのような柔軟性はありません。ContactListは全連絡先のリストを表示するのにしか使えず、サブセットの表示はできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if you were to call a web service using jQuery, then you would be responsible for adding a m.startComputation call before the jQuery ajax call, and for adding a m.endComputation call at the end of the completion callback, in addition to the calls within the change event handler.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134953Z" creationid="shibukawa.yoshiki" creationdate="20150412T134826Z">
        <seg>そうではなくjQueryを使ってウェブサービス呼び出しをしているのであれば、changeイベントハンドラ内にこの関数のペアを置く以外に、jQueryのajax呼び出しの前にm.startComputationを追加し、コールバックが完了した後にm.endComputation呼び出しを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, javascript developers rarely ever throw errors that are subclasses of Error, and for the purposes of application error handling, the underlying prototypal chain of the error class is typically not relevant.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174723Z" creationid="shibukawa.yoshiki" creationdate="20150415T174723Z">
        <seg>言い換えると、JavaScript開発者は例外に関して、アプリケーションのエラーハンドリングを目的としてErrorのサブクラスを作って投げることはほとんどありません。Errorのプロトタイプチェーンを気にすることはほとんどありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once each request completes, the counter is decremented.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154500Z" creationid="shibukawa.yoshiki" creationdate="20150416T154500Z">
        <seg>リクエストが完了するたびにカウンタが減少します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once installed, create two files in the root of your project, package.json and Gruntfile.js</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150546Z" creationid="shibukawa.yoshiki" creationdate="20150412T150546Z">
        <seg>インストールしたら、プロジェクトのルートにpackage.jsonとGruntfile.jsの2つのファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once resolved, the placeholder is replaced with component B's view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094557Z" creationid="shibukawa.yoshiki" creationdate="20150502T094557Z">
        <seg>非同期処理が完了すると、プレースホルダは実際のコンポーネントBのビューに置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once that counter reaches zero, Mithril redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190035Z" creationid="shibukawa.yoshiki" creationdate="20150411T190035Z">
        <seg>カウンタがゼロになるとMithrilは再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the controller code finishes executing (and this may include waiting for AJAX requests to complete), the view class is instantiated, and the instance of the controller is passed as an argument to the view's constructor.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T021045Z" creationid="shibukawa.yoshiki" creationdate="20150414T021045Z">
        <seg>コントローラコードの実行が完了すると(AJAXのリクエストの完了待ちも含む)ビュークラスのインスタンスが作られ、ビューのコンストラクタにコントローラのインスタンスが渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the counter reaches zero, Mithril redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154159Z" creationid="shibukawa.yoshiki" creationdate="20150416T154159Z">
        <seg>カウンタがゼロになるとMithrilは再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you have a copy of Mithril, getting started is surprisingly boilerplate-free:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142648Z" creationid="shibukawa.yoshiki" creationdate="20150407T142648Z">
        <seg>Mithrilのインストールをしたらコーディングを開始しましょう。Mithrilは、決まり文句がとても少ない、小さなHTMLから開始することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One caveat of using the CSS syntax is that it clobbers the style attribute in the DOM element on redraws, so this syntax is not appropriate if you need to use it in conjunction with 3rd party tools that modify the element's style outside of Mithril's templates (e.g. via config, which is explained below)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014630Z" creationid="shibukawa.yoshiki" creationdate="20150413T014630Z">
        <seg>注意点としては、CSS文法を使うとDOM要素の再描画の時にstyle属性が強制的にテンプレートで設定されたスタイルに上書きされます。そのため、Mithrilのテンプレートの外からスタイルを変更するようなサードパーティ製ツールを使用する必要があるときは、CSS文法を避けてください。この後のconfigの項目で詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One common way of using config is in conjunction with m.route, which is an unobtrusive extension to links that allow Mithril's routing system to work transparently regardless of which routing mode is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124149Z" creationid="shibukawa.yoshiki" creationdate="20150413T123936Z">
        <seg>設定configの一般的な使用法の１つに、m.routeと一緒に使用して、設定されているラウティングモードにかかわらず、透過的に動作するようにリンクを拡張するというものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One extremely important aspect of this architecture is that since components encapsulate their internal state, then by definition it's harder to reason about AJAX request redundancy (i.e. how to prevent two identical AJAX requests originating from two different components).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021953Z" creationid="shibukawa.yoshiki" creationdate="20150502T021953Z">
        <seg>このアーキテクチャの注意点としては、コンポーネントが内部状態をカプセル化しているため、AJAXアクセスが冗長になってしまうのを防ぐのが難しいということがあります。異なるコンポーネントがまったく同じAJAXアクセスを行うのを防ぐ方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One important limitation to be aware of when using components is that you cannot call Mithril's redrawing methods (m.startComputation / m.endComputation and m.redraw) from templates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094813Z" creationid="shibukawa.yoshiki" creationdate="20150502T094813Z">
        <seg>一番重要な制限は、テンプレートの中からMithrilの再描画メソッド(m.startComputation / m.endComputation / m.redraw)を呼び出すことができないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One important note about the config method is that you should avoid calling m.redraw, m.startComputation and m.endComputation in the config function's execution thread.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135443Z" creationid="shibukawa.yoshiki" creationdate="20150412T135443Z">
        <seg>configメソッドについて注意すべきことは、config関数の実行スレッド内では、m.redraw、m.startComputation、m.endComputationを呼び出さないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of its selling points is that it allows developers to leverage their existing jQuery knowledge, while providing some "walls" to organize the code in a more structured manner.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020006Z" creationid="shibukawa.yoshiki" creationdate="20150420T020006Z">
        <seg>開発者に対するBackboneのセールスポイントの1つは、既存のjQueryの知識を活かした上で、コードをきちんと構造化するための「ついたて」を提供するというものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One other difference that is extremely clear is the treatment of data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015651Z" creationid="shibukawa.yoshiki" creationdate="20150420T015651Z">
        <seg>他に大きく異る点は、データの取り扱いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One related difference is that other frameworks often have hard-coded base classes where every conceivable convenience method gets inherited by the developer's classes (remember, in Javascript, this can mean copying all of the utility methods over to the child class, regardless of whether they're going to be used or not).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T145321Z" creationid="shibukawa.yoshiki" creationdate="20150417T145321Z">
        <seg>これに関連する他のフレームワークとの違いとして、これらのフレームワークはよく、考えつく限りの便利なメソッドが満載になったフレームワーク固有のベースクラスを提供していて、開発者のクラスにこれを継承させます。実際に使うかどうかにかかわらず、JavaScriptではこれらのユーティリティメソッドもすべて子クラスにコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One technical aspect that is also different is that Backbone is heavily event-oriented.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020723Z" creationid="shibukawa.yoshiki" creationdate="20150420T020719Z">
        <seg>技術的な側面での大きな違いは、Backboneがイベント駆動に重きをおいている点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One thing you may have noticed on the Mithril homepage is that, out of the box, Angular is not as performant as other frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094331Z" creationid="shibukawa.yoshiki" creationdate="20150420T094331Z">
        <seg>もう1点、Mithrilホームページを見て分かるように、Angularは他のフレームワークよりもパフォーマンスで引けを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One typical way to override this is to receive as-is responses.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T175213Z" creationid="shibukawa.yoshiki" creationdate="20150410T175213Z">
        <seg>よくある変更方法としては、変換せずに帰ってきた入力をそのままアプリケーションに渡す方式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way of organizing components is to use component parameter lists to send data downstream, and to define events to bubble data back upstream to a centralized module who is responsible for interfacing with the model layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T000307Z" creationid="shibukawa.yoshiki" creationdate="20150502T000307Z">
        <seg>コンポーネントの組み立て方の１つの例としては、コンポーネントのパラメータリストを使ってデータを下流に流すと共に、モデルレイヤとのインタフェースとなっている中心のモジュールまでバブリングしてデータを上流に戻すイベントを定義するというものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only 12kb gzipped, no dependencies</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150730T225644Z" creationid="shibukawa.yoshiki" creationdate="20150730T225636Z">
        <seg>gzip圧縮時にたったの12KBで、他への依存がない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only tag, id, class and attribute selectors are supported.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150610Z" creationid="shibukawa.yoshiki" creationdate="20150413T150610Z">
        <seg>タグ、ID、クラス、属性セレクタのみがサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optimizing Performance</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141712Z" creationid="shibukawa.yoshiki" creationdate="20150412T141712Z">
        <seg>パフォーマンスの最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optimizing Performance - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141653Z" creationid="shibukawa.yoshiki" creationdate="20150412T141653Z">
        <seg>パフォーマンスの最適化 - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optimizing performance</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015824Z" creationid="shibukawa.yoshiki" creationdate="20150409T015824Z">
        <seg>パフォーマンスの最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opting out of the auto redrawing system</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050758Z" creationid="shibukawa.yoshiki" creationdate="20150502T050758Z">
        <seg>自動再描画システムの対象から外す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional controller</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045932Z" creationid="shibukawa.yoshiki" creationdate="20150502T045932Z">
        <seg>オプショナルなコントローラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other arguments to be bound as arguments to both the controller and view functions</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100647Z" creationid="shibukawa.yoshiki" creationdate="20150502T100647Z">
        <seg>controllerとview関数に束縛されるそれ以外の引数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise it follows the Promises/A+ specifications.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174356Z" creationid="shibukawa.yoshiki" creationdate="20150415T174356Z">
        <seg>そうでない場合は、Promises/A+の仕様に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our next step is to write a view-model that will use our model classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152255Z" creationid="shibukawa.yoshiki" creationdate="20150407T152255Z">
        <seg>次のステップとして、モデルクラスを使用する、ビュー・モデルを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Output</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134431Z" creationid="shibukawa.yoshiki" creationdate="20150407T134431Z">
        <seg>出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameterized components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050010Z" creationid="shibukawa.yoshiki" creationdate="20150502T050010Z">
        <seg>パラメータ化されたコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameterized initial state</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050614Z" creationid="shibukawa.yoshiki" creationdate="20150502T050614Z">
        <seg>パラメータの初期状態</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameterizes a component</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045801Z" creationid="shibukawa.yoshiki" creationdate="20150502T045801Z">
        <seg>コンポーネントのパラメータ化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters to pass as a querystring</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171527Z" creationid="shibukawa.yoshiki" creationdate="20150414T171527Z">
        <seg>クエリー文字列として渡されるパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performance</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134435Z" creationid="shibukawa.yoshiki" creationdate="20150407T134435Z">
        <seg>パフォーマンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persisting DOM elements across route changes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121529Z" creationid="shibukawa.yoshiki" creationdate="20150502T121529Z">
        <seg>ラウト変更前後でのDOMエレメントの永続化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persisting config data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T234205Z" creationid="shibukawa.yoshiki" creationdate="20150412T234205Z">
        <seg>設定データの永続化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Post questions and discuss Mithril related topics.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135754Z" creationid="shibukawa.yoshiki" creationdate="20150407T135754Z">
        <seg>質問を投稿したり、Mithril関連の話題について議論をするメーリングリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preventing redraws on events</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T125106Z" creationid="shibukawa.yoshiki" creationdate="20150416T125106Z">
        <seg>イベントによる再描画の阻止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing web service data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123850Z" creationid="shibukawa.yoshiki" creationdate="20150410T123850Z">
        <seg>ウェブサービスのデータの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-web-service-data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174506Z" creationid="shibukawa.yoshiki" creationdate="20150414T174506Z">
        <seg>ウェブサービスのデータの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Querystring parameters in a route are also available in this collection automatically.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170737Z" creationid="shibukawa.yoshiki" creationdate="20150414T170737Z">
        <seg>ラウト中のクエリー文字列のパラメータもこのコレクションに自動的に格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queuing Operations</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125333Z" creationid="shibukawa.yoshiki" creationdate="20150410T125333Z">
        <seg>操作のキューイング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queuing operations</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174524Z" creationid="shibukawa.yoshiki" creationdate="20150414T174524Z">
        <seg>操作のキューイング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>React is a component engine developed by Facebook.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095613Z" creationid="shibukawa.yoshiki" creationdate="20150420T095613Z">
        <seg>ReactはFacebookによって開発されたコンポーネントエンジンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read Guide</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135559Z" creationid="shibukawa.yoshiki" creationdate="20150407T135559Z">
        <seg>ガイドを読む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read an argument from a parameterized route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153708Z" creationid="shibukawa.yoshiki" creationdate="20150412T153708Z">
        <seg>パラメータ化されたラウトから引数の読み込み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read articles</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135714Z" creationid="shibukawa.yoshiki" creationdate="20150407T135714Z">
        <seg>記事を読む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read docs</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135625Z" creationid="shibukawa.yoshiki" creationdate="20150407T135625Z">
        <seg>ドキュメントを読む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read the current route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153306Z" creationid="shibukawa.yoshiki" creationdate="20150412T153306Z">
        <seg>現在のラウトを取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading the currently active route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152451Z" creationid="shibukawa.yoshiki" creationdate="20150414T152451Z">
        <seg>現在アクティブなラウトの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redirecting</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012905Z" creationid="shibukawa.yoshiki" creationdate="20150410T012905Z">
        <seg>リダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redirects to a route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153249Z" creationid="shibukawa.yoshiki" creationdate="20150412T153249Z">
        <seg>ラウトへリダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redraws the view for the currently active component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125933Z" creationid="shibukawa.yoshiki" creationdate="20150502T125933Z">
        <seg>現在のアクティブなコンポーネントのビューの再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refer to the auto-redrawing guide for an example.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135018Z" creationid="shibukawa.yoshiki" creationdate="20150412T135018Z">
        <seg>サンプルについては自動描画システムのガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless, you could also force multiple redraws to happen by using the background and initialValue options in m.request, or by manually calling m.redraw().</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094358Z" creationid="shibukawa.yoshiki" creationdate="20150502T094149Z">
        <seg>特に気にしなければ、backgroundオプションとinitialValueオプションを付けてm.requestを呼び出すか、手動でm.redraw()を呼び出せば、何度か強制的に再描画させることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Released under the MIT license </seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000937Z" creationid="shibukawa.yoshiki" creationdate="20150408T000937Z">
        <seg>MITライセンスでリリースされています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Released under the MIT license</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135930Z" creationid="shibukawa.yoshiki" creationdate="20150407T135930Z">
        <seg>MITライセンスでリリースされています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember that the rules for keys apply to components the same way they do to regular elements: it is not allowed to have duplicate keys on children of the same parent, and they must be either strings or numbers (or something with a .toString() implementation that makes the entity uniquely identifiable in the local scope when serialized).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090821Z" creationid="shibukawa.yoshiki" creationdate="20150502T090821Z">
        <seg>キーの適用のルールは通常のエレメントと同じです。同じ親の子供が同じキーを持つことはできません。またキーは文字列か数字、もしくは.toString()メソッドを持っていてローカルスコープ内でユニークなキーを生成できる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rendering</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135029Z" creationid="shibukawa.yoshiki" creationdate="20150407T135029Z">
        <seg>レンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rendering Components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125012Z" creationid="shibukawa.yoshiki" creationdate="20150502T125012Z">
        <seg>コンポーネントのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rendering before web service requests finish</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174714Z" creationid="shibukawa.yoshiki" creationdate="20150414T174714Z">
        <seg>ウェブサービスのリクエスト完了前のレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rendering components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045857Z" creationid="shibukawa.yoshiki" creationdate="20150502T045857Z">
        <seg>コンポーネントのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Renders a component</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045812Z" creationid="shibukawa.yoshiki" creationdate="20150502T045812Z">
        <seg>コンポーネントのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieving a value via the getter-setter API</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014904Z" creationid="shibukawa.yoshiki" creationdate="20150415T014904Z">
        <seg>getter-setter APIを使ったデータの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returning an array, a string, a number, boolean, falsy value, etc will result in an error.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095709Z" creationid="shibukawa.yoshiki" creationdate="20150502T095709Z">
        <seg>配列、文字列、数値、ブーリアン、負になる値などを返すとエラーになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Roadmap</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154253Z" creationid="shibukawa.yoshiki" creationdate="20150412T154253Z">
        <seg>ロードマップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Robust</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133440Z" creationid="shibukawa.yoshiki" creationdate="20150407T133440Z">
        <seg>信頼性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Route parameters are dynamic values that can be extracted from the URL based on the signature of the currently active route.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170523Z" creationid="shibukawa.yoshiki" creationdate="20150414T170523Z">
        <seg>ラウトのパラメータは、現在アクティブなラウトのシグニチャを元にして、現在のURLから取り出された動的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routes can take arguments, by prefixing words with a colon :</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153420Z" creationid="shibukawa.yoshiki" creationdate="20150414T153420Z">
        <seg>:を前に付いた単語を書くことで、ラウトに引数を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routes can take arguments, by prefixing words with a colon :.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003039Z" creationid="shibukawa.yoshiki" creationdate="20150410T003039Z">
        <seg>:を前に付いた単語を書くことで、ラウトに引数を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routes with querystrings</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152326Z" creationid="shibukawa.yoshiki" creationdate="20150414T152326Z">
        <seg>ラウトとクエリー文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015810Z" creationid="shibukawa.yoshiki" creationdate="20150407T140735Z">
        <seg>ラウティング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015956Z" creationid="shibukawa.yoshiki" creationdate="20150409T015956Z">
        <seg>ラウティング - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing is a system that allows creating Single-Page-Applications (SPA), i.e. applications that can go from a page to another without causing a full browser refresh.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152527Z" creationid="shibukawa.yoshiki" creationdate="20150414T152527Z">
        <seg>ラウティング(Routing = アメリカ英語読みはルーティングよりもラウティングが近い)は、シングルページアプリケーション(SPA)を作るための仕組みです。他のページに行く時に、フルにブラウザをリフレッシュしなくても済むアプリケーションを実現することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing is a system that allows creating Single-Page-Applications (SPA), i.e. applications that can go from one page to another without causing a full browser refresh.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T020138Z" creationid="shibukawa.yoshiki" creationdate="20150409T020138Z">
        <seg>ラウティング(Routing = アメリカ英語読みはルーティングよりもラウティングが近い)は、シングルページアプリケーション(SPA)を作るための仕組みです。他のページに行く時に、フルにブラウザをリフレッシュしなくても済むアプリケーションを実現することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing is single-page-application (SPA) friendly, and can be implemented using either location.hash, HTML5 URL rewriting or location.querystring.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153216Z" creationid="shibukawa.yoshiki" creationdate="20150414T153216Z">
        <seg>ラウトはシングルページアプリケーション(SPA)を実現しやすくする仕組みで、 location.hash、HTML5のURL書き換え、location.querystringのどれかの方法を使って実装できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Routing mode abstraction</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153317Z" creationid="shibukawa.yoshiki" creationdate="20150412T153317Z">
        <seg>ラウティングモードの抽象化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running clean up code on route change</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152414Z" creationid="shibukawa.yoshiki" creationdate="20150414T152414Z">
        <seg>ラウト変更時に後処理コードを実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safe-by-default templates</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133820Z" creationid="shibukawa.yoshiki" creationdate="20150407T133820Z">
        <seg>デフォルト設定が安全側に振られたテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safety</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135046Z" creationid="shibukawa.yoshiki" creationdate="20150407T135046Z">
        <seg>安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sample code</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134223Z" creationid="shibukawa.yoshiki" creationdate="20150407T134223Z">
        <seg>サンプルコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See "Signature" section for details.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235315Z" creationid="shibukawa.yoshiki" creationdate="20150412T235315Z">
        <seg>詳細についてはシグニチャのセクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See m() for more information on virtual elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013558Z" creationid="shibukawa.yoshiki" creationdate="20150410T013558Z">
        <seg>仮想エレメントについての詳細は、m()のドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See m.component for information on components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135834Z" creationid="shibukawa.yoshiki" creationdate="20150502T135834Z">
        <seg>コンポーネントに関してはm.componentを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See m.deferred for more information on promises.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180629Z" creationid="shibukawa.yoshiki" creationdate="20150415T180629Z">
        <seg>promiseについてはm.deferredを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See subtree directives.html for more information.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160449Z" creationid="shibukawa.yoshiki" creationdate="20150413T160449Z">
        <seg>要塞については、subtree directives.htmlを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See m.route.mode for the caveats of each implementation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153242Z" creationid="shibukawa.yoshiki" creationdate="20150414T153242Z">
        <seg>それぞれの実装方法の詳細については、m.route.modeを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the integration guide for more information.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125508Z" creationid="shibukawa.yoshiki" creationdate="20150413T125500Z">
        <seg>これについては他のライブラリとの統合を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the next section.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174214Z" creationid="shibukawa.yoshiki" creationdate="20150415T173510Z">
        <seg>次のセクションもご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Serialize data into querystring format</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153729Z" creationid="shibukawa.yoshiki" creationdate="20150412T153729Z">
        <seg>データをクエリー文字列フォーマットでシリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Serializes an object into its URI encoded querystring representation, following the same serialization conventions as URI.js</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170947Z" creationid="shibukawa.yoshiki" creationdate="20150414T170947Z">
        <seg>URI.jsと同じシリアライズ規約を使い、オブジェクトをURIでエンコードされたクエリー文字列にシリアライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Serializing getter-setters</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133748Z" creationid="shibukawa.yoshiki" creationdate="20150414T133748Z">
        <seg>getter-setterのシリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting context.retain = true in the element's config function allows the span to stay intact after a route change.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T134935Z" creationid="shibukawa.yoshiki" creationdate="20150413T134828Z">
        <seg>エレメントのconfig関数の中でcontext.retain = trueと設定すると、ラウトが変更されてもコストが高い(つもりの)spanタグを保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting strategy to none in any one of those handlers will not affect the redrawing strategy of other handlers (and remember that strategy("none") has no effect on asynchronous redraws).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151229Z" creationid="shibukawa.yoshiki" creationdate="20150416T151229Z">
        <seg>この場合、１つのハンドラでnoneに戦略を変更しても、strategy("none") は非同期の再描画に効果を与えないため、他のハンドラの再描画戦略に影響を与えることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the background option to true prevents a request from affecting redrawing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T000224Z" creationid="shibukawa.yoshiki" creationdate="20150415T000224Z">
        <seg>backgroundオプションをtrueに設定すると、リクエストが再描画のプロセスに干渉することはなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signature</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235059Z" creationid="shibukawa.yoshiki" creationdate="20150412T235059Z">
        <seg>シグニチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar, setting the value of attribute readonly to false is equivalent to removing the attribute in HTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153955Z" creationid="shibukawa.yoshiki" creationdate="20150413T153955Z">
        <seg>同様にreadonly属性にfalseを設定すると、その属性をHTMLから取り除くのと同じ結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, ContactForm can be used to both create new contacts as well as edit existing ones.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T010148Z" creationid="shibukawa.yoshiki" creationdate="20150502T010148Z">
        <seg>同様にContactFormも、新規の連絡先の作成と、既存の連絡先の編集の両方に利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since computer screens are not able to display changes faster than a frame, this optimization saves CPU cycles and helps UIs stay responsive even in the face of spammy data changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T191712Z" creationid="shibukawa.yoshiki" creationdate="20150411T191712Z">
        <seg>コンピュータのスクリーンはフレーム以上の速度で表示することはできないため、この最適化によってCPUのサイクルを節約することができますし、大量のデータ変更に対してもUIの応答性を保つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since controllers can call model methods, it's possible for nested components to encapsulate asynchronous behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093109Z" creationid="shibukawa.yoshiki" creationdate="20150502T093109Z">
        <seg>コントローラはモデルのメソッドを呼ぶことができますが、非同期の動作をカプセル化するのにネストされたコンポーネントを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Small API, small learning curve</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134049Z" creationid="shibukawa.yoshiki" creationdate="20150407T133432Z">
        <seg>小さくシンプルなAPIと、低い学習コスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So calling m.request multiple times from a controller context increments the internal counter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154446Z" creationid="shibukawa.yoshiki" creationdate="20150416T154446Z">
        <seg>m.requestをコントローラのコンテキスト内で複数回呼ぶと、内部カウンターが増加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, we've been using m.render to manually redraw after we made a change to the data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161003Z" creationid="shibukawa.yoshiki" creationdate="20150408T161003Z">
        <seg>最初に紹介したときは、データを変更した後に手動でm.renderを呼び出して再描画を行わせていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Social Media</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135808Z" creationid="shibukawa.yoshiki" creationdate="20150407T135808Z">
        <seg>ソーシャルメディア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some asynchronous operations might need to affect redrawing both before and after their completion.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135833Z" creationid="shibukawa.yoshiki" creationdate="20150415T135833Z">
        <seg>再描画の操作によっては、呼び出し前と後の両方に再描画が必要になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some cases may not require a redraw upon completion of the asynchronous callbacks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135749Z" creationid="shibukawa.yoshiki" creationdate="20150415T135749Z">
        <seg>非同期のコールバックを待たずに再描画を行っても問題ないケースもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the older frameworks among the popular ones (out-of-the-box jQuery and Backbone, specifically) take a more procedural paradigm when it comes to the view layer; this means every action requires the developer to write custom view-level code to handle it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014215Z" creationid="shibukawa.yoshiki" creationdate="20150420T014215Z">
        <seg>有名ないくつかの古いフレームワーク(jQueryやBackboneなどは特に)は、ビューのレイヤーに対しても、より手続き型寄りのパラダイムを採用しました。開発者が毎回、開発対象ごとにビューレベルのコードを手書きしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some services (e.g. Flickr) don't follow the convention of calling the callback parameter callback.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235033Z" creationid="shibukawa.yoshiki" creationdate="20150414T234945Z">
        <seg>Flickrなどの一部のサービスは、callbackパラメータで指定されたcallbackを呼び出すというJSONPの規約に従っていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you only care about a particular condition in an event and want the event to not trigger a redraw if this condition is not met.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150101Z" creationid="shibukawa.yoshiki" creationdate="20150416T150101Z">
        <seg>イベント内の特定の条件について考慮した時に、その条件に合わなければ再描画を行いたくない、と思うこともよくあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Speaking from experience, it's generally difficult to reason about performance in Angular.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094802Z" creationid="shibukawa.yoshiki" creationdate="20150420T094745Z">
        <seg>経験から見ても、Angularのパフォーマンス向上させるのは難しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specific Framework Comparisons</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015024Z" creationid="shibukawa.yoshiki" creationdate="20150420T015024Z">
        <seg>特定のフレームワークとの比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050605Z" creationid="shibukawa.yoshiki" creationdate="20150502T050605Z">
        <seg>ステートフルなコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateless components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050557Z" creationid="shibukawa.yoshiki" creationdate="20150502T050557Z">
        <seg>ステートレスなコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Steep performance degradation is a notoriously common issue in non-trivial Angular applications and there are several third party libraries which attempt to get around performance problems.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094626Z" creationid="shibukawa.yoshiki" creationdate="20150420T094626Z">
        <seg>巨大なAngularのアプリケーションのパフォーマンスは厳しいものがあり、それに対応しようとするサードパーティ製のライブラリもいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequent parameters have no restrictions (e.g. "this is a test")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080042Z" creationid="shibukawa.yoshiki" creationdate="20150502T080042Z">
        <seg>それに続く引数("this is a test")には制限がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently, the view function is called and will be called again anytime a redraw is required.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071921Z" creationid="shibukawa.yoshiki" creationdate="20150502T071921Z">
        <seg>その後、view関数が再描画が必要になるたびに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subtree Directives</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123430Z" creationid="shibukawa.yoshiki" creationdate="20150416T123430Z">
        <seg>サブツリーディレクティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subtree directives</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015933Z" creationid="shibukawa.yoshiki" creationdate="20150416T015933Z">
        <seg>サブツリーディレクティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161941Z" creationid="shibukawa.yoshiki" creationdate="20150408T161941Z">
        <seg>まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose we have a component called ProjectList and the following data:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085647Z" creationid="shibukawa.yoshiki" creationdate="20150502T085647Z">
        <seg>下記のデータを持つ、ProjectListと呼ばれるコンポーネントがあったとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SweetJS requires a NodeJS environment.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150037Z" creationid="shibukawa.yoshiki" creationdate="20150412T150037Z">
        <seg>SweetJSを実行するにはNodeJS環境が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronous execution</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140153Z" creationid="shibukawa.yoshiki" creationdate="20150415T140153Z">
        <seg>同期実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take it with a grain of salt.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015147Z" creationid="shibukawa.yoshiki" creationdate="20150420T015147Z">
        <seg>そのまま鵜呑みにせずに、参考程度にお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Template Converter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013555Z" creationid="shibukawa.yoshiki" creationdate="20150417T013555Z">
        <seg>テンプレートコンバータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Test Summary</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135442Z" creationid="shibukawa.yoshiki" creationdate="20150407T135442Z">
        <seg>テスト結果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Testing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154222Z" creationid="shibukawa.yoshiki" creationdate="20150412T154222Z">
        <seg>テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Testing the various parts of the component is trivial:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081601Z" creationid="shibukawa.yoshiki" creationdate="20150502T081546Z">
        <seg>コンポーネントのさまざまなパーツをテストするのは簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That organization pattern needlessly ties unrelated aspects of the application together and dilutes the clarity of modules.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015746Z" creationid="shibukawa.yoshiki" creationdate="20150421T015746Z">
        <seg>このようなパターンでアプリケーションを分けてしまうと、レイヤー間で不必要なコードの密結合が起きてしまいます。モジュールによる、MVC縦断の縦のつながりがわかりにくくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The m.startComputation / m.endComputation pair is designed to be "stacked", i.e. multiple asynchronous services can each call this pair of functions to indicate that they want the redrawing algorithm to wait for them to finish before a redraw occurs.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130550Z" creationid="shibukawa.yoshiki" creationdate="20150502T130550Z">
        <seg>m.startComputation / m.endComputationのペアは「スタックされる」ように設計されています。例えば、複数の非同期サービスのそれぞれがこの呼出のペアを持っており、すべてのリクエストが完了するまで再描画を待たせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The config's retain flag can be used to change how specific elements are redrawn when routes change.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000509Z" creationid="shibukawa.yoshiki" creationdate="20150506T000509Z">
        <seg>configのretainフラグを使うと、ラウト変更時に特定の要素を再描画するかどうかを指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ContactForm component is, as its name suggests, a form that allows us to edit the fields of a Contact entity.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T001804Z" creationid="shibukawa.yoshiki" creationdate="20150502T001804Z">
        <seg>ContactFormコンポーネントは、名前から推測できる通りで、Contactエンティティのフィールドを編集するフォームを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ContactList component displays a table showing all the contact entities that are passed to it via the contacts argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002420Z" creationid="shibukawa.yoshiki" creationdate="20150502T002420Z">
        <seg>ContactListコンポーネントは、contacts引数で渡されたすべての連絡先のエンティティを表形式で表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ContactList component's controller is marked as Observable, and the save event handler in ContactForm calls Observable.trigger after saving.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021142Z" creationid="shibukawa.yoshiki" creationdate="20150502T021142Z">
        <seg>ContactListコンポーネントのコントローラが監視対象としてマークして、その後ContactFormのsaveイベントハンドラの中で、保存後にObservable.trigger呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Observable object can be further refactored so that trigger broadcasts to "channels", which controllers can subscribe to.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025105Z" creationid="shibukawa.yoshiki" creationdate="20150502T025105Z">
        <seg>Observable(監視可能)オブジェクトはtriggerを使ってコントローラが購読している"channels"にブロードキャストするという方式にリファクタリングすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Observable object exposes two methods: register which marks a controller as a Observable entity, and trigger which reloads controllers marked by register.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T020914Z" creationid="shibukawa.yoshiki" creationdate="20150502T020914Z">
        <seg>Observableオブジェクトは2つのメソッドを提供しています。registerはコントローラのエンティティを監視対象のエンティティとして登録します。triggerはregisterで登録されたコントローラをリロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TodoList class is simply an alias of the native Array class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151056Z" creationid="shibukawa.yoshiki" creationdate="20150407T151044Z">
        <seg>TodoListクラスは単に、標準のArrayクラスの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The attributes argument (i.e. the second parameter in the m("div", {class: "container"}, "Hello") example) is meant to be used for attributes whose values we want to dynamically populate.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002101Z" creationid="shibukawa.yoshiki" creationdate="20150413T002101Z">
        <seg>m("div", {class: "container"}, "Hello")の2番目のパラメータのattributes引数は、動的に変更する可能性のある属性を設定するのに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The config attribute</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121555Z" creationid="shibukawa.yoshiki" creationdate="20150413T154833Z">
        <seg>config属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The config function created by our factory only runs the initialization code if it hasn't already.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133749Z" creationid="shibukawa.yoshiki" creationdate="20150412T133749Z">
        <seg>このファクトリ関数で作成されたconfig関数は、初期化関数だけを実行します。ただし、すでに初期化済みの場合は何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The config mechanism can also be used to put focus on form inputs, and call methods that would not be possible to execute via the regular attribute syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124432Z" creationid="shibukawa.yoshiki" creationdate="20150413T124432Z">
        <seg>configの仕組みを使うと、入力フォームにフォーカスを移動したり、通常の属性文法では呼び出せないメソッドを呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The config option can also be used to retrieve the XMLHttpRequest instance for aborting the request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182308Z" creationid="shibukawa.yoshiki" creationdate="20150414T182308Z">
        <seg>configを通じて、XMLHttpRequestのインスタンスに対して、リクエストの中断を行わせることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The config option can be used to arbitrarily configure the native XMLHttpRequest instance and to access properties that would not be accessible otherwise.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182052Z" creationid="shibukawa.yoshiki" creationdate="20150414T182052Z">
        <seg>configオプションを使って、ネイティブのXMLHttpRequestインスタンスの設定を任意に設定したり、他の方法ではアクセスできないプロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The controller function is called once when the component is rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071828Z" creationid="shibukawa.yoshiki" creationdate="20150502T071828Z">
        <seg>controller関数は、コンポーネントがレンダリングされる時に一度だけ呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The controller function is optional and defaults to an empty function controller: function() {}</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072050Z" creationid="shibukawa.yoshiki" creationdate="20150502T072050Z">
        <seg>controller関数はオプショナルです。デフォルト値は空の関数(controller: function() {})です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dashboard component in the example shows how a developer would consume the select2 component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045343Z" creationid="shibukawa.yoshiki" creationdate="20150502T045343Z">
        <seg>サンプルのdashboardコンポーネントを見ると、どのようにselect2コンポーネントを使用するかが分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The errorCallback is called if reject is called in the root deferred.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175931Z" creationid="shibukawa.yoshiki" creationdate="20150415T175931Z">
        <seg>ルートのdeferredのrejectが呼ばれるとerrorCallbackが呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The extract method can be used to read metadata from HTTP response headers or the status field of an XMLHttpRequest.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175735Z" creationid="shibukawa.yoshiki" creationdate="20150414T175735Z">
        <seg>extractメソッドはHTTPレスポンスヘッダのメタデータや、XMLHttpRequestのステータスフィールドを読み込むのに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The m.redraw.strategy getter-setter indicates how the next component redraw will occur.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T133408Z" creationid="shibukawa.yoshiki" creationdate="20150502T133408Z">
        <seg>m.redraw.strategy getter-setterは次のコンポーネントの再描画をどのように行うかを設定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The m.route.mode defines which part of the URL to use for routing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153703Z" creationid="shibukawa.yoshiki" creationdate="20150414T153703Z">
        <seg>m.route.modeは、URLのどの部分をラウトとして使うかを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The m.route.mode property defines which URL portion is used to implement the routing mechanism.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004211Z" creationid="shibukawa.yoshiki" creationdate="20150410T004211Z">
        <seg>m.route.modeプロパティを使うと、どのURLに対してラウティングの仕組みを実装するかを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The m.startComputation / m.endComputation pair is designed to be "stacked", i.e. multiple asynchronous services can each call this pair of functions to indicate that they want the redrawing algorithm to wait for them to finish before a redraw occurs.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114333Z" creationid="shibukawa.yoshiki" creationdate="20150502T114333Z">
        <seg>m.startComputation / m.endComputationのペアは「スタックされる」ように設計されています。例えば、複数の非同期サービスのそれぞれがこの呼出のペアを持っており、すべてのリクエストが完了するまで再描画を待たせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The m.withAttr("value", todo.vm.description) call above returns a function that is the rough equivalent of this code:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T022246Z" creationid="shibukawa.yoshiki" creationdate="20150408T022246Z">
        <seg>m.withAttr("value", todo.vm.description)という関数呼びしは、次のコードに相当する関数を返り値として返します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The m.withAttr utility is a functional programming tool provided by Mithril to minimize the need for anonymous functions in the view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T022141Z" creationid="shibukawa.yoshiki" creationdate="20150408T022141Z">
        <seg>m.withAttrはMithrilが提供する関数型プログラミングのためのツールで、ビューの内部で無名関数の使用頻度を下げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The onerror function can be safely replaced if the default error monitoring semantics are not desired.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174815Z" creationid="shibukawa.yoshiki" creationdate="20150415T174815Z">
        <seg>もし標準のエラーをモニタリングする仕組みが期待に合わなければ、onerrorを安全に置き換えて使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The options parameter that was passed into m.request call</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014232Z" creationid="shibukawa.yoshiki" creationdate="20150415T014232Z">
        <seg>optionsパラメータは、m.request呼び出し時に渡された引数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The promise object is actually a function - specifically, it's an m.prop getter-setter, which gets populated with the value returned by successCallback if the promise is resolved successfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134828Z" creationid="shibukawa.yoshiki" creationdate="20150415T134828Z">
        <seg>promiseは普通の関数です。具体的にはm.prop getter-setterで、promiseが成功すると、successCallbackが返す値が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The successCallback is called if resolve is called in the root deferred.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175736Z" creationid="shibukawa.yoshiki" creationdate="20150415T175736Z">
        <seg>ルートのdeferredのresolveが呼ばれるとsuccessCallbackが呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The then method returns another promise whose computations (if any) receive their inputs from the parent promise's computation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175036Z" creationid="shibukawa.yoshiki" creationdate="20150415T175036Z">
        <seg>thenメソッドは親のpromiseの計算結果を受け取る、別のpromiseを作って返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The view function does not create a DOM tree when called.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072341Z" creationid="shibukawa.yoshiki" creationdate="20150502T072341Z">
        <seg>view関数は使用されたタイミングではDOMツリーを作成することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The view has access to methods and properties that the controller chooses to expose in the returned object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061901Z" creationid="shibukawa.yoshiki" creationdate="20150502T061901Z">
        <seg>viewは、コントローラが公開すると決めたメソッドやプロパティにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The vm.add.bind(vm, vm.description) expression above returns a function that is equivalent to this code:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151435Z" creationid="shibukawa.yoshiki" creationdate="20150408T151435Z">
        <seg>vm.add.bind(vm, vm.description)という式は、次の式と等価です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The then method returns a child promise, which, itself, can have more child promises, recursively.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134713Z" creationid="shibukawa.yoshiki" creationdate="20150415T134645Z">
        <seg>thenメソッドは子供のpromiseを返します。この子のpromiseにもさらに子のpromiseを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The onunload event is called if an instantiated component is removed from a virtual element tree via a redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092640Z" creationid="shibukawa.yoshiki" creationdate="20150502T092640Z">
        <seg>インスタンス化されたコンポーネントが仮想エレメントツリーから削除されるときにonunloadイベントが呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The promise property is the root of the promise tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134134Z" creationid="shibukawa.yoshiki" creationdate="20150415T134134Z">
        <seg>promiseプロパティは、promise木のルートです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Auto-Redrawing System</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140901Z" creationid="shibukawa.yoshiki" creationdate="20150407T140901Z">
        <seg>自動再描画システム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Auto-Redrawing System - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183333Z" creationid="shibukawa.yoshiki" creationdate="20150411T183333Z">
        <seg>自動再描画システム - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CSS selector syntax (e.g. a#google.external[href='http://google.com']) is meant to be used for declaring static attributes in the element, i.e. attribute values that don't change dynamically when the user interacts with the app.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T001946Z" creationid="shibukawa.yoshiki" creationdate="20150413T001946Z">
        <seg>a#google.external[href='http://google.com'])のようなCSSセレクタ文法は、エレメントの静的なアトリビュートの定義で使用します。静的というのはアプリケーションの中で動的に変更されることがない要素になるという意味です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DOM element that corresponds to virtual element defined by the m() call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155036Z" creationid="shibukawa.yoshiki" creationdate="20150413T155036Z">
        <seg>m()呼び出しで定義された仮想エレメントに対応するDOMエレメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTP method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002047Z" creationid="shibukawa.yoshiki" creationdate="20150415T002047Z">
        <seg>HTTPのメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TemperatureConverter controller never stores the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081502Z" creationid="shibukawa.yoshiki" creationdate="20150502T081502Z">
        <seg>TemperatureConverterコントローラは値を保持することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Todo class API is reusable and unit-test friendly, and in addition, it's a plain-vanilla Javascript class, and so has almost no framework-specific learning curve.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T234500Z" creationid="shibukawa.yoshiki" creationdate="20150408T234500Z">
        <seg>TodoクラスのAPIは再利用可能で、ユニットテストが容易です。また、プレーンなJavaScriptのクラスであるため、フレームワーク特有の学習は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The URL to request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002200Z" creationid="shibukawa.yoshiki" creationdate="20150415T002200Z">
        <seg>リクエストを送るURL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The XMLHttpRequest instance.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014203Z" creationid="shibukawa.yoshiki" creationdate="20150415T014203Z">
        <seg>XMLHttpRequestのインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to "cast" the response to a class of your choice</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014452Z" creationid="shibukawa.yoshiki" creationdate="20150410T014452Z">
        <seg>レスポンスを好きなクラスにキャストする機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to get an early reference to a container that will hold the asynchronous response</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014404Z" creationid="shibukawa.yoshiki" creationdate="20150410T014347Z">
        <seg>非同期のレスポンスが後で格納されるコンテンナを事前に参照しておく機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to handle arguments in the controller is useful for setting up the initial state for a component whose state depends on input data:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084456Z" creationid="shibukawa.yoshiki" creationdate="20150502T084456Z">
        <seg>コントローラ内で引数を持てる機能は、コンポーネントの初期値のセットアップに便利です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to queue operations to be performed after the asynchronous request completes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014429Z" creationid="shibukawa.yoshiki" creationdate="20150410T014429Z">
        <seg>非同期のリクエストが完了した後に実行される操作をキューに貯めておく機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to unwrap data in a response that includes metadata properties</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014517Z" creationid="shibukawa.yoshiki" creationdate="20150410T014517Z">
        <seg>メタデータのプロパティを含むレスポンスを展開する機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The auto-redrawing system in Mithril is not affected by changes in values of m.prop getter-setters.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153954Z" creationid="shibukawa.yoshiki" creationdate="20150416T153954Z">
        <seg>Mithrilの自動再描画システムは、m.prop getter-setterの値の変更では何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic usage pattern for m.request returns an m.prop getter-setter, which is populated when the AJAX request completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014645Z" creationid="shibukawa.yoshiki" creationdate="20150410T014645Z">
        <seg>m.requestを通常の使用法で使うと、AJAXのリクエストが完了した後に結果が格納されるm.prop getter-setterを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The biggest difference between Ember and Mithril is summarized in the Architecture section above: Ember's comprehensiveness comes at the cost of a steep learning curve and a high degree of vendor lock-in.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095436Z" creationid="shibukawa.yoshiki" creationdate="20150420T095436Z">
        <seg>EmberとMithrilの一番大きな違いは、このアーキテクチャの違いに収束します。広範囲に渡るため、急峻なラーニングカーブを持ち、幅広くベンダーにロックインされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The button calls the todo.vm.add method when clicked.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153858Z" creationid="shibukawa.yoshiki" creationdate="20150408T153858Z">
        <seg>ボタンが押されると、todo.vm.addメソッドが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The callbacks for this promise receive as a parameter an Array containing the values of all the input promises</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T181118Z" creationid="shibukawa.yoshiki" creationdate="20150415T181118Z">
        <seg>このpromiseのレシーバーは、入力のメソッドのすべての値を持つ配列を引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkboxes save their value to the task.done getter setter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T160629Z" creationid="shibukawa.yoshiki" creationdate="20150408T160629Z">
        <seg>チェックボックスは値をtask.done getter setterに保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above defines a view-model object called vm.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T162019Z" creationid="shibukawa.yoshiki" creationdate="20150407T162019Z">
        <seg>上記のコードは、vmという名前のビュー・モデルオブジェクトを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code bound to the onchange can be read like this: "with the attribute value, set todo.vm.description".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021305Z" creationid="shibukawa.yoshiki" creationdate="20150408T021305Z">
        <seg>このコードはonchangeに結び付けれており、「valueの属性の値を, todo.vm.descriptionに設定」するという意味になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complete view looks like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153552Z" creationid="shibukawa.yoshiki" creationdate="20150408T153552Z">
        <seg>完成したviewは次のようなコードになっています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data to unwrap</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013000Z" creationid="shibukawa.yoshiki" creationdate="20150415T013000Z">
        <seg>unwrapするデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value (if this parameter is falsy) is JSON.parse</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013238Z" creationid="shibukawa.yoshiki" creationdate="20150415T013203Z">
        <seg>この設定がfalsyな値だったときのデフォルト動作は、JSON.parseです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value (if this parameter is falsy) is JSON.stringify</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013129Z" creationid="shibukawa.yoshiki" creationdate="20150415T013129Z">
        <seg>この設定がfalsyな値だったときのデフォルト動作は、JSON.stringifyです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value (if this parameter is falsy) is the identity function function(value) {return value}</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012744Z" creationid="shibukawa.yoshiki" creationdate="20150415T012744Z">
        <seg>この設定がfalsyな値だったときのデフォルトの動作は、function(value) {return value}という関数と等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value is "search".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004843Z" creationid="shibukawa.yoshiki" creationdate="20150410T004843Z">
        <seg>デフォルトは"search"です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deferred object can then apply a value by calling either resolve or reject, which then dispatches the value to be processed to the computation tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T133747Z" creationid="shibukawa.yoshiki" creationdate="20150415T133718Z">
        <seg>deferredは、resolveもしくはrejectを呼び出すことで、値を適用することができます。その値は計算木に渡って処理されていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deferred object returned by m.deferred has two methods: resolve and reject, and one property called promise.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134006Z" creationid="shibukawa.yoshiki" creationdate="20150415T134006Z">
        <seg>m.deferred関数が返すdeferredオブジェクトは、resolveとrejectの2つのメソッドと、promiseと呼ばれるプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dependency injector</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045846Z" creationid="shibukawa.yoshiki" creationdate="20150412T154242Z">
        <seg>依存性注入(Dependency Injection)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The description gets crossed out via CSS if the task is marked as done.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T160832Z" creationid="shibukawa.yoshiki" creationdate="20150408T160832Z">
        <seg>タスクが完了したとマークされると、CSSを通じて説明が消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deserialized object</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140000Z" creationid="shibukawa.yoshiki" creationdate="20150502T140000Z">
        <seg>デシリアライズしたオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference with the modified version is that add no longer takes an argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152436Z" creationid="shibukawa.yoshiki" creationdate="20150408T152436Z">
        <seg>変更前のコードと異なっているのはaddメソッドの引数がなくなった点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference, aside from avoiding an anonymous function, is that the m.withAttr idiom also takes care of catching the correct event target and selecting the appropriate source of the data - i.e. whether it should come from a Javascript property or from DOMElement::getAttribute()</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151145Z" creationid="shibukawa.yoshiki" creationdate="20150408T151145Z">
        <seg>無名関数の使用を避ける以外の違いとしては、m.withAttrを使うと、正しいイベントターゲットや、適切なデータソースを選んでくれます。例えば、その入力ソースがJavaScriptのプロパティか、DOMElement::getAttribute()かといった違いを識別して、適切な動作をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The different between m.mount and m.render is that a component rendered via m.mount auto-redraws automatically when event handlers are triggered, whereas components rendered via m.render do not.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125206Z" creationid="shibukawa.yoshiki" creationdate="20150502T125206Z">
        <seg>m.mountとm.renderの違いは、m.mountの場合は自動再描画システムがイベントハンドラから起動されるが、m.renderは起動しない点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The easiest way to polyfill these features is to include this script:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014737Z" creationid="shibukawa.yoshiki" creationdate="20150417T014614Z">
        <seg>次のスクリプト(polyfillと呼ばれる互換性向上コード)を読み込ませるのがもっとも簡単な補完方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effort to make the table paginated, searchable or filterable can improve the user experience in addition to solving the performance problem both on redraws and on initial page load.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143606Z" creationid="shibukawa.yoshiki" creationdate="20150412T143606Z">
        <seg>テーブルをページ分割したり、ソートやフィルタ可能にすると、ユーザエクスペリエンスが向上するだけでなく、再描画と初期のページロードの両方のパフォマンスの問題が解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end result is that Mithril waits for all requests to complete before attempting to redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154538Z" creationid="shibukawa.yoshiki" creationdate="20150416T154538Z">
        <seg>すべてのリクエストが完了するのを待って、Mithrilは再描画を行おうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end result is that you can call m.request and other integrated data services seamlessly, and Mithril will wait for all of the asynchronous operations to complete before attempting to redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190821Z" creationid="shibukawa.yoshiki" creationdate="20150411T190821Z">
        <seg>これによって、m.requestや他のデータサービスとの統合をシームレスに行えるようになっています。Mithrilはすべての非同期操作が完了するのをまってから再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines three routes, to be rendered in &lt;body&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002804Z" creationid="shibukawa.yoshiki" creationdate="20150410T002804Z">
        <seg>次のサンプルは、&lt;body&gt;のレンダリングをする、3つのラウトを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a contrived redraw counter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125842Z" creationid="shibukawa.yoshiki" creationdate="20150413T125842Z">
        <seg>次のサンプルは、再描画のカウントを表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a convoluted series of AJAX requests implemented with a third party library.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010751Z" creationid="shibukawa.yoshiki" creationdate="20150412T010751Z">
        <seg>次のサンプルには、サードパーティライブラリを使った複雑に入り組んだAJAXリクエストのかたまりがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a route that takes a userID parameter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003111Z" creationid="shibukawa.yoshiki" creationdate="20150410T003111Z">
        <seg>次のサンプルはuserIDパラメータを取るラウトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a route that takes an userID parameter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153431Z" creationid="shibukawa.yoshiki" creationdate="20150414T153431Z">
        <seg>次のサンプルはuserIDパラメータを取るラウトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a simple component that integrates with the select2 library.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021607Z" creationid="shibukawa.yoshiki" creationdate="20150412T014035Z">
        <seg>次のサンプルは、select2ライブラリ(jQuery用の拡張版&lt;select&gt;タグを提供するライブラリ)を統合した、シンプルなコンポーネントの例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a variation of the contacts app where ContactForm is responsible for saving.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T030623Z" creationid="shibukawa.yoshiki" creationdate="20150502T030623Z">
        <seg>次のサンプルは、連絡先アプリの別バージョンで、ContactFormが保存の責務を担っているバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how to configure a request where the server expects requests to have a Content-Type: application/json header</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182219Z" creationid="shibukawa.yoshiki" creationdate="20150414T182219Z">
        <seg>下記の例は、サーバがリクエストとしてContent-Type: application/jsonヘッダを期待しているときに、それを行うための方法を示したサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how to receive a plain string from a txt file.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T175346Z" creationid="shibukawa.yoshiki" creationdate="20150410T175346Z">
        <seg>次のサンプルはテキストファイルをそのままプレーンな文字列として受ける取る方法を紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how to use a SubtreeDirective object to create a static header that doesn't incur diff costs once it has been rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124343Z" creationid="shibukawa.yoshiki" creationdate="20150416T124343Z">
        <seg>下記の例は静的なヘッダーに対してサブツリーディレクティブをどのように使用するかのサンプルです。このようにすることで、一度レンダリングされた後は差分検出のコストが発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples in this site usually conflate different MVC layers together for the sake of readability, but normally it's recommended that each layer on a module be in different files.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015128Z" creationid="shibukawa.yoshiki" creationdate="20150421T015128Z">
        <seg>このサイトのサンプルは、読みやすさのために異なるMVCレイヤーを1つのファイルにまとめていますが、レイヤーごとにファイルを分割するのが推奨されるスタイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception monitor</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015810Z" creationid="shibukawa.yoshiki" creationdate="20150415T015810Z">
        <seg>例外モニタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The existence of the component only becomes known to the diff engine at the time when the template is rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093533Z" creationid="shibukawa.yoshiki" creationdate="20150502T093533Z">
        <seg>差分検知エンジンは、テンプレートをレンダリングする時にのみ、コンポーネントの存在を検知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first and most obvious thing you may have noticed in the view layer is that the view is not written in HTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013054Z" creationid="shibukawa.yoshiki" creationdate="20150409T013054Z">
        <seg>これがもっともはっきりと気づいてもらいやすい点が、ビューがHTMLに書かれていないという点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first parameter after the component object is meant to be used as an attribute map and should be an object (e.g. {name: "world"}).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080026Z" creationid="shibukawa.yoshiki" creationdate="20150502T080026Z">
        <seg>コンポーネントオブジェクトの後の最初のパラメータは属性のマップで、{name: "world"}などのオブジェクトを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example illustrates this pattern:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081054Z" creationid="shibukawa.yoshiki" creationdate="20150502T081054Z">
        <seg>次のサンプルはこのパターンを説明しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following topics are good places to start a deeper dive.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015805Z" creationid="shibukawa.yoshiki" creationdate="20150409T015805Z">
        <seg>Mithrilについてより深く知りたい場合には次のトピックが良い出発点になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The goal of the framework is to make application code discoverable, readable and maintainable, and hopefully help you become an even better developer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141806Z" creationid="shibukawa.yoshiki" creationdate="20150407T141806Z">
        <seg>このフレームワークのゴールは、アプリケーションコードの探索しやすさ、読みやすさ、メンテナンス性を向上させ、あなたがすばらしい開発者になる手助けをすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implications of saving are left to the parent component to handle.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T010840Z" creationid="shibukawa.yoshiki" creationdate="20150502T010840Z">
        <seg>保存の操作については、親のコンポーネントに残してあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initialization code defines a change event handler.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134001Z" creationid="shibukawa.yoshiki" creationdate="20150412T134001Z">
        <seg>初期化コードはchangeイベントハンドラを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key for each child must be unique among a list of sibling DOM elements, but it does not need to be globally unique.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142205Z" creationid="shibukawa.yoshiki" creationdate="20150413T142205Z">
        <seg>リストの子の兄弟のDOMエレメントのキーはユニークでなければなりませんが、アプリケーション全体でグローバルにユニークである必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key is defined in the li, which is the closest element to the items array, not directly on the input, even though we want to track focus on the input.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T143904Z" creationid="shibukawa.yoshiki" creationdate="20150413T143904Z">
        <seg>キーは、items配列に一番近いエレメントのliエレメントに設定します。フォーカスを維持したいのはinputエレメントですが、このエレメントに直接キーを設定することはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list can have todo items added to it via the push method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151931Z" creationid="shibukawa.yoshiki" creationdate="20150407T151931Z">
        <seg>配列の方はpushメソッドを使ってTodoの項目を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lowest level rendering method</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153918Z" creationid="shibukawa.yoshiki" creationdate="20150412T153918Z">
        <seg>低レベルのレンダリングの方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The macro takes regular Mithril templates like the one below:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144911Z" creationid="shibukawa.yoshiki" creationdate="20150412T144911Z">
        <seg>このマクロは下記のような通常のMithrilのテンプレートを受け取ります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main difference between Angular templates and Mithril templates is that Angular templates follow the tradition of being defined in HTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025135Z" creationid="shibukawa.yoshiki" creationdate="20150420T025135Z">
        <seg>一番大きな違いは、AngularとMithrilのテンプレートです。AngularのテンプレートはHTMLの中に定義するという、伝統的な方法を取っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The methods can be called to dispatch a value to the promise tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134114Z" creationid="shibukawa.yoshiki" creationdate="20150415T134114Z">
        <seg>これらのメソッドを呼ぶと、promise木に値を送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mock object used by Mithril for its own test suite can be found in the development repo.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160830Z" creationid="shibukawa.yoshiki" creationdate="20150416T160830Z">
        <seg>Mithril自身がテストで使っているモックは開発リポジトリの中にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most interesting component is ContactsWidget:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002616Z" creationid="shibukawa.yoshiki" creationdate="20150502T002616Z">
        <seg>もっとも興味深いコンポーネントはContactsWidgetです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most relevant difference is that Vue uses browser features that don't work (and cannot be made to work) in Internet Explorer 8 and lower.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110137Z" creationid="shibukawa.yoshiki" creationdate="20150420T110137Z">
        <seg>Mithrilともっとも異なる点は、ViewがInernet Explorer 8以下では動作せず、代替のない機能を利用している点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most visible difference between React and Mithril is that React's JSX syntax does not run natively in the browser, whereas Mithril's uncompiled templates do.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T100217Z" creationid="shibukawa.yoshiki" creationdate="20150420T100045Z">
        <seg>見た目で一番大きくことなるのは、ブラウザ上でそのままは動作しないJSXという文法です。Mithrilのコンパイルしていないテンプレートはそのまま動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of a route parameter</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170816Z" creationid="shibukawa.yoshiki" creationdate="20150414T170816Z">
        <seg>ラウトパラメータの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the querystring key that defines the name of the callback function to be called by the response.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014619Z" creationid="shibukawa.yoshiki" creationdate="20150415T014619Z">
        <seg>レスポンス受け取るコールバック関数を定義する、クエリー文字列の名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new strategy will apply to the next scheduled redraw, if any.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T130855Z" creationid="shibukawa.yoshiki" creationdate="20150416T130855Z">
        <seg>これを設定すると、次にスケジュールされている再描画の時点から、新しい方法が適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next step is to write a view so users can interact with the application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040836Z" creationid="shibukawa.yoshiki" creationdate="20150502T040836Z">
        <seg>次に、ユーザとアプリケーションがインタラクションするためのビューを書きましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The observer pattern</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180155Z" creationid="shibukawa.yoshiki" creationdate="20150501T180155Z">
        <seg>オブザーバパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only reason I talked about partial application here was to make you aware of that technique, since it becomes useful when dealing with parameterized event handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152718Z" creationid="shibukawa.yoshiki" creationdate="20150408T152718Z">
        <seg>部分適用を使って説明したのは、単にこのようなテクニックが使えるということを紹介する目的でした。これを使うと、パラメータを持つイベントハンドラの可能性が広がります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only reasonable course of action to prevent the potential null reference exceptions in this case is to add the existence check in the source code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172853Z" creationid="shibukawa.yoshiki" creationdate="20150415T172853Z">
        <seg>このような問題を防ぐ唯一の方法は、null参照例外が発生する可能性のあるすべての箇所に存在チェックを追加する方法しかありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional controller function creates an object that may be used in the following recommended ways:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061513Z" creationid="shibukawa.yoshiki" creationdate="20150502T061513Z">
        <seg>オプションのcontroller関数は、次のように使われるオブジェクトを作成することが期待されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other side of the coin is still supported: if a developer needs to signal an exceptional condition within a promise callback, they can manually throw a new Error (for example, if a validation rule failed, and there should be an error message displayed to the user).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173349Z" creationid="shibukawa.yoshiki" creationdate="20150415T173349Z">
        <seg>もちろん、コインの反対側の標準のPromise/A+の仕様もサポートされています。バリデーションの失敗があってエラーメッセージを表示しなければならない場合など、開発者がpromiseのコールバックの中で例外の発生を知らせなければならない場合は、new Errorで作成した例外を投げて、それを受け取ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The params in this doc refer to properties of the `ctrl` argument
@param {Object} data - the data with which to populate the &lt;option&gt; list
@param {number} value - the id of the item in `data` that we want to select
@param {function(Object id)} onchange - the event handler to call when the selection changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021530Z" creationid="shibukawa.yoshiki" creationdate="20150412T014315Z">
        <seg>このドキュメントのパラメータは、`ctrl`引数のプロパティです
@param {Object} data - &lt;option&gt;リストを実行したいデータ
@param {number} value - `data`内の、選択したいアイテムのID
@param {function(Object id)} onchange - 選択が変更された時に呼び出されるイベントハンドラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The performance tests in the homepage show execution times for parsing and evaluation of Mithril's code, compared to some popular frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113646Z" creationid="shibukawa.yoshiki" creationdate="20150417T113646Z">
        <seg>ホームページのパフォーマンステストでは、Mithrilと他の有名なフレームワークで、コードのパースと評価にかかる時間の比較をしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The promise object is actually a getter-setter function that gets populated when the promise is fulfilled.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135159Z" creationid="shibukawa.yoshiki" creationdate="20150415T135159Z">
        <seg>promiseオブジェクトは実際のgetter-setter関数であるため、promiseが果たされると、値が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The promise of the deferred object that is resolved when all input promises have been resolved</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180934Z" creationid="shibukawa.yoshiki" creationdate="20150415T180934Z">
        <seg>入力に渡されたすべてのpromiseが解決したときに解決されるpromise。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason Mithril waits for all asynchronous services to complete before redrawing is to avoid wasteful browser repaints, and to minimize the need for null reference checks in templates.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154844Z" creationid="shibukawa.yoshiki" creationdate="20150416T154844Z">
        <seg>Mithrilがすべての非同期サービスの待ち合わせをするのは、何度もムダなブラウザ再描画を行わないようにしたり、テンプレート内でnull参照チェックを行う回数を減らす、という理由によるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response object (or the child items if this object is an Array) will be passed as a parameter to the class constructor defined by type</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013750Z" creationid="shibukawa.yoshiki" creationdate="20150415T013750Z">
        <seg>レスポンスオブジェクト、もしくはレスポンスが配列の場合はその子供は、typeで定義されているクラスコンストラクタに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the code can be implemented using idioms we already covered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153535Z" creationid="shibukawa.yoshiki" creationdate="20150408T153535Z">
        <seg>残りのコードは、これまで説明してきたテクニックで書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of the controller function is passed to the view as its first argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072010Z" creationid="shibukawa.yoshiki" creationdate="20150502T072010Z">
        <seg>controller関数の返り値は、view関数の最初の引数として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of the controller function is passed to the view function as its first argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125510Z" creationid="shibukawa.yoshiki" creationdate="20150502T125510Z">
        <seg>controller関数の返り値は、view関数の最初の引数として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of the view function is merely a plain Javascript data structure that represents a DOM tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072424Z" creationid="shibukawa.yoshiki" creationdate="20150502T072424Z">
        <seg>ビュー関数の返り値はDOMを表現したJavaScriptのデータ構造です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned VirtualElement is a Javascript data structure that represents the DOM element to be rendered by m.render</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160555Z" creationid="shibukawa.yoshiki" creationdate="20150413T160555Z">
        <seg>返されるVirtualElementは、DOMエレメントを表すデータ構造です。このデータ構造はm.renderを通じてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned getter-setter also implements the promise interface (also known as a thennable): this is the mechanism you should always use to queue operations to be performed on the data from the web service.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015523Z" creationid="shibukawa.yoshiki" creationdate="20150410T015523Z">
        <seg>返されるgetter-setterはpromiseのインタフェース(thennableとも呼ばれる)を持っています。この機能は、ウェブサービスからデータが帰ってきた後の操作をキューイングするのに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned getter-setter can be thought of as a box: you can pass this reference around cheaply, and you can "unwrap" its value when needed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014906Z" creationid="shibukawa.yoshiki" creationdate="20150410T014906Z">
        <seg>getter-setterを返すことは参照を安いコストでコード内に渡すことができて、値が必要になったときにデータの実体を取り出すことができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned string is a String object instance (as opposed to a string primitive) containing the same HTML content, and exposing a flag property for internal use within Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015545Z" creationid="shibukawa.yoshiki" creationdate="20150416T015545Z">
        <seg>返される文字列は文字列オブジェクトのインスタンス(文字列プリミティブではない)で、同じHTMLコンテンツと、Mithril内部で使用するフラグ属性を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned window is the same as what is passed in.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T162202Z" creationid="shibukawa.yoshiki" creationdate="20150416T162154Z">
        <seg>引数に渡されたのと同じwindowを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The root DOM element in a component's view must not be changed during the lifecycle of the component, otherwise undefined behavior will occur.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095939Z" creationid="shibukawa.yoshiki" creationdate="20150502T095939Z">
        <seg>コンポーネントのビューのルートのDOMエレメントはコンポーネントのライフサイクル内で変更してはいけません。未定義の動作をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The route to redirect to if the current URL does not match any of the defined routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T155753Z" creationid="shibukawa.yoshiki" creationdate="20150414T155753Z">
        <seg>現在のURLが、どの定義されたラウトにもマッチしなかった時にリダイレクトされラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The route to redirect to.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171417Z" creationid="shibukawa.yoshiki" creationdate="20150414T171417Z">
        <seg>リダイレクト先のラウト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second one has a data binding to the description getter-setter of the Todo class instance.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153318Z" creationid="shibukawa.yoshiki" creationdate="20150408T153318Z">
        <seg>2つ目のタグは、Todoクラスのインスタンスdescription getter-setterへのバインディングが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second one is called if it completes with an error.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175019Z" creationid="shibukawa.yoshiki" creationdate="20150414T175019Z">
        <seg>2つ目のパラメータはエラーなく完了したときに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second parameter is called if it completes with an error.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124846Z" creationid="shibukawa.yoshiki" creationdate="20150410T124846Z">
        <seg>2つ目のパラメータはエラーなく完了したときに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The serialized representation of the input data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171011Z" creationid="shibukawa.yoshiki" creationdate="20150414T171011Z">
        <seg>入力データのシリアライズ化表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest server-side setup possible to support pathname mode is to serve the same content regardless of what URL is requested.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012822Z" creationid="shibukawa.yoshiki" creationdate="20150410T012822Z">
        <seg>pathnameモードを使用するためのサーバ設定の中で、一番簡単な方法は、どのURLが要求されても同じコンテンツを返すようにする方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest use case of this feature is to implement functional value assignment via m.prop (i.e. the same thing as above).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015909Z" creationid="shibukawa.yoshiki" creationdate="20150410T015842Z">
        <seg>この機能のもっとも簡単な使い方は、m.propを使って関数型的な値の割り当てを行うことです(上記のコードと等価です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string johndoe is bound to the :userID parameter, which can be retrieved programmatically in the controller via m.route.param("userID").</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004107Z" creationid="shibukawa.yoshiki" creationdate="20150410T003958Z">
        <seg>johndoeという文字列が:userIDパラメータに結び付けられます。このパラメータは、コントローラ内でm.route.param("userID")というAPI呼び出しをするとプログラムから参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The table lists all the existing to-dos, if any.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153940Z" creationid="shibukawa.yoshiki" creationdate="20150408T153940Z">
        <seg>もし既存のToDoがある場合は、既存のすべてのToDoが表形式で出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The template is rendered as a child of the implicit &lt;html&gt; element of the document.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153807Z" creationid="shibukawa.yoshiki" creationdate="20150408T153807Z">
        <seg>テンプレートは暗黙の&lt;html&gt;要素としてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The text input saves its value to the todo.vm.description getter-setter we defined earlier.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153841Z" creationid="shibukawa.yoshiki" creationdate="20150408T153841Z">
        <seg>テキスト入力は、値を、以前定義したtodo.vm.description getter-setter に保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The thennable mechanism is intended to be used in three ways:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123530Z" creationid="shibukawa.yoshiki" creationdate="20150410T123530Z">
        <seg>thennableの仕組みは主に以下の3ヶ所で使われることを想定しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third argument for config allows you to map data to a virtual DOM element in a way that persists across redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125558Z" creationid="shibukawa.yoshiki" creationdate="20150413T125558Z">
        <seg>configの3番目の引数を使うと、再描画時に仮想のDOM要素を保持しておくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tool allows you to write code like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013900Z" creationid="shibukawa.yoshiki" creationdate="20150417T013900Z">
        <seg>このツールを使うと、次のようなコードが書けます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unwrapped data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013018Z" creationid="shibukawa.yoshiki" creationdate="20150415T013018Z">
        <seg>unwrapされたデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The utility method m() creates virtual DOM elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004251Z" creationid="shibukawa.yoshiki" creationdate="20150408T004251Z">
        <seg>m()というユーティリティ関数はvirtual DOMの要素を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value that maps to the parameter specified by key</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170834Z" creationid="shibukawa.yoshiki" creationdate="20150414T170834Z">
        <seg>keyにマップされたパラメータの値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value that populates the returned getter-setter before the request completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012356Z" creationid="shibukawa.yoshiki" creationdate="20150415T012356Z">
        <seg>リクエスト完了前に、この関数が返すgetter-setterが内部で保持する初期値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values that replace the dynamic parameters in a URL are available via m.route.param()</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165328Z" creationid="shibukawa.yoshiki" creationdate="20150414T165328Z">
        <seg>URLの中で動的パラメータを置き換えた値は、m.route.param()を通じて取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The vast majority of times, it's advisable to use m.mount instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100346Z" creationid="shibukawa.yoshiki" creationdate="20150502T100220Z">
        <seg>ほとんどの場合は、代わりにm.mountを使うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The view function is run again whenever a redraw is required (i.e. whenever event handlers are triggered by user input).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072719Z" creationid="shibukawa.yoshiki" creationdate="20150502T072719Z">
        <seg>ユーザ入力イベントのハンドラが起動された時など、再描画が必要な時にview関数は何度も呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The virtual DOM data structure to which the config is applied to</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140052Z" creationid="shibukawa.yoshiki" creationdate="20150502T140052Z">
        <seg>configを適用する仮想DOMデータ構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The virtual DOM diffing algorithm has a weakness: a naive diff is not aware of the identity of DOM elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141044Z" creationid="shibukawa.yoshiki" creationdate="20150413T141006Z">
        <seg>仮想DOMの差分検知アルゴリズムには、DOM要素の厳密な同一性について判断できないという欠点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The way the redrawing engine defers redrawing is by keeping an internal counter that is incremented by m.startComputation and decremented by m.endComputation.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190021Z" creationid="shibukawa.yoshiki" creationdate="20150411T190021Z">
        <seg>再描画エンジンは、内部のカウンタを使って再描画のタイミングを遅らせます。カウンタはm.startComputationを呼び出すとインクリメントされ、m.endComputationを呼び出すとデクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, to use Mithril, point a script tag to the downloaded file:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T170149Z" creationid="shibukawa.yoshiki" creationdate="20150407T170149Z">
        <seg>Mithrilを使う場合には、scriptタグを使って、ダウンロードしたファイルを参照します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are different ways to organize components that can side-step the need for multiple redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094012Z" creationid="shibukawa.yoshiki" creationdate="20150502T094012Z">
        <seg>再描画が何度か走るのを避けるコンポーネントの組み立て方もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a couple of reasons why Mithril runs callbacks synchronously.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140627Z" creationid="shibukawa.yoshiki" creationdate="20150415T140627Z">
        <seg>Mithrilがコールバックを同期で実行しているにはいくつか理由があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a few other technical caveats when nesting components:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095608Z" creationid="shibukawa.yoshiki" creationdate="20150502T095608Z">
        <seg>コンポーネントのネスト時には、いくつか技術的な制約があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a lot of different Javascript frameworks and evaluating their merits and shortcomings can be a daunting task.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015752Z" creationid="shibukawa.yoshiki" creationdate="20150417T015752Z">
        <seg>JavaScriptのフレームワーク同士で比較しても数多くの相違点があります。それぞれのフレームワークのメリット、欠点を評価するのは骨の折れる仕事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are some important semantic caveats for m.redraw.strategy("none") that you should be aware of: Setting the strategy to "none" only affects synchronous redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150506Z" creationid="shibukawa.yoshiki" creationdate="20150416T150411Z">
        <seg>注意すべきこととしては、m.redraw.strategy("none") で戦略を"none"に設定しても、そのフレームで同期的に行われる再描画にしか効果がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three ways to render a component:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071629Z" creationid="shibukawa.yoshiki" creationdate="20150502T071629Z">
        <seg>コンポーネントを表示する方法は3通りあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two static methods: list for retrieving a list of contacts, and save to save a single contact.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T224217Z" creationid="shibukawa.yoshiki" creationdate="20150501T224217Z">
        <seg>これらには、データのリストを取得するlistメソッドと、単体の連絡先を取得するsaveメソッドという2つの静的メソッドがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are, however, some limitations to the diff algorithm that require you to add key attributes in some edge cases.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T020315Z" creationid="shibukawa.yoshiki" creationdate="20150416T020315Z">
        <seg>しかし、いくつかの特殊なケースをうまく処理するために、差分検知アルゴリズムにkey属性を渡す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a number of ways to improve Mithril performance for the rare cases where pages are too complex for their own good.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142320Z" creationid="shibukawa.yoshiki" creationdate="20150412T142320Z">
        <seg>ページがその機能を実装するために複雑すぎる状況になっているという状況は稀ですが、その場合にMithrilのパフォーマンスを改善する方法はいくつｋもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a tool called MSX by Jonathan Buchanan that allows you to write templates using HTML syntax, and then automatically compile them to Javascript when files change.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013750Z" creationid="shibukawa.yoshiki" creationdate="20150417T013750Z">
        <seg> Jonathan Buchananが作成したMSX というツールがあります。これを使うとHTMLの文法を使ったテンプレートが作成できます。ファイルを変更すると自動でJavaScriptにコンパイルします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's a type definition file that you can use to add Mithril support to Typescript</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014314Z" creationid="shibukawa.yoshiki" creationdate="20150417T014314Z">
        <seg>TypeScriptにMithrilサポートを追加する型定義ファイルもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's just one caveat: while simply initializing multiple "islands" in this fashion works, their initialization calls are not aware of each other and can cause redraws too frequently.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141104Z" creationid="shibukawa.yoshiki" creationdate="20150412T140926Z">
        <seg>１つだけ注意すべきことがあるとしたら、単純にこれら複数の「島」を初期化してしまった時に、それぞれの初期化呼び出しがお互いを認識せずに、再描画処理が想定上に発生してしまう、ということを避けなければならない、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's no idiomatic way to organize jQuery code in an MVC pattern and many frameworks were created specifically to overcome that shortcoming.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015357Z" creationid="shibukawa.yoshiki" creationdate="20150420T015357Z">
        <seg>MVCパターンをjQueryを使って実現するための共通の書き方といったものは存在しません。そのため、この足りないところを補うために数多くのフレームワークが作られました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's no need for a parse-and-compile pre-processing step to turn strings containing HTML + templating syntax into working DOM elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013833Z" creationid="shibukawa.yoshiki" creationdate="20150409T013833Z">
        <seg>HTMLまじりの複雑な文字列を表示前に自前にパースしてコンパイルして、実際に表示されるDOM要素にするという大掛かりな仕事が必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, using the computation methods is recommended in order to reduce the amount of intermediate redraws that would otherwise occur as multiple asynchronous services are resolved.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T115205Z" creationid="shibukawa.yoshiki" creationdate="20150502T115205Z">
        <seg>そのため、複数の非同期アクセスが完了する前に再描画が即座に行われないようにするために、computationメソッドを使うほうが推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you should ensure that templates have null checks in place to account for the possibility of variables being uninitialized when the forced redraw occurs.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130153Z" creationid="shibukawa.yoshiki" creationdate="20150502T130153Z">
        <seg>そのため、強制再描画時に、未初期化の変数アクセスが発生しないようにテンプレートでのnullチェックを確実に行うようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you should not use config to modify controller and model values, if you expect these changes to render immediately.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125028Z" creationid="shibukawa.yoshiki" creationdate="20150413T125028Z">
        <seg>このため、コントローラやモデルの値など、すぐにレンダリングに反映したい変更をするのにconfigを使うのは適しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These components are designed to not interface with other components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T014356Z" creationid="shibukawa.yoshiki" creationdate="20150502T014356Z">
        <seg>これらのコンポーネントはお互いのコンポーネントとやりとりをするようには設計されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions are internally called by Mithril when you initialize a component via m.mount or m.route, and when you trigger event handlers that were created within templates with m().</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125801Z" creationid="shibukawa.yoshiki" creationdate="20150502T125801Z">
        <seg>これらの関数は、m.mountやm.routeを通じてコンポーネントを初期化したり、m()を使って作られたテンプレート内のイベントハンドラを起動したときに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These hooks allow you to unwrap different parts of the response data depending on whether it succeed or failed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174508Z" creationid="shibukawa.yoshiki" creationdate="20150410T174508Z">
        <seg>これらのフックを使うと、レスポンスが成功したかどうかによって、レスポンスデータの違う箇所をアンラップできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods are only intended to be used by people who are writing libraries that do things asynchronously, or when calling vanilla javascript asynchronous functions from template config functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153059Z" creationid="shibukawa.yoshiki" creationdate="20150416T153059Z">
        <seg>これらのメソッドは非同期のタスクを実行するライブラリを作成したり、素のJavaScriptの非同期関数をテンプレートのconfig関数から呼び出す人のみが使うことを想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods assume that the AJAX responses return contacts in JSON format, containing the same fields as the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T000018Z" creationid="shibukawa.yoshiki" creationdate="20150502T000018Z">
        <seg>このlistメソッドは、AJAXのレスポンスとして、クラスと同じ名前のフィールドを含むJSON形式で連絡先情報を返してくることを想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two functions are here to illustrate the ability to expose APIs to component consumers that complement the component's user interface.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T032643Z" creationid="shibukawa.yoshiki" creationdate="20150502T032643Z">
        <seg>これらの2つの関数は、コンポーネント利用者にAPIを公開することで、コンポーネントのインタフェースを補完できることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They allow developers to encapsulate functionality into reusable units.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061224Z" creationid="shibukawa.yoshiki" creationdate="20150502T061224Z">
        <seg>コンポーネントの仕組みに従うってコーディングすると、再利用可能な、カプセル化された部品を作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can be initialized and used like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150835Z" creationid="shibukawa.yoshiki" creationdate="20150407T150835Z">
        <seg>これらのクラスは次のように初期化して使います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They do this because once the element is ready (and thus, has an accessible innerHTML property), their rendering engines cannot backtrack to the parsing-stage if the script calls something like document.write("&lt;/body&gt;").</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014356Z" creationid="shibukawa.yoshiki" creationdate="20150416T014356Z">
        <seg>一度HTMLエレメントの読み込みが完了して、 innerHTML プロパティにアクセス可能になった後は、スクリプトがdocument.write("&lt;/body&gt;")といった関数呼び出しをしたとしても、パースの段階に戻ることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Third-party promise library support</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133735Z" creationid="shibukawa.yoshiki" creationdate="20150414T133735Z">
        <seg>サードパーティのPromiseライブラリのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This if statement is important, because this function may be called multiple times by Mithril's auto-redrawing system and we don't want to re-initialize select2 at every redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133941Z" creationid="shibukawa.yoshiki" creationdate="20150412T133941Z">
        <seg>この関数はMithrilの自動再描画システムから何度も呼び出されますし、描画のたびに何度もselect2を初期化するのはうれしくないため、このif文は大切です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows getter-setters to be passed directly as parameters to m.request, for example.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135657Z" creationid="shibukawa.yoshiki" creationdate="20150414T135657Z">
        <seg>これにより、getter-setterはそのままm.requestなどのパラメータとして渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows named anchors (i.e. &lt;a href="#top"&gt;Back to top&lt;/a&gt;, &lt;a name="top"&gt;&lt;/a&gt;) to work on the page, but routing changes causes page refreshes in IE8, due to its lack of support for history.pushState.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005103Z" creationid="shibukawa.yoshiki" creationdate="20150410T005103Z">
        <seg>このモードを使うと、名前付きのアンカー(例えば、&lt;a href="#top"&gt;トップに戻る&lt;/a&gt;、&lt;a name="top"&gt;&lt;/a&gt;)を使うことができますが、IE8の場合はhistory.pushStateのサポートがないため、ページリフレッシュが発生してしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows named anchors (i.e. &lt;a href="#top"&gt;Back to top&lt;/a&gt;, &lt;a name="top"&gt;&lt;/a&gt;) to work on the page, but routing changes causes page refreshes in IE8, due to its lack of support for history.pushState.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165955Z" creationid="shibukawa.yoshiki" creationdate="20150414T165955Z">
        <seg>このモードを使うと、名前付きのアンカー(例えば、&lt;a href="#top"&gt;トップに戻る&lt;/a&gt;、&lt;a name="top"&gt;&lt;/a&gt;)を使うことができますが、IE8の場合はhistory.pushStateのサポートがないため、ページリフレッシュが発生してしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows swapping the implementation of the saveContact handler without changing the ContactForm component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031718Z" creationid="shibukawa.yoshiki" creationdate="20150502T031718Z">
        <seg>これにより、ContactFormコンポーネントを変更することなく、saveContactハンドラの実装を変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows the developer to abstract away any aspect of the template at will.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002827Z" creationid="shibukawa.yoshiki" creationdate="20150413T002827Z">
        <seg>これによって開発者から見てテンプレートに対してあらゆる抽象化が行えるようなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows us to maintain input focus and plugin state correctly.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141807Z" creationid="shibukawa.yoshiki" creationdate="20150413T141807Z">
        <seg>これを使うと、入力のフォーカスや、プラグインの状態を正しく維持することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to implement optimizations that avoid creating virtual DOM trees in favor of their cached counterparts, if you know they have not changed between redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123810Z" creationid="shibukawa.yoshiki" creationdate="20150416T123810Z">
        <seg>もし再描画間で差分が発生していないことが明示的にわかっている場合は、キャッシュと対になる仮想DOMツリーの生成の手間が省けるため、処理を最適化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also applies for asynchronous functions called from 3rd party libraries or from vanilla javascript, if they call this pair of functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154704Z" creationid="shibukawa.yoshiki" creationdate="20150416T154704Z">
        <seg>サードパーティのライブラリや、ネイティブJavaScriptのコードから非同期関数を使う時も、これらの関数のペアを呼ぶ場合は同じルールが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach means that developers can get discoverable codebases without necessarily getting locked into the framework.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T144943Z" creationid="shibukawa.yoshiki" creationdate="20150417T144943Z">
        <seg>これにより、開発者はフレームワークにロックインされることなく、オープンなコードベースを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This architecture can yield highly flexible and reusable code, but flexibility can also increase the cognitive load of the system (for example, you need to look at both the top-level module and ContactList in order to know what is the data being displayed (and how it's being filtered, etc).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T012919Z" creationid="shibukawa.yoshiki" creationdate="20150502T012919Z">
        <seg>このアーキテクチャにすることで、高い柔軟性と再利用性の高井コードが得られますが、柔軟性が高いということはシステムを理解する負荷が高まるということです。どのようにデータが表示されるかを知るには、トップレベルのモジュールと、ContactListの2つを見る必要があります。場合によってはどのようにフィルタされるかを知る必要もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This binds the description getter-setter to the text input.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014947Z" creationid="shibukawa.yoshiki" creationdate="20150408T014947Z">
        <seg>このコードにより、description getter-setterとテキスト入力が接続されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be done by simply calling m.startComputation at the beginning, and m.endComputation at the end of the function.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134514Z" creationid="shibukawa.yoshiki" creationdate="20150412T134514Z">
        <seg>統合するには関数の先頭でm.startComputationを呼び、関数の最後でm.endComputationを呼び出すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can get noticeably bulky when you look at thing like collections: you often need to implement insertion code and deletion code, in addition to a "draw everything" routine for performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014351Z" creationid="shibukawa.yoshiki" creationdate="20150420T014351Z">
        <seg>「すべてを描画する」ルーチンに加えて、パフォーマンスを向上させるために、部品を追加する、削除するといったコードの実装が必要で、コード量がとても大きくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This comes with several benefits (proper error reporting, proper lexical scoping, etc.), while still allowing HTML syntax to be used via a preprocessor tool</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041323Z" creationid="shibukawa.yoshiki" creationdate="20150502T041323Z">
        <seg>このことには、エラー発生時のメッセージが分かりやすいとか、適切なレキシカルスコープが使えるなどのさまざまな利点があります。また、HTML文法を使うことができるプリプロセッサツールも利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This cost might be less of a concern in single page apps, but not necessarily if the app is typically opened simultaneously in multiple tabs, or run on less powerful devices.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113548Z" creationid="shibukawa.yoshiki" creationdate="20150417T113548Z">
        <seg>このコストは、シングルページアプリケーションでは影響は小さくなりますが、複数タブで同時に開かれたり、性能の低いデバイスで実行される場合はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This creates a new function with the parameter already set.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151345Z" creationid="shibukawa.yoshiki" creationdate="20150408T151345Z">
        <seg>このメソッドを使うと、パラメータがあらかじめ設定された、新しい関数を作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This design decision comes from experience with DRY and the "bus factor" of large, highly relational model layers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032507Z" creationid="shibukawa.yoshiki" creationdate="20150421T014921Z">
        <seg>このデザインの原則はDRYと、リレーショナルモデル層のトラックナンバーの大きさから来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This deviation from the spec is there to make it easier for developers to find common logical errors such as typos that lead to null reference exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172449Z" creationid="shibukawa.yoshiki" creationdate="20150415T172340Z">
        <seg>仕様と異なるこの動作により、タイプミスによるnull参照例外などの一般的なエラーを開発者が簡単に見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that data being accessed in the view isn't nullable as a result of asynchronous data not being available yet.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235932Z" creationid="shibukawa.yoshiki" creationdate="20150414T235932Z">
        <seg>この仕組により、ビューが非同期データのデータにアクセスするときも、データがまだ利用できないために表示がおかしくなる、ということがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example is also available as a jsFiddle.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163514Z" creationid="shibukawa.yoshiki" creationdate="20150408T163514Z">
        <seg>このサンプルは、jsFiddleでも確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This flag is false the first time it runs on an element, and true on redraws that happen after the element has been created.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155231Z" creationid="shibukawa.yoshiki" creationdate="20150413T155231Z">
        <seg>そのエレメントに対して初めて実行される時はこのフラグがfalseに設定され、エレメントの作成後に再描画が発生してそこから呼ばれる時はtrueになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function initializes the vm object with three members: list, which is simply an array, description, which is an m.prop getter-setter function with an empty string as the initial value, and add, which is a method that adds a new Todo instance to list if an input description getter-setter is not an empty string.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T162621Z" creationid="shibukawa.yoshiki" creationdate="20150407T162621Z">
        <seg>このコードは、3つのメンバーを持つvmオブジェクトを初期化しています。単純な配列のlist、初期値の文字列として空の文字列を渡されたm.propのgetter-setter関数であるdescription、入力のdescription getter-setterが空の文字列でないときに、新しいTodoインスタンスを,listに登録するadd関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function overwrites the reference to the window object that is used internally by Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160616Z" creationid="shibukawa.yoshiki" creationdate="20150416T160616Z">
        <seg>この関数を使うと、Mithril内部で使われるwindowオブジェクトを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function will be called with the value of the defined property as an argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140918Z" creationid="shibukawa.yoshiki" creationdate="20150414T140918Z">
        <seg>この関数は引数として定義されたプロパティの値とともに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This handler method can be assigned to properties like onclick, or passed as callbacks to addEventListener.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T141043Z" creationid="shibukawa.yoshiki" creationdate="20150414T141043Z">
        <seg>このハンドラメソッドは、onclickなどのプロパティに設定したり、addEventListenerにコールバックとして渡すことができるメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the benefit of cleaner syntax for writing static text, but it comes with the disadvantage of features getting awkwardly tied to HTML syntax, as well as providing poor debugging support.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025712Z" creationid="shibukawa.yoshiki" creationdate="20150420T025712Z">
        <seg>この方式は静的なテキストを作成するのは書きやすいというメリットがありますが、HTMLの文法を密結合してしまっている欠点がありますし、デバッグもしやすいとは言えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This idiom can also be used to attach onprogress event handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182339Z" creationid="shibukawa.yoshiki" creationdate="20150414T182339Z">
        <seg>この方法は、onprogressを付与するのにも使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a convenience method to compose virtual elements that can be rendered via m.render().</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235212Z" creationid="shibukawa.yoshiki" creationdate="20150412T235212Z">
        <seg>この関数は仮想DOM要素を組み立てるための簡単なインタフェースを提供する関数です。この仮想DOM要素はm.render()メソッドを使ってレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a form of lazy evaluation: it allows us to say "use this value later, when the event handler gets called".</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151857Z" creationid="shibukawa.yoshiki" creationdate="20150408T151857Z">
        <seg>このような形式を遅延評価(lazy evaluation)と呼びます。これを使うと、「イベントハンドラが呼ばれて、本当に必要になったタイミングまで値の取得を遅らせよう」ということができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a getter-setter factory utility.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133832Z" creationid="shibukawa.yoshiki" creationdate="20150414T133832Z">
        <seg>この関数は、getter-setterのファクトリ関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a high-level utility for working with web services, which allows writing asynchronous code relatively procedurally.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174738Z" creationid="shibukawa.yoshiki" creationdate="20150414T174738Z">
        <seg>この関数はウェブサービスと協調するための高度なユーティリティです。この機能を使うと、非同期で動作するコードを、比較的手続き的に記述することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a low-level method in Mithril.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015830Z" creationid="shibukawa.yoshiki" creationdate="20150415T015830Z">
        <seg>これは、Mithrilの低レベルメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a problem particularly for frameworks that had breaking changes in the past: It's common to find answers in StackOverflow that are out-of-date and no longer work with the latest version of said frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114247Z" creationid="shibukawa.yoshiki" creationdate="20150417T114247Z">
        <seg>これは特に、過去の大きな変更があると問題になります。StackOverflowで見つけた解答が最新版のフレームワークでは動作しないということがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an event handler factory.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140138Z" creationid="shibukawa.yoshiki" creationdate="20150414T140138Z">
        <seg>この関数はイベントハンドラを生成するファクトリ関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is good for framework adoption, but not necessarily ideal for team scalability and codebase discoverability.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020356Z" creationid="shibukawa.yoshiki" creationdate="20150420T020356Z">
        <seg>これはフレームワーク適用の柔軟性を高める点では悪くないのですが、開発チームのスケーラビリティやコードベースの探索のしやすさの点で理想的とはいえません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is in stark contrast to the ActiveRecord pattern of other frameworks, where model entities are largely object representations of database entities and these entities are manipulated in controllers in an ad-hoc field-by-field fashion, and then "committed" via a save method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032841Z" creationid="shibukawa.yoshiki" creationdate="20150421T032841Z">
        <seg>これは、他のフレームワークのActiveRecordパターンと大きく異なっています。ActiveRecordパターンのモデルエンティティは、データベースのエンティティのオブジェクト表現という側面が強く、アドホックにコントローラ内でフィード操作されて、最後にsaveメソッドでコミットされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known, appropriately, as the observer pattern.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025130Z" creationid="shibukawa.yoshiki" creationdate="20150502T025130Z">
        <seg>これはオブザーバパターンと呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is perfectly valid: there are three asynchronous computations pending after the jQuery.when method is called, and therefore, three pairs of m.startComputation / m.endComputation in play.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010103Z" creationid="shibukawa.yoshiki" creationdate="20150412T010103Z">
        <seg>このコードは完璧に正しいコードです。jQuery.whenが呼ばれた後に、そこから3組のm.startComputation / m.endComputation呼び出しがあるため、3つの非同期描画が遅延されて、バッチ処理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the default for going from one route to another.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143321Z" creationid="shibukawa.yoshiki" creationdate="20150416T143321Z">
        <seg>この動作はラウト間の遷移時のデフォルトの動作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the most potentially expensive method in Mithril and should not be used at a rate faster than the rate at which the native requestAnimationFrame method fires (i.e. the rate at which browsers are comfortable calling recurring rendering-intensive code).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020309Z" creationid="shibukawa.yoshiki" creationdate="20150421T020309Z">
        <seg>m.redrawは、Mithrilの中でもっとも重い処理になりえる関数です。ネイティブのrequestAnimationFrameメソッドが起動されるよりも早いペースで呼び出すべきではありません。このメソッドは、レンダリングに関するコードを実行するのに、ブラウザにとって一番快適なインターバルを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the recommended way for views and models to exchange data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062126Z" creationid="shibukawa.yoshiki" creationdate="20150502T062126Z">
        <seg>これがMithrilの推奨する、ビューとモデルのデータの交換方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the value of the defined DOM element's property.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140943Z" creationid="shibukawa.yoshiki" creationdate="20150414T140943Z">
        <seg>これは定義されたDOMエレメントの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is to make the method compatible with virtual DOM elements' config attribute (see m())</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172538Z" creationid="shibukawa.yoshiki" creationdate="20150414T172538Z">
        <seg>これは、仮想DOMエレメントconfig属性に対して、メソッドの互換性を維持するために使用します。m()を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for re-running ajax calls for different model entities.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085524Z" creationid="shibukawa.yoshiki" creationdate="20150502T085524Z">
        <seg>これは違うモデルエンティティに対してAJAX呼び出しを再実行した場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful if there are cleanup tasks that need to be run when an element is destroyed (e.g. clearing setTimeout's, etc)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130429Z" creationid="shibukawa.yoshiki" creationdate="20150413T130429Z">
        <seg>エレメントが破棄されるときに、なんらかの後片付けのタスクを実行したい時にはこの機能は便利です。例えば、setTimeoutを辞めるといったタスクがあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful when a config instantiates 3rd party classes and accesses the instance on redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125737Z" creationid="shibukawa.yoshiki" creationdate="20150413T125737Z">
        <seg>configのコールバックがサードパーティのクラスのインスタンスを作成したり、再描画時にそのインスタンスにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful when the relevant data is either in a response header or the status field.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013414Z" creationid="shibukawa.yoshiki" creationdate="20150415T013414Z">
        <seg>このオプションはレスポンスヘッダやステータスフィールドに必要なデータがある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful when using the background option, in order to avoid the need for null checks in views that may be attempting to access the returned getter-setter before the asynchronous request resolves.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012521Z" creationid="shibukawa.yoshiki" creationdate="20150415T012521Z">
        <seg>backgroundオプションを使用するときにこのオプションを使用すると、リクエスト完了前にビューがgetter-setterにアクセスするときにnullチェックを行う手間が減ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful when we want to control access to certain properties in an object, as opposed to exposing all the fields in POJOs (plain old Javascript objects) for arbitrary processing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170524Z" creationid="shibukawa.yoshiki" creationdate="20150410T170524Z">
        <seg>POJO(plain old JavaScript objects)の場合はすべてのフィールドが公開状態になってしまうため、この機能を使うとオブジェクト内のプロパティへのアクセス方法をコントロールしやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful, for example, if you declare a canvas element and want to use the Javascript API to draw:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123454Z" creationid="shibukawa.yoshiki" creationdate="20150413T123454Z">
        <seg>この機能は、例えばcanvasエレメントを作り、JavaScriptの描画APIを使って絵を描く場合などに便利です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful, for example, if you received invalid JSON from the server in production and you want to display a message to the user saying that the server is offline.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181246Z" creationid="shibukawa.yoshiki" creationdate="20150414T181246Z">
        <seg>もしJSONとしては不正なレスポンスをプロダクション環境のサーバから受け取ったとして、ユーザに対してサーバがオフラインであるというメッセージを表示したいとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This key-value map should define a list of HTML attributes and their respective values.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153433Z" creationid="shibukawa.yoshiki" creationdate="20150413T153433Z">
        <seg>キー・バリューのマップはHTML属性とその値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to reason about the state of the UI and to test it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183527Z" creationid="shibukawa.yoshiki" creationdate="20150411T183527Z">
        <seg>これにより、UIの状態や状態のテストが簡単に行えるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes the href behave correctly regardless of which m.route.mode is selected.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013416Z" creationid="shibukawa.yoshiki" creationdate="20150410T013416Z">
        <seg>この書き方を使用すると、どのm.route.modeが選択されていたとしても、期待通りの実行結果が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means it's possible for a view to attempt to use data before it is available.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001641Z" creationid="shibukawa.yoshiki" creationdate="20150415T001641Z">
        <seg>このオプションを有効にすると、データが利用可能になる前にビューがデータにアクセスしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that compiled templates don't need to parse the string in m("div#foo") and they don't incur the cost of the function call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144404Z" creationid="shibukawa.yoshiki" creationdate="20150412T144404Z">
        <seg>コンパイルされたテンプレートを使用する時は、m("div#foo")といった文字列をパースする必要がなく、関数呼び出しのコストは発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that in the code below, the input on screen will overwritten by the model data any time a redraw happens:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015206Z" creationid="shibukawa.yoshiki" creationdate="20150413T015206Z">
        <seg>これはつまり、下記のサンプルのスクリーン上のテキスト入力の値は、モデルデータが変更されるたびに上書きされることを意味しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that just as you are able to bind the value attribute in an &lt;select&gt;, you are also able to bind the selectedIndex property, if needed for whatever reason.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021929Z" creationid="shibukawa.yoshiki" creationdate="20150408T021929Z">
        <seg>&lt;select&gt;タグであれば、value属性と結びつけることもできますし、用途によってはselectedIndexプロパティとバインドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the virtual dom tree may take two or more redraws (depending on how many nested asynchronous components there are) to be fully rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093904Z" creationid="shibukawa.yoshiki" creationdate="20150502T093904Z">
        <seg>これによって非同期のネストされたコンポーネントの数次第で、完全なレンダリングが行われるまでに、何度か仮想DOMツリーの再描画処理が走る可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that typing something on the input and then re-rendering will clobber the text on screen.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015937Z" creationid="shibukawa.yoshiki" creationdate="20150408T015937Z">
        <seg>これは、何かしらのテキストを入力して、再レンダリングが実行されると、スクリーン上のテキストが破棄されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that we are avoiding the creation of the header subtree (and therefore skipping the diff algorithm) altogether, but it also means that dynamic variables will NOT be updated within the header.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124500Z" creationid="shibukawa.yoshiki" creationdate="20150416T124500Z">
        <seg>こうすると、ヘッダーに関するサブツリーが作られなくなり、差分アルゴリズムもスキップしますが、ヘッダ内の動的な変数が更新されることもなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism allows multiple components to be reloaded in response to non-idempotent operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021537Z" creationid="shibukawa.yoshiki" creationdate="20150502T021537Z">
        <seg>この仕組みを使うと、状態を変更させるような操作に対して複数のコンポーネントをリロードさせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism is only intended to be used as a last resort optimization tool.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124016Z" creationid="shibukawa.yoshiki" creationdate="20150416T124016Z">
        <seg>この機能は、パフォーマンスの最適化のための最終手段として用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism is useful to clear timers and unsubscribe event handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T015902Z" creationid="shibukawa.yoshiki" creationdate="20150414T015902Z">
        <seg>タイマーをクリアしたり、イベントハンドラをunsubscribeする場合に、この仕組みが便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method accepts two callbacks which process a value passed to the resolve and reject methods, respectively, and pass the processed value to the returned promise</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175631Z" creationid="shibukawa.yoshiki" creationdate="20150415T175631Z">
        <seg>このメソッドは、resolve、rejectメソッドに渡される値を受け取り、結果のpromiseに格納される値を処理して返す2つのコールバックを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method always returns the value of the internal store, regardless of whether it was updated or not.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140011Z" creationid="shibukawa.yoshiki" creationdate="20150414T140011Z">
        <seg>このメソッドは、値が更新されたかどうかにかかわらず、常に内部ストアの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method flags a string as trusted HTML.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013558Z" creationid="shibukawa.yoshiki" creationdate="20150416T013558Z">
        <seg>このメソッドは文字列に対して信用できるHTMLであるとフラグを立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method generates a DOM tree inside of a given HTML element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015955Z" creationid="shibukawa.yoshiki" creationdate="20150416T015955Z">
        <seg>このメソッドは、DOMツリーを指定されたHTML属性内に定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method gets called every time an exception is thrown inside a promise callback.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180257Z" creationid="shibukawa.yoshiki" creationdate="20150415T180257Z">
        <seg>このメソッドはpromiseコールバックの中で例外が発生するたびに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is meant to be used with a virtual element's config attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013226Z" creationid="shibukawa.yoshiki" creationdate="20150410T013226Z">
        <seg>このメソッドを使うには、 config仮想エレメントのプロパティを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is provided to decouple the browser's event model from the controller/logic model.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140435Z" creationid="shibukawa.yoshiki" creationdate="20150414T140435Z">
        <seg>このメソッドは、ブラウザのイベントモデルと、コントローラ/ロジックモデルを疎結合にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method overloads four different units of functionality:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152555Z" creationid="shibukawa.yoshiki" creationdate="20150414T152555Z">
        <seg>このメソッドは4つの異なる機能をオーバーロードしています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method passes a value to the errorCallback of the deferred object's child promise</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180158Z" creationid="shibukawa.yoshiki" creationdate="20150415T180154Z">
        <seg>このメソッドは、deferredオブジェクトの子のpromiseのerrorCallbackに値を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method passes a value to the successCallback of the deferred object's child promise</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180143Z" creationid="shibukawa.yoshiki" creationdate="20150415T180143Z">
        <seg>このメソッドは、deferredオブジェクトの子のpromiseのsuccessCallbackに値を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method takes a list of promises and returns a promise that resolves when all promises in the input list have resolved.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180614Z" creationid="shibukawa.yoshiki" creationdate="20150415T180533Z">
        <seg>このメソッドはリストに入ったpromiseを受け取り、すべてのpromiseが果たされた時に解決するpromiseを解決します。￥</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option is useful for running operations in the background (i.e. without user intervention).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T011826Z" creationid="shibukawa.yoshiki" creationdate="20150415T011826Z">
        <seg>この操作は、ユーザの操作によらず行われるバックグラウンドの操作を実行する場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option is useful for web services that use uncommon conventions for defining jsonp callbacks (e.g. foo.com/?jsonpCallback=doSomething)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014719Z" creationid="shibukawa.yoshiki" creationdate="20150415T014719Z">
        <seg>foo.com/?jsonpCallback=doSomethingなど、一般的な規約とはことなるjsonpコールバック定義をさせるウェブサービスを章するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This optional compilation tool is merely "icing on the cake" that speeds up the Javascript run-time of templates (which is already fast, even without compilation - see the performance section on the homepage).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144842Z" creationid="shibukawa.yoshiki" creationdate="20150412T144842Z">
        <seg>Mithirilは トップページのパフォーマンスのセクションで既にお見せしているように、コンパイルなどしなくてもすでに高速です。このオプションのコンパイルツールは、いわば「ケーキの上のデコレーション」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This page aims to provide a comparison between Mithril and some of the most widely used frameworks, as well as some of the younger, but relevant ones.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015911Z" creationid="shibukawa.yoshiki" creationdate="20150417T015911Z">
        <seg>このページではMithrilと他のよく使われるフレームワークの違いについて説明します。中には関連しているが、まだまだ若いものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pattern is useful to decouple chains of dependencies (however care should be taken to avoid "come-from hell", i.e. difficulty in following a chains of events because they are too numerous and arbitrarily inter-dependent)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025524Z" creationid="shibukawa.yoshiki" creationdate="20150502T025524Z">
        <seg>このパターンは依存関係の鎖を分離するのに役立ちます。しかし、数多くの内部依存関係を持つことによって、イベントの連鎖を追いかけるのが難しくなる「地獄からやってくる」ケースに陥らないように注意する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This redirects to the URL http://server/#/dashboard/johndoe and yields:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003359Z" creationid="shibukawa.yoshiki" creationdate="20150410T003359Z">
        <seg>これを実行すると、http://server/#/dashboard/johndoeにリダイレクトして、下記のタグを挿入します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rendering technique is known as virtual DOM diffing.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072607Z" creationid="shibukawa.yoshiki" creationdate="20150502T072604Z">
        <seg>このレンダリング技術は仮想DOMの差分検知と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This renders the following markup:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013720Z" creationid="shibukawa.yoshiki" creationdate="20150408T013720Z">
        <seg>このメソッド呼び出しをすると、次のようなマークアップが生成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This returns the portion of the URL determined by m.route.mode (minus the ? or # symbols for the search and hash modes, respectively).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172128Z" creationid="shibukawa.yoshiki" creationdate="20150414T172128Z">
        <seg>この関数は、m.route.modeで決定されるURLのパーツ(マイナス?もしくは#シンボル - それぞれsearchモードとhash モード時)を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This route would be selected if the URL was /path/to/page/1, /path/to/page/test, etc</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T160207Z" creationid="shibukawa.yoshiki" creationdate="20150414T160207Z">
        <seg>このラウとは、/path/to/page/1、/path/to/page/testといったURLが指定された場合に選択されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should be either window or a mock of the window object.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161447Z" creationid="shibukawa.yoshiki" creationdate="20150416T161447Z">
        <seg>この引数はwindowもしくはモックwindowオブジェクト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This special parameter allows you to call methods on the DOM element after it gets created.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123355Z" creationid="shibukawa.yoshiki" creationdate="20150413T123355Z">
        <seg>この特別なパラメータを使うと、DOMエレメントの精製後にその要素に対してメソッドが呼べるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step is meant to be done in the controller layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124319Z" creationid="shibukawa.yoshiki" creationdate="20150410T124319Z">
        <seg>このステップはコントローラレイヤ内で完結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step is meant to be done in the model layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123925Z" creationid="shibukawa.yoshiki" creationdate="20150410T123925Z">
        <seg>このステップはモデルレイヤ内で完結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This step isn't required in order to use Mithril, but it's an easy way to squeeze a little bit more performance out of an application, without the need for code changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143904Z" creationid="shibukawa.yoshiki" creationdate="20150412T143904Z">
        <seg>このステップはMithrilを使う上で必須のものではありませんが、コードを一切変更せずにアプリケーション外で簡単にパフォーマンスを少し向上させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This string should be a CSS rule that represents a DOM element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150546Z" creationid="shibukawa.yoshiki" creationdate="20150413T150546Z">
        <seg>DOMエレメントを表現するCSSルールの文字列を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntax allows you to bind intermediate results before piping them down for further processing, for example:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T020233Z" creationid="shibukawa.yoshiki" creationdate="20150410T020233Z">
        <seg>この文法を使うと、パイプ処理が次の処理を起動する前に中間結果を束縛することができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tool is also available as a Rails gem, created by Jordan Humphreys.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014137Z" creationid="shibukawa.yoshiki" creationdate="20150417T014137Z">
        <seg>このツールは、 Jordan Humphreysが作成したRails gemでも提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This value can be programmatically changed in controllers and event handlers to modify the next redrawing strategy.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152459Z" creationid="shibukawa.yoshiki" creationdate="20150416T152459Z">
        <seg>この値は、コントローラとイベントハンドラの中で設定することができます。これは次に行われるの再描画の戦略にのみ作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will allow the compiler to type-check calls to the Mithril API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014405Z" creationid="shibukawa.yoshiki" creationdate="20150417T014405Z">
        <seg>コンパイラがMithril API呼び出しに対して型チェックが行えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will provide all the polyfills required for the browser.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014706Z" creationid="shibukawa.yoshiki" creationdate="20150417T014706Z">
        <seg>このライブラリはブラウザで必要とされるすべての足りない機能を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid surprises, be sure to change only attribute values, using undefined or null as values if appropriate, rather than conditionally substituting attribute dictionaries altogether.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144324Z" creationid="shibukawa.yoshiki" creationdate="20150413T144324Z">
        <seg>想定外の事態を避けるには、undefinedやnullを使って属性の値だけを変更するようにしてください。条件によって属性の辞書そのものを置き換えるコードは避けましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To compile a file, type:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150219Z" creationid="shibukawa.yoshiki" creationdate="20150412T150219Z">
        <seg>ファイルをコンパイルするには次のようにタイプします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define a list of routes, you need to specify a host DOM element, a default route and a key-value map of possible routes and respective components to be rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135028Z" creationid="shibukawa.yoshiki" creationdate="20150502T135028Z">
        <seg>ラウトを定義する時は、ホストとなるDOM要素と、デフォルトのラウト、あとは遷移する可能性のあるラウトとそれをレンダリングするためのコンポーネントのキー・バリューのマップが必要となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define a list of routes, you need to specify a host DOM element, a default route and a key-value map of possible routes and respective modules to be rendered.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002722Z" creationid="shibukawa.yoshiki" creationdate="20150409T162838Z">
        <seg>ラウトを定義する時は、ホストとなるDOM要素と、デフォルトのラウト、あとは遷移する可能性のあるラウトとそれをレンダリングするためのモジュールのキー・バリューのマップが必要となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To illustrate the difference between Mithril and A+ promises, consider the code below:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140322Z" creationid="shibukawa.yoshiki" creationdate="20150415T140310Z">
        <seg>下記のコードを使用して、MithrilとA+ promisesの違いを紹介します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To implement flow control in Mithril views, we simply use Javascript Array methods:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152856Z" creationid="shibukawa.yoshiki" creationdate="20150408T152849Z">
        <seg>JavaScriptの配列のメソッドを使うだけで、Mithrilのビューでフローコントロールを実装することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To install SweetJS, NodeJS provides a command-line package manager tool.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150153Z" creationid="shibukawa.yoshiki" creationdate="20150412T150153Z">
        <seg>SweetJSをインストールするのに使うコマンドラインのパッケージマネージャは、NodeJSが提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To install it, go to its website and use the installer provided.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150117Z" creationid="shibukawa.yoshiki" creationdate="20150412T150117Z">
        <seg>NodeJSをインストールするには、NodeJSのウェブサイトに行き、提供されているインストーラを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To integrate synchronous code, call m.startComputation at the beginning of the method, and m.endComputation at the end.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193105Z" creationid="shibukawa.yoshiki" creationdate="20150411T193105Z">
        <seg>同期処理のコードと統合する場合は、メソッドの先頭でm.startComputationを呼んで、最後にm.endComputationを呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To maintain the identities of DOM elements, you need to add a key property to the direct children of the array that you're planning to modify.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142044Z" creationid="shibukawa.yoshiki" creationdate="20150413T142044Z">
        <seg>DOM要素の識別子を維持するには、変更したい配列の子供に、keyプロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make JSON-P requests, add the dataType option instead of method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T234822Z" creationid="shibukawa.yoshiki" creationdate="20150414T234756Z">
        <seg>JSONPリクエストを行うには、methodではなく、dataTypeを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To optimize rendering, you should add a m.startComputation call before the first widget initialization call, and a m.endComputation after the last widget initialization call in each execution thread.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141303Z" creationid="shibukawa.yoshiki" creationdate="20150412T141303Z">
        <seg>レンダリングを初期化するには、それぞれの実行スレッドの中で、最初のウィジェットの初期化の前にm.startComputationを呼び出し、最後のウィジェットの初期化の後にm.endComputationを呼び出すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent unloading when attempting to navigate away from a page, you can check the return value of m.mount</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092352Z" creationid="shibukawa.yoshiki" creationdate="20150502T092352Z">
        <seg>他のページに遷移しようとしたときに、アンロードが中断されたかどうかを知るには、m.mountの返り値をチェックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To render a string as HTML, see m.trust</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155543Z" creationid="shibukawa.yoshiki" creationdate="20150413T155543Z">
        <seg>文字列をHTMLとしてレンダリングしたい場合は、m.trustを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run the automation task, run the following command from the root folder of your project:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150823Z" creationid="shibukawa.yoshiki" creationdate="20150412T150823Z">
        <seg>自動化処理を実行するには、プロジェクトのルートフォルダで次のようにタイプします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run the execution time tests below, click on their respective links, run the profiler from your desired browser's developer tools and measure the running time of a page refresh (Lower is better).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134936Z" creationid="shibukawa.yoshiki" creationdate="20150407T134936Z">
        <seg>下記の実行時間のテストを行う場合は、それぞれのリンクをクリックして、好きなブラウザの開発者ツールのプロファイラを起動してページリフレッシュの実行時間を計測してください(数値が少ないほうが良い)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run the tests for each framework, click on the respective links.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135234Z" creationid="shibukawa.yoshiki" creationdate="20150407T135234Z">
        <seg>各々のフレームワークのテストを実行する場合は、それぞれのリンクをクリックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To unload a component without loading another component, you can simply call m.mount with a null as the component parameter:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091517Z" creationid="shibukawa.yoshiki" creationdate="20150502T091517Z">
        <seg>他のコンポーネントをロードせずにコンポーネントをアンロードする場合は、コンポーネントの引数としてnullをm.mountに渡せばできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use the HTML5 FormData object as the payload for a request, you need to override the serialize option.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175359Z" creationid="shibukawa.yoshiki" creationdate="20150414T175359Z">
        <seg>HTML5 FormDataをリクエストのペイロードとして使うには、serializeをオーバーライドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use the bleeding edge version from npm, use the following command:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000846Z" creationid="shibukawa.yoshiki" creationdate="20150408T000833Z">
        <seg>npmを使って最先端のバージョンをインストールするには、次のコマンドを使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Todos are self-contained and their data aren't tied to the DOM like in typical jQuery based code.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T234340Z" creationid="shibukawa.yoshiki" creationdate="20150408T234340Z">
        <seg>Todoのコードは他のコードなどへの依存もなく、疎結合でまとまっています。jQueryベースのコードと違って、DOMと密結合していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tools - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013337Z" creationid="shibukawa.yoshiki" creationdate="20150417T013310Z">
        <seg>便利なツール - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trusted HTML is allowed to render arbitrary, potentially invalid markup, as well as run arbitrary Javascript, and therefore the developer is responsible for either:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013853Z" creationid="shibukawa.yoshiki" creationdate="20150416T013728Z">
        <seg>信用されたHTMLは、そのままレンダリングされます。そのソースは不正なマークアップであったり、そのままJavaScriptとして実行されるものである場合もありますが、この次の項目の責任は開発者が負います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typescript Support</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014243Z" creationid="shibukawa.yoshiki" creationdate="20150417T014243Z">
        <seg>TypeScriptサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically resolve/reject are called asynchronously after the then method is called, so normally this difference does not matter.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140610Z" creationid="shibukawa.yoshiki" creationdate="20150415T140533Z">
        <seg>一般的には、resolve/rejectはthenメソッドが呼ばれた後に非同期で呼ばれます。一般的にはこの差はそれほど大きな問題ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically this is required in three situations:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125458Z" creationid="shibukawa.yoshiki" creationdate="20150410T125447Z">
        <seg>一般的に、この機能は以下の3つの場面で必要となります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, m.startComputation / m.endComputation don't need to be called from application space.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152936Z" creationid="shibukawa.yoshiki" creationdate="20150416T152936Z">
        <seg>多くの場合、アプリケーション空間からm.startComputation / m.endComputationを呼ぶ必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, it's used in conjunction with m.prop to implement data binding in the view-to-model direction.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140249Z" creationid="shibukawa.yoshiki" creationdate="20150414T140249Z">
        <seg>一般的に、この関数はm.propと組み合わせて、ビューからモデル方向のデータバインディングを作成するのに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, model entities are reusable and live outside of components (e.g. var User = ...).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040711Z" creationid="shibukawa.yoshiki" creationdate="20150502T040711Z">
        <seg>モデルの実体は再利用可能なため、コンポーネントの外で定義されることが多いです (例: var User = ...)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, this rate is around 60 calls per second.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020327Z" creationid="shibukawa.yoshiki" creationdate="20150421T020327Z">
        <seg>通常は一秒間に60回呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, when separating MVC layers, it's common that the namespace declaration be in the model layer, since this is usually the most used dependency for the other layers.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015353Z" creationid="shibukawa.yoshiki" creationdate="20150421T015353Z">
        <seg>一般的に、MVCレイヤーを分割する場合は、モデルレイヤー内で名前空間を定義すべきです。モデルレイヤーは他の全てのレイヤーが依存するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, you should not even be using inline styles to begin with (unless you are dynamically changing them).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013449Z" creationid="shibukawa.yoshiki" creationdate="20150413T013449Z">
        <seg>一般的に動的に値を変更する時以外は、インラインでのスタイル設定は使用すべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unchecked Error Handling</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T141001Z" creationid="shibukawa.yoshiki" creationdate="20150415T141001Z">
        <seg>チェックしていないエラーのハンドリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike some frameworks, Mithril tries very hard to avoid locking you into a web of dependencies: you can use as little of the framework as you need.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142104Z" creationid="shibukawa.yoshiki" creationdate="20150407T142104Z">
        <seg>他のフレームワークと異なり、Mithrilはクモの巣のような依存関係にとらわれないようにするために多大な努力を払っています。フレームワーク内の必要な部分だけを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unloading components</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050641Z" creationid="shibukawa.yoshiki" creationdate="20150502T050641Z">
        <seg>コンポーネントのアンロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until the promise is resolved, the value of the prop will resolve to undefined</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135403Z" creationid="shibukawa.yoshiki" creationdate="20150414T135403Z">
        <seg>promiseが解決されるまでは、propの値はundefinedになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unwrapping Response Data</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170850Z" creationid="shibukawa.yoshiki" creationdate="20150410T170850Z">
        <seg>レスポンスデータの展開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating the value of the description in the model updates the DOM input when Mithril redraws.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015040Z" creationid="shibukawa.yoshiki" creationdate="20150408T015040Z">
        <seg>モデルの中のdescriptionの値を更新すると、Mithirlが再描画を行ってDOMのテキスト入力を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usage</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154314Z" creationid="shibukawa.yoshiki" creationdate="20150412T154314Z">
        <seg>使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usage of keys</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020816Z" creationid="shibukawa.yoshiki" creationdate="20150421T020816Z">
        <seg>キーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usage of m.redraw</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015757Z" creationid="shibukawa.yoshiki" creationdate="20150421T015757Z">
        <seg>m.redrawの使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use m.mount() or m.route() to activate a component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130004Z" creationid="shibukawa.yoshiki" creationdate="20150502T130004Z">
        <seg>コンポーネントのアクティベートには、m.mount()か、m.route()を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Useful Tools</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141024Z" creationid="shibukawa.yoshiki" creationdate="20150407T141024Z">
        <seg>便利なツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Useful for adding request headers and when using XHR2 features, such as the XMLHttpRequest's upload property.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014152Z" creationid="shibukawa.yoshiki" creationdate="20150415T014152Z">
        <seg>この関数を使うと、リクエストヘッダを追加したり、XMLHttpRequestのuploadプロパティなどXHR2の機能を呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Different Data Transfer Formats</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174826Z" creationid="shibukawa.yoshiki" creationdate="20150410T174826Z">
        <seg>異なるデータ転送フォーマットを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using HTML entities</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T160200Z" creationid="shibukawa.yoshiki" creationdate="20150412T160200Z">
        <seg>HTMLエンティティを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using JSON-P</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T234820Z" creationid="shibukawa.yoshiki" creationdate="20150414T174700Z">
        <seg>JSONPの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using bleeding edge from NPM</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000758Z" creationid="shibukawa.yoshiki" creationdate="20150408T000758Z">
        <seg>NPMで最先端のバージョンを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using variable data formats</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174611Z" creationid="shibukawa.yoshiki" creationdate="20150414T174611Z">
        <seg>可変データ・フォーマットの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually it's recommended that you store application state outside of components (either in a view-model or in the top-level component in the case of nested components).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T082350Z" creationid="shibukawa.yoshiki" creationdate="20150502T082350Z">
        <seg>通常は、アプリケーションの状態は、ビューモデルか、ネストされたコンポーネントの場合は最上位のコンポーネント以外のコンポーネントに持たせるべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Utilities to integrate asynchronous contexts to the rendering system</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154215Z" creationid="shibukawa.yoshiki" creationdate="20150412T154215Z">
        <seg>非同期のコンテキストをMithrilのレンダリングシステムに統合するためのユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values' types should match the expected type for the respective attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153600Z" creationid="shibukawa.yoshiki" creationdate="20150413T153600Z">
        <seg>型は値の、それぞれの属性が期待する型とマッチする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variadic routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152313Z" creationid="shibukawa.yoshiki" creationdate="20150414T152313Z">
        <seg>可変個引数のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>View</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004128Z" creationid="shibukawa.yoshiki" creationdate="20150408T004128Z">
        <seg>ビュー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>View Layer Paradigm</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T145622Z" creationid="shibukawa.yoshiki" creationdate="20150417T145622Z">
        <seg>ビューレイヤーパラダイム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>View-Model</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152214Z" creationid="shibukawa.yoshiki" creationdate="20150407T152214Z">
        <seg>ビュー・モデル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>View-models are also responsible for handling business logic that revolves around UI-specific restrictions.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T153025Z" creationid="shibukawa.yoshiki" creationdate="20150407T153025Z">
        <seg>ビューモデルはUI固有の制約に関するビジネスロジックを処理する責任を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Views in Mithril use a virtual DOM diff implementation, which sidesteps performance problems related to opaque dirty-checking and excessive browser repaint that are present in some frameworks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021414Z" creationid="shibukawa.yoshiki" creationdate="20150409T014712Z">
        <seg>Mithrilのビューは仮想DOMの差分実装を使用していて、いくつかのフレームワークが持っている不透明要素のダーティチェックやパフォーマンス上の問題といった問題を解決しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Virtual DOM diffing and compilable templates</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134014Z" creationid="shibukawa.yoshiki" creationdate="20150407T134014Z">
        <seg>Virtual DOM差分更新と、コンパイル可能なテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vue is a relatively new templating engine, but it boasts impressive results in its performance benchmark.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105928Z" creationid="shibukawa.yoshiki" creationdate="20150420T105928Z">
        <seg>Vueは比較的新しいテンプレートエンジンですが、パフォーマンスのベンチマークでは目覚ましい結果を残しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vue's implementation cleverly hijacks array methods, but it should be noted that Javascript Arrays cannot be truly subclassed and as such, Vue suffers from abstraction leaks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110434Z" creationid="shibukawa.yoshiki" creationdate="20150420T110434Z">
        <seg>Vueの実装は巧妙に配列のメソッドをハイジャックします。JavaScriptの配列をきちんとサブクラス化することが難しくなるため、抽象化の漏れに直面することがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Warning: this section is likely biased.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015053Z" creationid="shibukawa.yoshiki" creationdate="20150420T015053Z">
        <seg>注意: このセクションの説明にはバイアスがかかっているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can append an ellipsis (...) to the name of a route argument to allow it to match URL snippets that contain slashes:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153907Z" creationid="shibukawa.yoshiki" creationdate="20150414T153907Z">
        <seg>省略記号(...)をラウトの引数の名前に付けると、スラッシュを含むURLにマッチさせることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We declare this outside of the select2.view function to avoid cluttering the template.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133638Z" creationid="shibukawa.yoshiki" creationdate="20150412T133638Z">
        <seg>テンプレートが散乱するのを避けるために、select2.view関数の外側にこの関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We only evaluate the getter-setter to get its value in the controller method.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151744Z" creationid="shibukawa.yoshiki" creationdate="20150408T151744Z">
        <seg>Mithrilは、getter-setterをcontrollerメソッド内でしか評価しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll see how to define a component in a bit.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135132Z" creationid="shibukawa.yoshiki" creationdate="20150502T135132Z">
        <seg>どのようにコンポーネントを定義するか見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll see how to define a module in a bit.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002911Z" creationid="shibukawa.yoshiki" creationdate="20150410T002911Z">
        <seg>どのようにモジュールを定義するか見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Web Services</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140740Z" creationid="shibukawa.yoshiki" creationdate="20150407T140740Z">
        <seg>ウェブサービス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Web Services - Mithril</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013833Z" creationid="shibukawa.yoshiki" creationdate="20150410T013833Z">
        <seg>ウェブサービス - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weekly articles on how to use Mithril to its full potential.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135705Z" creationid="shibukawa.yoshiki" creationdate="20150407T135705Z">
        <seg>Mithrilのポテンシャルを引き出す使い方を紹介するブログです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is Mithril?</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140447Z" creationid="shibukawa.yoshiki" creationdate="20150407T132200Z">
        <seg>Mithrilとは？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When integrating with third party libraries, you might find that you need to call asynchronous methods from outside of Mithril's API.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004432Z" creationid="shibukawa.yoshiki" creationdate="20150412T004432Z">
        <seg>サードパーティ製のライブラリを統合する時に、MithrilのAPIの外で非同期メソッドが使っているものもあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When m.mount is called, the controller function runs, and its return value is returned by the m.mount call.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125637Z" creationid="shibukawa.yoshiki" creationdate="20150502T125637Z">
        <seg>m.mountが呼ばれると、controller関数が実行されて、それがm.mountの返り値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a attribute name expects different types for the value in HTML and Javascript, the Javascript type should be used.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153800Z" creationid="shibukawa.yoshiki" creationdate="20150413T153800Z">
        <seg>もし、指定された属性名がHTMLとJavaScriptで異なる型を期待している場合は、JavaScriptの型が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a component has asynchronous payloads and they are queued by the auto-redrawing system, its view is NOT rendered until all asynchronous operations complete.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093644Z" creationid="shibukawa.yoshiki" creationdate="20150502T093644Z">
        <seg>もしコンポーネントが非同期のロードを行っていて、再描画システムのカウンター操作を行っている場合は、非同期操作が完了するまでは再描画が行われることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When calling multiple background AJAX requests, it's recommended that you use m.sync to batch redraw once at the end of all requests, as opposed to repeatedly redrawing after every request:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134537Z" creationid="shibukawa.yoshiki" creationdate="20150502T134537Z">
        <seg>複数のバックグラウンドのAJAXリクエストを行った場合は、個別のリクエストの完了後に再描画を行うのではなく、m.syncを使って待ち合わせを行い、一度だけ再描画を行うのが推奨です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When components aren't nested, Mithril waits for all asynchronous tasks to complete, but when components are nested, a component's parent view renders before the component completes its asynchronous tasks.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093241Z" creationid="shibukawa.yoshiki" creationdate="20150502T093241Z">
        <seg>コンポーネントがネストされていないとMithrilはすべての非同期タスクが完了するのを待ちますが、ネストされていると非同期タスクの完了前に親コンポーネントが再描画することがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When computation methods are used dilligently and religiously, templates are never redrawn with incomplete data.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T115359Z" creationid="shibukawa.yoshiki" creationdate="20150502T115359Z">
        <seg>computationメソッドを使うと、未完了のデータをテンプレートが利用することがなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When dealing with asynchronous functions, you must call [m.startComputation / m.endComputation] if you want the asynchronous payload to affect the view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135455Z" creationid="shibukawa.yoshiki" creationdate="20150415T135455Z">
        <seg>非同期関数を使用して、その非同期で取得してきた値をビューに反映させたい時は、[m.startComputation / m.endComputation]を呼ぶ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When refactoring is unavoidable, the developer can simply replace the m.prop call with an appropriate getter-setter implementation, instead of having to grep for API usage across the entire application.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002313Z" creationid="shibukawa.yoshiki" creationdate="20150409T002313Z">
        <seg>リファクタリングが避けられなくなったら、m.prop呼び出しを、適切なgetter-setter実装に置き換えるだけで済みます。プログラム全体をgrepしてAPIを使っている箇所を検索して置き換える必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the URL matches a route, the respective component's controller is instantiated and passed as a parameter to the view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135208Z" creationid="shibukawa.yoshiki" creationdate="20150502T135208Z">
        <seg>URLがラウトにマッチすると、対応するコンポーネントのコントローラがインスタンス化されて、引数としてビューに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the URL matches a route, the respective module's controller is instantiated and passed as a parameter to the view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003820Z" creationid="shibukawa.yoshiki" creationdate="20150410T003820Z">
        <seg>URLがラウトにマッチすると、対応するモジュールのコントローラがインスタンス化されて、引数としてビューに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the component's asynchronous operations complete, another redraw is triggered and the entire template tree is evaluated again.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093753Z" creationid="shibukawa.yoshiki" creationdate="20150502T093753Z">
        <seg>コンポーネントの非同期操作が完了すると、他の再描画が起動されて、テンプレートのツリー全体を再び再評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the flag is set to "all", Mithril throws away the current view and redraws from scratch.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T140607Z" creationid="shibukawa.yoshiki" creationdate="20150416T140607Z">
        <seg>このフラグが"all"に設定されると、Mithrilは現在のビューをすべて破棄し、ゼロから再描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the flag is set to "diff", Mithril performs a diff between the old view and the new view and applies patches to the DOM only where needed.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143423Z" creationid="shibukawa.yoshiki" creationdate="20150416T143423Z">
        <seg>このフラグが"diff"に設定されると、Mithrilは古いビューと新しいビューの間の差分の検知を行い必要な箇所にだけ差分を適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the flag is set to "none", Mithril skips the next redraw.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143445Z" creationid="shibukawa.yoshiki" creationdate="20150416T143445Z">
        <seg>フラグが"none"に設定されるとMithrilは次の再描画をスキップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When updates happen, the template is not wholly re-rendered - only the changes are applied.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T160905Z" creationid="shibukawa.yoshiki" creationdate="20150408T160905Z">
        <seg>更新が発生した場合は、全体の再描画は行われずに、変更があった箇所だけ更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using the router, a route change recreates the DOM tree from scratch in order to unload plugins from the previous page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130655Z" creationid="shibukawa.yoshiki" creationdate="20150413T130655Z">
        <seg>routerを使用している時は、ラウトが変更されると、前のページで使用されていたプラグインをアンロードするために、DOMツリーがスクラッチから再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When we get there, I'll explain why we're passing description as an argument instead of simply using OOP-style member association.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163625Z" creationid="shibukawa.yoshiki" creationdate="20150407T163439Z">
        <seg>準備が整ったところで、なぜこのサンプルではオブジェクト指向プログラミングのスタイルのメンバーの関連付けを行わずに、descriptionを引数として渡すのかを説明しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether routing uses location hash, querystring or pathname</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153641Z" creationid="shibukawa.yoshiki" creationdate="20150412T153641Z">
        <seg>ラウティングがハッシュ、クエリー文字列、パス名のどのモードを使用するか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether this is the first time we are running this function on this element.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155116Z" creationid="shibukawa.yoshiki" creationdate="20150413T155116Z">
        <seg>関数がこのエレメントに対して実行されるのが初回かどうかを表すフラグです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Mithril doesn't dictate how to organize your code, it does provide some recommendations for structuring it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T014003Z" creationid="shibukawa.yoshiki" creationdate="20150421T014003Z">
        <seg>Mithrilは、手取り足取りコードを構造化させることはありませんが、アプリケーションの構造として推奨していることがいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Mithril technically does support this use case, relying on multiple redraw passes degrades performance and makes it possible to code yourself into an infinite execution loop situation, which is extremely difficult to debug.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135828Z" creationid="shibukawa.yoshiki" creationdate="20150412T135828Z">
        <seg>Mithrilは技術的にこのユースケースをサポートしていないため、再描画が何度も行われてパフォーマンスが低下したりしますし、場合によってはアプリケーションコードが無限ループして、デバッグが極めて難しい状況になったりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While at first glance, it may seem expensive to run a global redraw every time data changes, Mithril makes it possible to do this efficiently thanks to its fast diffing algorithm, which only updates the DOM where it needs to be updated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184052Z" creationid="shibukawa.yoshiki" creationdate="20150411T184052Z">
        <seg>初めて見るとデータ変更があるたびに全体を再描画するのは高コストに見えると思いますが、変更のあるDOMだけを更新するという高速な差分アルゴリズムを使い、Mithrilでは効率的にこれを行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While both basic assignment syntax and thennable syntax can be used to the same effect, typically it's recommended that you use the assignment syntax in the first example whenever possible, as it's easier to read.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T022931Z" creationid="shibukawa.yoshiki" creationdate="20150410T022931Z">
        <seg>代入構文も、thennableを使った構文も同じ結果になりますが、前者の例の方が読みやすいため、何か制約がない限りはこちらを使用する方がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While both basic assignment syntax and thennable syntax can be used to the same effect, typically it's recommended that you use the assignment syntax whenever possible, as it's easier to read.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174926Z" creationid="shibukawa.yoshiki" creationdate="20150414T174926Z">
        <seg>代入構文も、thennableを使った構文も同じ結果になりますが、前者の例の方が読みやすいため、何か制約がない限りはこちらを使用する方がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While superficially this may seem like an odd design, this actually has a lot of benefits:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013155Z" creationid="shibukawa.yoshiki" creationdate="20150409T013155Z">
        <seg>ぱっと見ると、これはとても奇妙な設計に見えますが、実際には多くのメリットがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this decision allows better API discoverability, the trade-off is that we're largely giving up on custom constraints and behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003021Z" creationid="shibukawa.yoshiki" creationdate="20150409T003021Z">
        <seg>既に慣れ親しんでいるAPIが使えるようになったトレードオフとして、カスタムの動作を行うことができなくなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this, we can make the onclick binding on the template much simpler:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152559Z" creationid="shibukawa.yoshiki" creationdate="20150408T152559Z">
        <seg>これにより、テンプレートのonclickバインディングをもっとシンプルに書くことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With those methods and properties, it creates a template that can consume model data and call controller methods to affect the model.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062103Z" creationid="shibukawa.yoshiki" creationdate="20150502T062103Z">
        <seg>これらのメソッドとプロパティを使い、モデルデータを利用したり、モデルを変化させるコントローラのメソッドを呼んだりするテンプレートを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes, this is valid HTML 5!</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142725Z" creationid="shibukawa.yoshiki" creationdate="20150407T142725Z">
        <seg>そうです。これは完全なHTML5です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are encouraged to use CSS selectors to define virtual elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235303Z" creationid="shibukawa.yoshiki" creationdate="20150412T235303Z">
        <seg>仮想エレメントを定義するときはCSSセレクタを使うのが推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are responsible for ensuring that templates aren't too big to render efficiently.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020812Z" creationid="shibukawa.yoshiki" creationdate="20150421T020812Z">
        <seg>そのため、テンプレートが大きくなりすぎないようにして、レンダリングを効率よく行うことが大切です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can download a zip of the latest version version here.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164534Z" creationid="shibukawa.yoshiki" creationdate="20150407T164534Z">
        <seg>ここから最新バージョンのzipアーカイブをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also learn how the redrawing system works here.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015009Z" creationid="shibukawa.yoshiki" creationdate="20150413T015009Z">
        <seg>また、こちらのドキュメントで再描画システムがどのように動くのか学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also configure individual elements to always be diffed, instead of recreated from scratch (even across route changes), by using the ctx.retain flag.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T133256Z" creationid="shibukawa.yoshiki" creationdate="20150502T133256Z">
        <seg>ctx.retainフラグを使うと、個別のエレメントに対してラウトの変更であっても、常に差分検知を行わずに再生成させないように指示することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also find Mithril in cdnjs and jsDelivr.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165214Z" creationid="shibukawa.yoshiki" creationdate="20150407T165214Z">
        <seg>cdnjsとjsDelivrの中から取得することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also fork the latest stable project directly from Github.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000257Z" creationid="shibukawa.yoshiki" creationdate="20150408T000257Z">
        <seg>Githubから直接、最新の安定版のプロジェクトをフォークすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also specify what attribute to bind.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021800Z" creationid="shibukawa.yoshiki" creationdate="20150408T021800Z">
        <seg>また、どの属性と結びつけるかも自由に設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use it to attach events to other elements (for example, window.onresize), but you should remove such event handlers via ctx.onunload to avoid surprises.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124451Z" creationid="shibukawa.yoshiki" creationdate="20150502T124451Z">
        <seg>この機能を使って、window.onresizeなどのイベントを他のエレメントに付与することもできますが、その場合はトラブルを避けるためにctx.onunload を使って確実にイベントハンドラを削除してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use more complex CSS selectors:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000233Z" creationid="shibukawa.yoshiki" creationdate="20150413T000233Z">
        <seg>より複雑なCSSセレクタを使用することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use other polyfills to support these features in IE7.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014826Z" creationid="shibukawa.yoshiki" creationdate="20150417T014826Z">
        <seg>IE7をサポートするためには他のPolyfillが使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use the onunload function to PREVENT a component from being unloaded in the context of a route change (i.e. to alert a user to save their changes before navigating away from a page)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091917Z" creationid="shibukawa.yoshiki" creationdate="20150502T091917Z">
        <seg>ラウターの変更のコンテキスト内でonunload関数を使うことで、モジュールがアンロードされるのを中断することができます。これはページ移動前にデータ変更することを警告する時などに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use the . syntax to add CSS classes and the # to add an id.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004414Z" creationid="shibukawa.yoshiki" creationdate="20150408T004414Z">
        <seg>.文法を使ってCSSのクラスを追加したり、#を使ってidを追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can alternatively include only specific polyfills:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014716Z" creationid="shibukawa.yoshiki" creationdate="20150417T014716Z">
        <seg>特定の</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can bind a pre-existing getter-setter by passing it in as a parameter to a .then method:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015957Z" creationid="shibukawa.yoshiki" creationdate="20150410T015957Z">
        <seg>あらかじめ作成したgetter-setterを.thenメソッドの引数で渡して束縛することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define a non-HTML-standard attribute called config.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123308Z" creationid="shibukawa.yoshiki" creationdate="20150413T123308Z">
        <seg>configという名前のHTML標準ではない属性を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can even build components that take other components as first-class-citizen parameters!</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T014444Z" creationid="shibukawa.yoshiki" creationdate="20150409T014444Z">
        <seg>他のコンポーネントを一級市民のパラメータとして受け取るようなコンポーネントも実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can find the Javascript syntax for all the CSS rules here.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013815Z" creationid="shibukawa.yoshiki" creationdate="20150413T013815Z">
        <seg>JavaScript文法におけるCSSのルールはこちらで確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can get around this issue by using extract</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175650Z" creationid="shibukawa.yoshiki" creationdate="20150414T175650Z">
        <seg>この問題を回避するには、extractを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can learn more about how redrawing heuristics work here.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161935Z" creationid="shibukawa.yoshiki" creationdate="20150408T161935Z">
        <seg>どのように再描画の仕組みが動作するかはこちらのドキュメントでより詳しく知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can learn more about keys here.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090840Z" creationid="shibukawa.yoshiki" creationdate="20150502T090840Z">
        <seg>キーについてはここで学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can optionally pre-compile templates that use m() by running the template-compiler.sjs macro with Sweet.js.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143744Z" creationid="shibukawa.yoshiki" creationdate="20150412T143744Z">
        <seg>Sweet.jsと一緒にtemplate-compiler.sjsマクロを実行すると、m()を使用するテンプレートをプリコンパイルすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override this by providing serialize and deserialize options:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174941Z" creationid="shibukawa.yoshiki" creationdate="20150410T174941Z">
        <seg>serializeオプションと、deserializeオプションを提供すると、この動作を変更することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pre-compile Mithril templates to make them run faster.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014212Z" creationid="shibukawa.yoshiki" creationdate="20150417T014212Z">
        <seg>Mithirlのテンプレートは事前にコンパイルすることでさらに高速にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can programmatically redirect to another page.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012943Z" creationid="shibukawa.yoshiki" creationdate="20150410T012943Z">
        <seg>APIを使用して他のページにリダイレクトすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read more about the promise exception monitor here.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181922Z" creationid="shibukawa.yoshiki" creationdate="20150414T181922Z">
        <seg>詳細については、こちらのpromiseの例外モニタを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read more about the m.prop getter-setter utility here and the m.withAttr event handler factory here.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014927Z" creationid="shibukawa.yoshiki" creationdate="20150413T014927Z">
        <seg>詳細の情報はこちらのm.prop getter-setterユーティリティと、こちらのm.withAttrイベントハンドラで読むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can see that our classes above fit the criteria: they have all the methods and properties that they need to be assembled into a meaningful state.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151742Z" creationid="shibukawa.yoshiki" creationdate="20150407T151742Z">
        <seg>上記のサンプルのモデルクラスは、この基準を満たしていることがわかるでしょう。意味のある状態を構成するのに必要なメソッドとプロパティを十分に備えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set inline styles like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013132Z" creationid="shibukawa.yoshiki" creationdate="20150413T013132Z">
        <seg>次のようにインラインでスタイルを設定できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify an initial value for the m.request getter-setter in order to avoid having to write defensive code against potential null reference exceptions:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001757Z" creationid="shibukawa.yoshiki" creationdate="20150415T001757Z">
        <seg>m.requestに渡すgetter-setterに初期値を渡すという防衛的なコーディングを行えば、null参照例外が発生する可能性を抑えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can unescape trusted HTML strings by using m.trust</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020947Z" creationid="shibukawa.yoshiki" creationdate="20150413T020947Z">
        <seg>信頼できるHTML文字列をエスケープを抑える時はm.trustを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use Mithril to create SVG documents (as long as you don't need to support browsers that don't support SVG natively).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T140726Z" creationid="shibukawa.yoshiki" creationdate="20150413T140726Z">
        <seg>ネイティブでSVGをサポートしていないブラウザをサポートしたくないと思わない限り、Mithrilを使ってSVGドキュメントを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use both HTML and Javascript attribute names.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153453Z" creationid="shibukawa.yoshiki" creationdate="20150413T153453Z">
        <seg>HTMLとJavaScriptの両方の属性名を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use it by adding a reference to your Typescript files.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014336Z" creationid="shibukawa.yoshiki" creationdate="20150417T014336Z">
        <seg>これを使用するには、TypeScriptファイルに参照を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use simple tag selectors to make templates resemble HTML:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000004Z" creationid="shibukawa.yoshiki" creationdate="20150413T000004Z">
        <seg>シンプルなタグセレクタを使って、HTMLに似たテンプレートを作成できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use task automation tools such as GruntJS to concatenate the files back together for production.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015208Z" creationid="shibukawa.yoshiki" creationdate="20150421T015208Z">
        <seg>GruntJSのようなタスク自動化ツールを使って、リリース環境向けにファイルを1つにまとめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the view-model like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163701Z" creationid="shibukawa.yoshiki" creationdate="20150407T163701Z">
        <seg>ビュー・モデルは次のように使えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this mechanism to attach custom event listeners to controller methods (for example, when integrating with third party libraries), but you are responsible for making sure the integration with Mithril's autoredrawing system is in place.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125403Z" creationid="shibukawa.yoshiki" creationdate="20150413T125403Z">
        <seg>この機能を使うと、サードパーティのライブラリを統合する時などに、コントローラのメソッドを呼び出すようなカスタムのイベントハンドラを登録できます。ただし、Mithrilの自動描画システムがきちんと働くようにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can, however, use CSS syntax when defining style rules as inline strings:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013928Z" creationid="shibukawa.yoshiki" creationdate="20150413T013928Z">
        <seg>インラインの文字列を使うことで、CSS文法を使ってスタイルルールを定義することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can, of course, nest virtual elements:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000541Z" creationid="shibukawa.yoshiki" creationdate="20150413T000541Z">
        <seg>もちろん、ネストされた仮想エレメントも作成できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't need to call m.mount to initialize your components if you define a list of routes - m.route calls it for you.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135114Z" creationid="shibukawa.yoshiki" creationdate="20150502T135114Z">
        <seg>ラウトのリストを定義した場合は、モジュールの初期化をするためにm.mountを呼ぶ必要はありません。m.routeが代わりに呼んでくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't need to change this flag to something else again later, since Mithril does that for you.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143529Z" creationid="shibukawa.yoshiki" creationdate="20150416T143529Z">
        <seg>繰り返しになりますが、このフラグを設定する必要はありません。Mithrilが自動で行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You get the ability to automate linting, unit testing and minifying of the entire view layer.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T014412Z" creationid="shibukawa.yoshiki" creationdate="20150409T014304Z">
        <seg>自動文法チェック(lint)、ユニットテスト、ビューレイヤーのminifyといったことも可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may choose to declare the namespace in a separate file or have the build system generate it on demand, instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015503Z" creationid="shibukawa.yoshiki" creationdate="20150421T015503Z">
        <seg>ファイルごとに名前空間を用意するか、あるいはビルドシステムに名前空間を作らせるかは開発者の自由です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may return an XHR-like object (e.g. a XDomainRequest instance) to override the provided XHR instance altogether.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014402Z" creationid="shibukawa.yoshiki" creationdate="20150415T014402Z">
        <seg>この関数を使うと、Mithrilが生成したXHRインスタンスの代わりに、XDomainRequestインスタンスなど、XHRのように動作するまったく別のオブジェクトに置き換えることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might also elect to maintain component state when it's not meaningful outside the scope of a single component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T083740Z" creationid="shibukawa.yoshiki" creationdate="20150502T083740Z">
        <seg>コンポーネント外で管理する意味がない場合は、コンポーネントの状態を維持することを選ぶことになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must add a pair of these calls for each asynchronous execution thread, unless the thread is already integrated.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134545Z" creationid="shibukawa.yoshiki" creationdate="20150412T134545Z">
        <seg>もしスレッドの統合が終わっていなければ、これらの関数のペアをすべての非同期実行スレッドのコードに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should always document integration components so that others can find out what attribute parameters can be used to initialize the component.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T140339Z" creationid="shibukawa.yoshiki" creationdate="20150412T140339Z">
        <seg>統合コンポーネントを作成するときは、常にドキュメントを作成し、他の人がコンポーネントの初期化時にどの属性パラメータが使用できるか分かるようにすべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should always use keys if you need to sort lists, remove items from them or splice them in any way.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150421Z" creationid="shibukawa.yoshiki" creationdate="20150413T150421Z">
        <seg>リストをソートしたり、要素を削除したり、スプライスする場合は常にキーを使用すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should avoid grouping classes by the MVC layer they belong to, i.e. don't create three files called model.js, controllers.js and views.js.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015612Z" creationid="shibukawa.yoshiki" creationdate="20150421T015612Z">
        <seg>MVCレイヤーそのものでクラスをグループ化するのはやめましょう。model.js、controllers.js、views.jsという名前のファイルは作ってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should avoid instantiating controller classes from views.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033729Z" creationid="shibukawa.yoshiki" creationdate="20150421T033729Z">
        <seg>ビューからコントr−ラのクラスのインスタンスを作成するのは避けましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not add the callback querystring parameter; Mithril already does that internally.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T234856Z" creationid="shibukawa.yoshiki" creationdate="20150414T234818Z">
        <seg>通常のJSONPリクエストで必要になるcallbackクエリー文字列パラメータを設定する必要はありません。Mithrilが内部で行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not use these methods if your code is intended to run repeatedly (e.g. by using setInterval).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193428Z" creationid="shibukawa.yoshiki" creationdate="20150411T193428Z">
        <seg>setIntervalを使う場合など、コードが別々に呼ばれるような場合はこれらのメソッドは使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should use this method and implement similar ones when extracting values from a browser's Event object, instead of hard-coding the extraction code into controllers (or model methods).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140631Z" creationid="shibukawa.yoshiki" creationdate="20150414T140631Z">
        <seg>Mithrilを使う場合には、このメソッドを使うか似たような機能を実装して、ブラウザのイベントオブジェクトからプログラムに使う値を取り出す操作を、コントローラやモデルにハードコードしないコーディングをしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You're probably starting to notice that Javascript has strong support for functional programming and that it allows us to naturally do things that can be clunky in other frameworks (e.g. looping inside a &lt;dl&gt;/&lt;dt&gt;/&lt;dd&gt; construct).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153457Z" creationid="shibukawa.yoshiki" creationdate="20150408T153457Z">
        <seg>ここまでの説明でお気づきの通り、JavaScriptには、関数型プログラミングに対する強力なサポートが備わっています。これを使うと、他のフレームワークではなかなかうまく表現しづらいコードを、とても自然な形で記述することができます。例えば、&lt;dl&gt;/&lt;dt&gt;/&lt;dd&gt;を構成するためにループを使うといったことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>])
}
//a configuration that persists across route changes
function persistent(el, isInit, context) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135053Z" creationid="shibukawa.yoshiki" creationdate="20150413T135053Z">
        <seg>])
}
//ラウトが変更されてもエレメントを保持する設定
function persistent(el, isInit, context) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>]);
};

//initialize the application
m.mount(document, {controller: todo.controller, view: todo.view});
&lt;/script&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041817Z" creationid="shibukawa.yoshiki" creationdate="20150502T041817Z">
        <seg>]);
};

//アプリケーションの初期化
m.mount(document, {controller: todo.controller, view: todo.view});
&lt;/script&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`id` is the the same as `value`
*/
Select2.config = function(ctrl) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045234Z" creationid="shibukawa.yoshiki" creationdate="20150502T045234Z">
        <seg>`id`は`value`と同じ
*/
Select2.config = function(ctrl) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>acknowledging that the string is authorized to run any code that may be contained within it.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014058Z" creationid="shibukawa.yoshiki" creationdate="20150416T014058Z">
        <seg>文字列の中にどのような処理も可能なコードがある可能性があり、それに実行権限を与えることを認める。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>after saving the contact, it reloads the list (.then(update.bind(this)))</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T003126Z" creationid="shibukawa.yoshiki" creationdate="20150502T003126Z">
        <seg>保存が完了したらリストのリロードをする(.then(update.bind(this)))。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an anchor element &lt;a&gt; with an href attribute that points to a route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172255Z" creationid="shibukawa.yoshiki" creationdate="20150414T172255Z">
        <seg>ラウトを指すhref属性を持つ&lt;a&gt;エレメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an object that retains its state across redraws</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140024Z" creationid="shibukawa.yoshiki" creationdate="20150502T140024Z">
        <seg>再描画間で状態を保持するオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>becomes:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002445Z" creationid="shibukawa.yoshiki" creationdate="20150409T002445Z">
        <seg>変更後:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>compile: {expand: true, cwd: ".", src: "**/*.js", dest: "destination-folder-goes-here/"}</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150721Z" creationid="shibukawa.yoshiki" creationdate="20150412T150655Z">
        <seg>compile: {expand: true, cwd: ".", src: "**/*.js", dest: "インストールフォルダはこちら/"}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log("unloaded the div");</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124516Z" creationid="shibukawa.yoshiki" creationdate="20150502T124516Z">
        <seg>console.log("divをアンロード");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log("unloaded!")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092744Z" creationid="shibukawa.yoshiki" creationdate="20150502T092744Z">
        <seg>console.log("アンロード!")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log("unloading home component");</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135632Z" creationid="shibukawa.yoshiki" creationdate="20150502T135632Z">
        <seg>console.log("ホームをアンロード");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console.log("unloading my component");</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091634Z" creationid="shibukawa.yoshiki" creationdate="20150502T091634Z">
        <seg>console.log("MyComponentコンポーネントを削除しています");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defining a list of routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162201Z" creationid="shibukawa.yoshiki" creationdate="20150409T162201Z">
        <seg>ラウトのリストの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else m.redraw.strategy("none") //otherwise, ignore
}})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150258Z" creationid="shibukawa.yoshiki" creationdate="20150416T150258Z">
        <seg>else m.redraw.strategy("none") //そうでなければ無視する
}})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://en.wikipedia.org/wiki/Observer_pattern</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025157Z" creationid="shibukawa.yoshiki" creationdate="20150502T025157Z">
        <seg>http://ja.wikipedia.org/wiki/Observer_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!isInit) ctx.data = "foo" //we wish to initialize this only once, even if the route changes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130727Z" creationid="shibukawa.yoshiki" creationdate="20150502T130727Z">
        <seg>if (!isInit) ctx.data = "foo" //この初期化はラウトの変更に関わらず一度だけ実行したい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!user.isAdmin) throw new Error("Sorry, you don't have permissions")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173404Z" creationid="shibukawa.yoshiki" creationdate="20150415T173404Z">
        <seg>if (!user.isAdmin) throw new Error("もうしわけありません。権限がありません。")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (e.keyCode == 13) vm.save() //do things and re-render only if the `enter` key was pressed</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150248Z" creationid="shibukawa.yoshiki" creationdate="20150416T150248Z">
        <seg>if (e.keyCode == 13) vm.save() //`enter`キーが押された時だけ再描画をする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in model-level methods if client-side processing is needed to make the data useful for a controller or view.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175047Z" creationid="shibukawa.yoshiki" creationdate="20150414T175047Z">
        <seg>モデルレベルのメソッド内で、コントローラやビューに対して処理しやすい形式のデータへの変換をクライアント側で行わなければならない場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in order to avoid the full-page recreation when changing routes, for the sake of performance of global 3rd party components.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130757Z" creationid="shibukawa.yoshiki" creationdate="20150502T130757Z">
        <seg>ラウト変更時に全画面の再構築を避けて、サードパーティのコンポーネントのパフォーマンス劣化を避ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in order to prevent redraw when dealing with keypress events where the event's keyCode is not of interest</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144741Z" creationid="shibukawa.yoshiki" creationdate="20150416T144741Z">
        <seg>keypressイベントで受け取ったキーコードが処理対象外だったので再描画を避けたい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the controller layer: to bind error messages</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174946Z" creationid="shibukawa.yoshiki" creationdate="20150414T174946Z">
        <seg>コントローラレイヤ内: エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the controller layer: to bind redirection code upon a condition</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174942Z" creationid="shibukawa.yoshiki" creationdate="20150414T174942Z">
        <seg>コントローラレイヤ内: 条件によって、リダイレクトするコードをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the controller, to bind error messages</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175057Z" creationid="shibukawa.yoshiki" creationdate="20150414T175057Z">
        <seg>コントローラ内で、エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the controller, to redirect after a model service resolves.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175053Z" creationid="shibukawa.yoshiki" creationdate="20150414T175053Z">
        <seg>コントローラ内で、モデルサービスが改良した後にリダイレクトさせたい場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the model layer: to process web service data in transformative ways (e.g. filtering a list based on a parameter that the web service doesn't support)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174936Z" creationid="shibukawa.yoshiki" creationdate="20150414T174936Z">
        <seg>モデルレイヤ内: ウェブサービスから受信したデータを変換処理をする場合。例えばウェブサービス側でサポートしていないフィルタリングをクライアント側で行う場合など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>item.foreach(doSomething) //programmer error: typo will throw runtime error to the console</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173033Z" creationid="shibukawa.yoshiki" creationdate="20150415T173033Z">
        <seg>item.foreach(doSomething) //プログラマのエラー: タイプミスによって実行時エラーがログに出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>jQuery is ubiquitous and has a large ecosystem, but it's not an MVC framework.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015221Z" creationid="shibukawa.yoshiki" creationdate="20150420T015221Z">
        <seg>jQueryはどこでも使われ、巨大なエコシステムを構築しましたが、それ自身はMVCフレームワークではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m(".container"); //yields &lt;div class="container"&gt;&lt;/div&gt;

m("#layout"); //yields &lt;div id="layout"&gt;&lt;/div&gt;

m("a[name=top]"); //yields &lt;a name="top"&gt;&lt;/a&gt;

m("[contenteditable]"); //yields &lt;div contenteditable&gt;&lt;/div&gt;

m("a#google.external[href='http://google.com']", "Google"); //yields &lt;a id="google" class="external" href="http://google.com"&gt;Google&lt;/a&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000407Z" creationid="shibukawa.yoshiki" creationdate="20150413T000407Z">
        <seg>m(".container"); //&lt;div class="container"&gt;&lt;/div&gt;を作成

m("#layout"); //&lt;div id="layout"&gt;&lt;/div&gt;を作成

m("a[name=top]"); //&lt;a name="top"&gt;&lt;/a&gt;を作成

m("[contenteditable]"); //&lt;div contenteditable&gt;&lt;/div&gt;を作成

m("a#google.external[href='http://google.com']", "Google"); //&lt;a id="google" class="external" href="http://google.com"&gt;Google&lt;/a&gt;を作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("br"); //yields a virtual element that represents &lt;br&gt;

m("div", "Hello"); //yields &lt;div&gt;Hello&lt;/div&gt;

m("div", {class: "container"}, "Hello"); //yields &lt;div class="container"&gt;Hello&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000106Z" creationid="shibukawa.yoshiki" creationdate="20150413T000040Z">
        <seg>m("br"); //&lt;br&gt;を表現する仮想エレメントを作成

m("div", "Hello"); //&lt;div&gt;Hello&lt;/div&gt;を作成

m("div", {class: "container"}, "Hello"); //&lt;div class="container"&gt;Hello&lt;/div&gt;を作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button", "Add"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013733Z" creationid="shibukawa.yoshiki" creationdate="20150408T013733Z">
        <seg>m("button", "追加"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button", {onclick: todo.vm.add}, "Add")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152603Z" creationid="shibukawa.yoshiki" creationdate="20150408T152603Z">
        <seg>m("button", {onclick: todo.vm.add}, "追加")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button", {onclick: todo.vm.add}, "Add"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153600Z" creationid="shibukawa.yoshiki" creationdate="20150408T153600Z">
        <seg>m("button", {onclick: todo.vm.add}, "追加"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button[type=button]", {onclick: args.onsave.bind(this, contact)}, "Save")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002039Z" creationid="shibukawa.yoshiki" creationdate="20150502T002039Z">
        <seg>m("button[type=button]", {onclick: args.onsave.bind(this, contact)}, "保存")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button[type=button]", {onclick: ctrl.save.bind(this, contact)}, "Save")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013724Z" creationid="shibukawa.yoshiki" creationdate="20150502T013724Z">
        <seg>m("button[type=button]", {onclick: ctrl.save.bind(this, contact)}, "保存")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button[type=button]", {onclick: ctrl.save}, "Upload")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034926Z" creationid="shibukawa.yoshiki" creationdate="20150502T034926Z">
        <seg>m("button[type=button]", {onclick: ctrl.save}, "アップロード")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("button[type=button]", {onkeypress: save}, "Save"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144902Z" creationid="shibukawa.yoshiki" creationdate="20150416T144902Z">
        <seg>m("button[type=button]", {onkeypress: save}, "保存"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("canvas", {config: draw})
]

//this creates the canvas element, and therefore, `isInitialized` is false
m.render(document.body, view);

//here, isInitialized is `true`
m.render(document.body, view);</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123656Z" creationid="shibukawa.yoshiki" creationdate="20150413T123637Z">
        <seg>m("canvas", {config: draw})
]

//このメソッド呼び出しをすると、canvasエレメントが作られ、`initialized`がfalseに設定される
m.render(document.body, view);

//ここではisInitializedは`true`になる
m.render(document.body, view);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", "&amp;times;") //becomes &lt;div&gt;&amp;amp;times;&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020917Z" creationid="shibukawa.yoshiki" creationdate="20150413T020917Z">
        <seg>m("div", "&amp;times;") //&lt;div&gt;&amp;amp;times;&lt;/div&gt;になる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", data) : null).</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121036Z" creationid="shibukawa.yoshiki" creationdate="20150502T121036Z">
        <seg>m("div", data) : null)を行う方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", m.trust("&amp;times;")) //becomes &lt;div&gt;&amp;times;&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020953Z" creationid="shibukawa.yoshiki" creationdate="20150413T020953Z">
        <seg>m("div", m.trust("&amp;times;")) //&lt;div&gt;&amp;times;&lt;/div&gt;になる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", {"data-index": 1}); //yields &lt;div data-index="1"&gt;&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013113Z" creationid="shibukawa.yoshiki" creationdate="20150413T013113Z">
        <seg>m("div", {"data-index": 1}); //&lt;div data-index="1"&gt;&lt;/div&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", {class: "widget"}); //yields &lt;div class="widget"&gt;&lt;/div&gt;

m("div", {className: "widget"}); //yields &lt;div class="widget"&gt;&lt;/div&gt;

m("button", {onclick: alert}); //yields &lt;button&gt;&lt;/button&gt;, which alerts its event argument when clicked

//note this uses the Javascript syntax (uppercase "O") for `readonly`
//in order to set the boolean javascript property instead of the HTML attribute
m("input", {readOnly: true}); //yields &lt;input readonly /&gt;

//using the HTML attribute name will call `setAttribute`, which may not be what you want
m("input", {readonly: false}); //yields &lt;input readonly="false" /&gt;, which is still readonly</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013004Z" creationid="shibukawa.yoshiki" creationdate="20150413T012502Z">
        <seg>m("div", {class: "widget"}); //&lt;div class="widget"&gt;&lt;/div&gt;を生成

m("div", {className: "widget"}); //&lt;div class="widget"&gt;&lt;/div&gt;を生成

m("button", {onclick: alert}); //押されるとアラートを表示する&lt;button&gt;&lt;/button&gt;を生成

//`readonly`の設定にJavaScript文法(大文字の"O"になる)を使用
//HTML属性とは異なり、JavaScriptのプロパティではboolean型を使用する
m("input", {readOnly: true}); //yields &lt;input readonly /&gt;

//HTML属性名は`setAttribute`が使われるため期待と異なることがある
m("input", {readonly: false}); //&lt;input readonly="false" /&gt;は属性が存在するので読み込み専用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", {style: {border: "1px solid red"}}); //yields &lt;div style="border:1px solid red;"&gt;&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013140Z" creationid="shibukawa.yoshiki" creationdate="20150413T013140Z">
        <seg>m("div", {style: {border: "1px solid red"}}); //&lt;div style="border:1px solid red;"&gt;&lt;/div&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div", {style: {textAlign: "center"}}); //yields &lt;div style="text-align:center;"&gt;&lt;/div&gt;
m("div", {style: {cssFloat: "left"}}); //yields &lt;div style="float:left;"&gt;&lt;/div&gt;

//this does not work
m("div", {style: {"text-align": "center"}});
m("div", {style: {float: "left"}});</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013720Z" creationid="shibukawa.yoshiki" creationdate="20150413T013711Z">
        <seg>m("div", {style: {textAlign: "center"}}); //&lt;div style="text-align:center;"&gt;&lt;/div&gt;を生成
m("div", {style: {cssFloat: "left"}}); //&lt;div style="float:left;"&gt;&lt;/div&gt;を生成

//これは動作しない
m("div", {style: {"text-align": "center"}});
m("div", {style: {float: "left"}});</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("div[style='text-align:center']"); //yields &lt;div style="text-align:center;"&gt;&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013936Z" creationid="shibukawa.yoshiki" creationdate="20150413T013936Z">
        <seg>m("div[style='text-align:center']"); //&lt;div style="text-align:center;"&gt;&lt;/div&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("h1", "Uploader demo"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034737Z" creationid="shibukawa.yoshiki" creationdate="20150502T034737Z">
        <seg>m("h1", "アップローダデモ"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("input", {config: plugin}) //assuming `plugin` initializes a 3rd party library</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144635Z" creationid="shibukawa.yoshiki" creationdate="20150416T144635Z">
        <seg>m("input", {config: plugin}) //`plugin`がサードパーティのライブラリを初期化するものとする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("label", "Email"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013644Z" creationid="shibukawa.yoshiki" creationdate="20150502T013644Z">
        <seg>m("label", "Eメール"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("label", "Name"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013638Z" creationid="shibukawa.yoshiki" creationdate="20150502T013638Z">
        <seg>m("label", "名前"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("label", "User:"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045319Z" creationid="shibukawa.yoshiki" creationdate="20150502T045319Z">
        <seg>m("label", "ユーザ:"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("li", "item 1"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000609Z" creationid="shibukawa.yoshiki" creationdate="20150413T000609Z">
        <seg>m("li", "アイテム 1"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("li", "item 2"),
]);

/*
yields
&lt;ul&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000638Z" creationid="shibukawa.yoshiki" creationdate="20150413T000614Z">
        <seg>m("li", "アイテム 2"),
]);

/*
これが作成される:
&lt;ul&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("p", "Drag and drop a file below.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034853Z" creationid="shibukawa.yoshiki" creationdate="20150502T034853Z">
        <seg>m("p", "ファイルをここにドロップしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m("td", "task description"),</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004223Z" creationid="shibukawa.yoshiki" creationdate="20150408T004223Z">
        <seg>m("td", "タスクの説明"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.endComputation(); //call `endComputation` at the end of everything</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010827Z" creationid="shibukawa.yoshiki" creationdate="20150412T010827Z">
        <seg>m.endComputation(); //すべての処理の後に`endComputation`を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.endComputation(); //call `endComputation` at the end of the callback</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193004Z" creationid="shibukawa.yoshiki" creationdate="20150411T193004Z">
        <seg>m.endComputation(); //`endComputation`はコールバックの最後で呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.endComputation(); //call after everything else in the event handler
}</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193139Z" creationid="shibukawa.yoshiki" creationdate="20150411T193139Z">
        <seg>m.endComputation(); //イベントハンドラの最後で、他の処理よりも後に呼ぶ
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.endComputation(); //call after everything else in the event handler
})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T175402Z" creationid="shibukawa.yoshiki" creationdate="20150501T175402Z">
        <seg>m.endComputation(); //イベントハンドラの最後で、他の処理よりも後に呼ぶ
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.endComputation(); //redraw regardless of whether `doStuff` threw errors</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153543Z" creationid="shibukawa.yoshiki" creationdate="20150416T153543Z">
        <seg>m.endComputation(); //`doStuff`が例外を投げたとしても再描画が行われる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.redraw(true) // force</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151342Z" creationid="shibukawa.yoshiki" creationdate="20150416T151342Z">
        <seg>m.redraw(true) // 強制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.render(document.body, m("br")); //puts a &lt;br&gt; in &lt;body&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000216Z" creationid="shibukawa.yoshiki" creationdate="20150413T000216Z">
        <seg>m.render(document.body, m("br")); //&lt;br&gt;タグを&lt;body&gt;に出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before everything else</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010808Z" creationid="shibukawa.yoshiki" creationdate="20150412T010808Z">
        <seg>m.startComputation(); //すべての処理の前に`startComputation`を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before the asynchronous AJAX request</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010127Z" creationid="shibukawa.yoshiki" creationdate="20150412T010127Z">
        <seg>m.startComputation(); //`startComputation`は非同期のAJAXリクエスト前に呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before the asynchronous `setTimeout`</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192949Z" creationid="shibukawa.yoshiki" creationdate="20150411T192949Z">
        <seg>m.startComputation(); //`startComputation`は非同期の`setTimeout`の前に呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before the asynchronous synchronization method</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010333Z" creationid="shibukawa.yoshiki" creationdate="20150412T010333Z">
        <seg>m.startComputation(); //非同期の同期メソッドの前に`startComputation`を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m.startComputation(); //call before everything else in the event handler</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193124Z" creationid="shibukawa.yoshiki" creationdate="20150411T193124Z">
        <seg>m.startComputation(); //イベントハンドラの先頭で、他の処理よりも先に呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>making links in templates routed transparently and unobtrusively</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162425Z" creationid="shibukawa.yoshiki" creationdate="20150409T162425Z">
        <seg>テンプレート内でリンクを作ると、透過的であまり主張しないリンクが作成できる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>on initialization, it fetches the list of contacts (this.contacts = Contact.list)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002640Z" creationid="shibukawa.yoshiki" creationdate="20150502T002640Z">
        <seg>初期化時に連絡先のリストを取得します(this.contacts = Contact.list())。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>onclick: ctrl.increment //view calls controller method on click</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071323Z" creationid="shibukawa.yoshiki" creationdate="20150502T071323Z">
        <seg>onclick: ctrl.increment //ビューはクリック時にコントローラメソッドを呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>programmatically redirecting between routes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162257Z" creationid="shibukawa.yoshiki" creationdate="20150409T162257Z">
        <seg>ソースコードによる、ラウト間のリダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>redirects to http://server/#/dashboard/marysue</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013048Z" creationid="shibukawa.yoshiki" creationdate="20150410T013048Z">
        <seg>このコードを実行すると、http://server/#/dashboard/marysueにリダイレクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return "Are you sure you want to leave?"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092416Z" creationid="shibukawa.yoshiki" creationdate="20150502T092416Z">
        <seg>return "本当に移動しますか？"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return deferred.promise;
};

//asynchronous consumer
var greeting = greetAsync()
var processed = greeting.then(function(value) {return value + " world"})

console.log(greeting()) // undefined - because `deferred.resolve` has not been called yet

setTimeout(function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135253Z" creationid="shibukawa.yoshiki" creationdate="20150415T135234Z">
        <seg>return deferred.promise;
};

//非同期の消費者
var greeting = greetAsync()
var processed = greeting.then(function(value) {return value + " world"})

console.log(greeting()) // undefined - `deferred.resolve`がまだ呼ばれてない

setTimeout(function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return description;
}

//make it serializable
this.description.toJSON = function() {return description}

//set the value
this.description(data.description)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002550Z" creationid="shibukawa.yoshiki" creationdate="20150409T002550Z">
        <seg>return description;
}

//シリアライズ可能にする
this.description.toJSON = function() {return description}

//値を設定
this.description(data.description)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return m("h1", ctrl.greeting)
}

//render
m.mount(document.body, {controller: controller, view: view}) // renders Hello</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071612Z" creationid="shibukawa.yoshiki" creationdate="20150502T071612Z">
        <seg>return m("h1", ctrl.greeting)
}

//レンダリング
m.mount(document.body, {controller: controller, view: view}) // 表示: Hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return m("h1", {config: Component1.config}, "test") //assume all routes display the same thing</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130704Z" creationid="shibukawa.yoshiki" creationdate="20150502T130704Z">
        <seg>return m("h1", {config: Component1.config}, "test") //すべてのラウトが同じコンテンツを表示する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return m("input", {oninput: m.withAttr("value", prop), value: prop()})
}

//a data store
var name = m.prop("")

//binding the data store in a view
input(name)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015709Z" creationid="shibukawa.yoshiki" creationdate="20150413T015709Z">
        <seg>return m("input", {oninput: m.withAttr("value", prop), value: prop()})
}

//データストア
var name = m.prop("")

//ビュー内のデータストアにバインディング
input(name)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return m.request({method: "GET", url: "/user", type: User});
}

var users = User.list();
//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), `users` will contain a list of User instances
//i.e. users()[0].name() == "John"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170827Z" creationid="shibukawa.yoshiki" creationdate="20150410T170827Z">
        <seg>return m.request({method: "GET", url: "/user", type: User});
}

var users = User.list();
//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` はUserインスタンスのリストを格納します
//例: users()[0].name() == "John"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return value
}

//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130409Z" creationid="shibukawa.yoshiki" creationdate="20150410T130334Z">
        <seg>return value
}

//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return vm
}())

//the controller defines what part of the model is relevant for the current page
//in our case, there's only one view-model that handles everything
todo.controller = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163341Z" creationid="shibukawa.yoshiki" creationdate="20150408T163303Z">
        <seg>return vm
}())

//コントローラは、モデルの中のどの部分が、現在のページと関連するのかを定義している
//この場合は１つのビュー・モデルですべてを取り仕切っている
todo.controller = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return {oninput: m.withAttr("value", prop), value: prop()}
}

//a data store
var name = m.prop("")

//binding the data store in a view
m("input", binds(name))</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015607Z" creationid="shibukawa.yoshiki" creationdate="20150413T015549Z">
        <seg>return {oninput: m.withAttr("value", prop), value: prop()}
}

//データストア
var name = m.prop("")

//ビュー内のデータストアにバインド
m("input", binds(name))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns a promise that can bind callbacks which get called on completion of the AJAX request.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014442Z" creationid="shibukawa.yoshiki" creationdate="20150415T014442Z">
        <seg>AJAXリクエストが完了したときに呼ばれるコールバックをバインドすることが可能なpromise。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>returns the currently active route</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172212Z" creationid="shibukawa.yoshiki" creationdate="20150414T172212Z">
        <seg>現在アクティブなラウトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sanitizing the markup contained in the string, or</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013916Z" creationid="shibukawa.yoshiki" creationdate="20150416T013916Z">
        <seg>サニタイズされたマークアップが文字列の中に含まれる、もしくは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sjs -r -m /template-compiler.sjs -o &lt;output-filename&gt;.js &lt;input-filename&gt;.js</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150236Z" creationid="shibukawa.yoshiki" creationdate="20150412T150236Z">
        <seg>sjs -r -m /template-compiler.sjs -o &lt;出力ファイル名&gt;.js &lt;入力ファイル名&gt;.js</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>temp: m.prop(10) // kelvin</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081105Z" creationid="shibukawa.yoshiki" creationdate="20150502T081105Z">
        <seg>temp: m.prop(10) // ケルビン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the list of HTML attributes changes, or</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135406Z" creationid="shibukawa.yoshiki" creationdate="20150413T135406Z">
        <seg>HTML属性のリストが変更されるか、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the method does not run if this flag is set to true.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172328Z" creationid="shibukawa.yoshiki" creationdate="20150414T172328Z">
        <seg>このフラグがtrueの場合はこのメソッドは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the tag name changes, or</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135356Z" creationid="shibukawa.yoshiki" creationdate="20150413T135356Z">
        <seg>タグ名が変更されるか、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the value of the element's id attribute changes</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135422Z" creationid="shibukawa.yoshiki" creationdate="20150413T135422Z">
        <seg>エレメントのid属性が変更された場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>things: m.request({method: "GET", url: "/api/things/", data: args}) //slice the data in some way</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084532Z" creationid="shibukawa.yoshiki" creationdate="20150502T084532Z">
        <seg>things: m.request({method: "GET", url: "/api/things/", data: args}) //何らかのルールでデータの一部を切り出し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.done = m.prop(false);
};

//the TodoList class is a list of Todo's
todo.TodoList = Array;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150427Z" creationid="shibukawa.yoshiki" creationdate="20150407T150427Z">
        <seg>this.done = m.prop(false);
};

//TodoListクラスはTodoのリスト
todo.TodoList = Array;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.done = m.prop(false);
};

//the TodoList class is a list of Todo's
todo.TodoList = Array;

//the view-model tracks a running list of todos,
//stores a description for new todos before they are created
//and takes care of the logic surrounding when adding is permitted
//and clearing the input after adding a todo to the list
todo.vm = (function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T162616Z" creationid="shibukawa.yoshiki" creationdate="20150408T162616Z">
        <seg>this.done = m.prop(false);
};

//TodoListクラスはtodoの配列
todo.TodoList = Array;

//ビュー・モデルは表示されているTodoのリストを管理し、
//作成が完了する前のTodoの説明を格納したり、
//作成が可能かどうかを判定するロジックや、
//Todoが追加された後にテキスト入力をクリアする責務を持つ
todo.vm = (function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>throw new Error("Server is offline")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181844Z" creationid="shibukawa.yoshiki" creationdate="20150414T181844Z">
        <seg>throw new Error("サーバがオフラインです")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>todo.vm.init()
}

//here's the view
todo.view = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163358Z" creationid="shibukawa.yoshiki" creationdate="20150408T163358Z">
        <seg>todo.vm.init()
}

//これがビュー
todo.view = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>todo.vm.init();

todo.vm.description(); // empty string
m.render(document, todo.view()); // input is blank

todo.vm.description("Write code"); //set the description in the controller
m.render(document, todo.view()); // input now says "Write code"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015242Z" creationid="shibukawa.yoshiki" creationdate="20150408T015204Z">
        <seg>todo.vm.init();

todo.vm.description(); // 空文字列
m.render(document, todo.view()); // テキスト入力もブランク

todo.vm.description("コードを書く"); // ビュー・モデルのdescriptionに値を設定
m.render(document, todo.view()); // テキスト入力に「コードを書く」が表示される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var app = {}

//here's an example plugin that determines whether data has changes.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124526Z" creationid="shibukawa.yoshiki" creationdate="20150416T124526Z">
        <seg>var app = {}

//どこのデータが変更されているかを決定するサンプルプラグイン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var deferred = Q.defer()
var users = m.prop(deferred.promise)

users() // undefined

deferred.resolve("Hello")

//wait for next tick for Q's A+ compliant promise to actually resolve
setTimeout(function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135547Z" creationid="shibukawa.yoshiki" creationdate="20150414T135547Z">
        <seg>var deferred = Q.defer()
var users = m.prop(deferred.promise)

users() // undefined

deferred.resolve("Hello")

//QのA+互換のPromiseが次のtickで解決するのを待つ
setTimeout(function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var isDone = myTask.done(); //isDone == false

//mark as done
myTask.done(true); //true

//now it's done
isDone = myTask.done(); //isDone == true</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150958Z" creationid="shibukawa.yoshiki" creationdate="20150407T150958Z">
        <seg>var isDone = myTask.done(); //isDone == false

//完了にする
myTask.done(true); //true

//ここでは完了している
isDone = myTask.done(); //isDone == true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var myTask = new todo.Todo({description: "Write code"});

//read the description
myTask.description(); //Write code

//is it done?</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150920Z" creationid="shibukawa.yoshiki" creationdate="20150407T150920Z">
        <seg>var myTask = new todo.Todo({description: "コードを書く"});

//descriptionを取得する
myTask.description(); //コードを書く

//完了しているか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var todo = {};

//for simplicity, we use this component to namespace the model classes

//the Todo class has two properties
todo.Todo = function(data) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040737Z" creationid="shibukawa.yoshiki" creationdate="20150502T040737Z">
        <seg>var todo = {};

//例をシンプルにするために、このコンポーネントをモデルクラスの名前空間として利用する

//Todoクラスはプロパティを2つ持つ
todo.Todo = function(data) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var transport = m.prop();

m.request({method: "POST", url: "/foo", config: transport});

//the `transport` getter-setter contains an instance of XMLHttpRequest
transport().abort();</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182405Z" creationid="shibukawa.yoshiki" creationdate="20150414T182405Z">
        <seg>var transport = m.prop();

m.request({method: "POST", url: "/foo", config: transport});

//`transport` getter-setterにはXMLHttpRequestのインスタンスが含まれる。
transport().abort();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var users = m.prop([]); //default value

m.request({method: "GET", url: "/user"}).then(users)
//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T020018Z" creationid="shibukawa.yoshiki" creationdate="20150410T020018Z">
        <seg>var users = m.prop([]); //default value

m.request({method: "GET", url: "/user"}).then(users)
//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var users = m.prop([]); //default value
var doSomething = function() { /*...*/ }

m.request({method: "GET", url: "/user"}).then(users).then(doSomething)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T020302Z" creationid="shibukawa.yoshiki" creationdate="20150410T020302Z">
        <seg>var users = m.prop([]); //デフォルト値
var doSomething = function() { /*...*/ }

m.request({method: "GET", url: "/user"}).then(users).then(doSomething)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var users = m.request({method: "GET", url: "/user"});

//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015137Z" creationid="shibukawa.yoshiki" creationdate="20150410T015137Z">
        <seg>var users = m.request({method: "GET", url: "/user"});

//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var vm = todo.vm

m("button", {onclick: vm.add.bind(vm, vm.description)}, "Add")</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151232Z" creationid="shibukawa.yoshiki" creationdate="20150408T151232Z">
        <seg>var vm = todo.vm

m("button", {onclick: vm.add.bind(vm, vm.description)}, "追加")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>view: function() {}
};

//go to the default route (home)
m.route(document.body, "/", {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135334Z" creationid="shibukawa.yoshiki" creationdate="20150502T135334Z">
        <seg>view: function() {}
};

//デフォルトラウト(home)に移動
m.route(document.body, "/", {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when save is called, it saves a contact (Contact.save(contact))</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T003052Z" creationid="shibukawa.yoshiki" creationdate="20150502T003052Z">
        <seg>saveが呼ばれると、連絡先を保存する(Contact.save(contact))。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when a new call to m.mount updates the root DOM element of the component in question</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091104Z" creationid="shibukawa.yoshiki" creationdate="20150502T091104Z">
        <seg>m.mount関数が当たらたに呼ばれ、指定されたコンポーネントのルートのDOMエレメントが更新された時</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when a route changes (if you are using m.route)</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091125Z" creationid="shibukawa.yoshiki" creationdate="20150502T091125Z">
        <seg>m.routeを使ってラウトが変更された場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>yields:</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002425Z" creationid="shibukawa.yoshiki" creationdate="20150413T002425Z">
        <seg>生成される結果:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{ onclick: function(e) { /*do stuff*/ } }</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T154827Z" creationid="shibukawa.yoshiki" creationdate="20150413T154827Z">
        <seg>{ onclick: function(e) { /*ハンドラの処理コード*/ } }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{class: "active"} : {})

//use this idiom instead
m("li", {class: selected ?</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144400Z" creationid="shibukawa.yoshiki" creationdate="20150413T144400Z">
        <seg>{class: "active"} : {})

//代わりにこのイディオムを使う
m("li", {class: selected ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{id: 2, name: "Mary"}
]

//ajax and display a list of projects for John
m.render(document.body, ProjectList({key: people[0].id, value: people[0]})

//ajax and display a list of projects for Mary
m.render(document.body, ProjectList({key: people[1].id, value: people[1]})</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085750Z" creationid="shibukawa.yoshiki" creationdate="20150502T085737Z">
        <seg>{id: 2, name: "Mary"}
]

//AJAXでデータを取得し、Johnのプロジェクト一覧を表示
m.render(document.body, ProjectList({key: people[0].id, value: people[0]})

//AJAXでデータを取得し、Maryのプロジェクト一覧を表示
m.render(document.body, ProjectList({key: people[1].id, value: people[1]})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{title: "item 1", url: "/item1"}
];

m.render(document.body, [</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123335Z" creationid="shibukawa.yoshiki" creationdate="20150416T123335Z">
        <seg>{title: "アイテム 1", url: "/item1"}
];

m.render(document.body, [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{title: "item 1", url: "/item1"},</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002436Z" creationid="shibukawa.yoshiki" creationdate="20150413T002436Z">
        <seg>{title: "アイテム 1", url: "/item1"},</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{title: "item 2", url: "/item2"},</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002438Z" creationid="shibukawa.yoshiki" creationdate="20150413T002438Z">
        <seg>{title: "アイテム 2", url: "/item2"},</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{title: "item 3", url: "/item3"}
];

m.render(document.body, [</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002442Z" creationid="shibukawa.yoshiki" creationdate="20150413T002442Z">
        <seg>{title: "アイテム 3", url: "/item3"}
];

m.render(document.body, [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//ContactList is the same as before
var ContactList = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031334Z" creationid="shibukawa.yoshiki" creationdate="20150502T031334Z">
        <seg>}
}

//ContactListは前の実装と同じ
var ContactList = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//ContactList no longer calls `Contact.save`
var ContactForm = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031314Z" creationid="shibukawa.yoshiki" creationdate="20150502T031314Z">
        <seg>}
}

//ContactListは`Contact.save`を呼ばない
var ContactForm = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//components that use the menu above
var Home = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124906Z" creationid="shibukawa.yoshiki" creationdate="20150502T124906Z">
        <seg>}
}

//上記のメニューを使用するコンポーネント
var Home = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//create a component whose controller and view functions receive some arguments
var component = m.component(MyComponent, {name: "world"}, "this is a test")

var ctrl = new component.controller() // logs "world", "this is a test"

m.render(document.body, component.view(ctrl)) // render the virtual DOM tree manually

//&lt;body&gt;Hello world this is a test&lt;/body&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075939Z" creationid="shibukawa.yoshiki" creationdate="20150502T075909Z">
        <seg>}
}

//controllerとviewが同じ値を受け取るコンポーネントを作成する
var component = m.component(MyComponent, {name: "world"}, "this is a test")

var ctrl = new component.controller() // 表示: "world", "this is a test"

m.render(document.body, component.view(ctrl)) // 手動で仮想DOMツリーをレンダリング

//&lt;body&gt;Hello world this is a test&lt;/body&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//end component



//usage
var Dashboard = {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045300Z" creationid="shibukawa.yoshiki" creationdate="20150502T045255Z">
        <seg>}
}

//コンポーネントの定義はここまで


//使用方法
var Dashboard = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//in the view
demo.view = function(ctrl) {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001806Z" creationid="shibukawa.yoshiki" creationdate="20150415T001806Z">
        <seg>}
}

//ビュー内
demo.view = function(ctrl) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//setup routes to start w/ the `#` symbol
m.route.mode = "hash";

//define a route
m.route(document.body, "/dashboard/johndoe", {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003247Z" creationid="shibukawa.yoshiki" creationdate="20150410T003247Z">
        <seg>}
}

//#記号から始まるラウトを使用するための設定
m.route.mode = "hash";

//ラウトの定義
m.route(document.body, "/dashboard/johndoe", {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

//view
var view = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144844Z" creationid="shibukawa.yoshiki" creationdate="20150416T144844Z">
        <seg>}
}

//ビュー
var view = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

m.mount(document.body, MyComponent)

//renders:
//&lt;a href="javascript:;"&gt;Count: 0&lt;/a&gt;
//
//the number increments when the link is clicked</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071359Z" creationid="shibukawa.yoshiki" creationdate="20150502T071338Z">
        <seg>}
}

m.mount(document.body, MyComponent)

//以下のようにレンダリングされる
//&lt;a href="javascript:;"&gt;Count: 0&lt;/a&gt;
//
//リンクがクリックされるたびにカウンタがインクリメントされる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

m.mount(document.body, MyComponent) // renders Hello</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072121Z" creationid="shibukawa.yoshiki" creationdate="20150502T072121Z">
        <seg>}
}

m.mount(document.body, MyComponent) // 表示: Hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}

m.mount(document.body, MyComponent) // renders Hello into &lt;body&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061408Z" creationid="shibukawa.yoshiki" creationdate="20150502T061408Z">
        <seg>}
}

m.mount(document.body, MyComponent) // &lt;body&gt;にHelloと表示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
});

//assuming the response is: `{data: [{name: "John"}, {name: "Mary"}], count: 2}`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174638Z" creationid="shibukawa.yoshiki" creationdate="20150410T174638Z">
        <seg>}
});

//レスポンスには`{data: [{name: "John"}, {name: "Mary"}], count: 2}`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
};

/**
Select2 config factory.</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045219Z" creationid="shibukawa.yoshiki" creationdate="20150502T045219Z">
        <seg>}
};

/**
Select2 configファクトリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
};

// mount on the same DOM element, replacing MyComponent
m.mount(document.body, AnotherComponent); // logs "unloading my component"</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091736Z" creationid="shibukawa.yoshiki" creationdate="20150502T091736Z">
        <seg>}
};

// 同じDOMエレメントに対してマウントし、MyComponentを置き換え
m.mount(document.body, AnotherComponent); // ログ: "MyComponentコンポーネントを削除しています"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
};

m.render(document, m("div", {config: unloadable}));

m.render(document, m("a")); //logs `unloaded the div` and `alert` never gets called</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124538Z" creationid="shibukawa.yoshiki" creationdate="20150413T130519Z">
        <seg>}
};

m.render(document, m("div", {config: unloadable}));

m.render(document, m("a")); //`divをアンロード`とログに表示されるが、`alert`は呼ばれない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>})

//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175232Z" creationid="shibukawa.yoshiki" creationdate="20150414T175232Z">
        <seg>})

//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>});
}

//controller
var controller = function() {</seg>
      </tuv>
      <tuv lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124220Z" creationid="shibukawa.yoshiki" creationdate="20150410T124220Z">
        <seg>});
}

//コントローラ
var controller = function() {</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
