<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="3.1.9" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv xml:lang="EN-US">
        <seg>"/blog/:date...": Component1, //for the default path in the line above, this route matches first!</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135234Z" creationid="shibukawa.yoshiki" creationdate="20150502T135234Z">
        <seg>"/blog/:date...": Component1, //上記のデフォルトパスはこのラウトに先にマッチします!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>"/blog/archive/:year": Component2
});

m.route.param("date") === "archive/2014"

//the routes should be flipped around to get `m.route.param("year") == "2014"`</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135300Z" creationid="shibukawa.yoshiki" creationdate="20150502T135300Z">
        <seg>"/blog/archive/:year": Component2
});

m.route.param("date") === "archive/2014"

//`m.route.param("year") == "2014"`が成立するように、ラウト定義の順番を変えること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>"/dashboard": Dashboard,
});

//re-route to dashboard
m.route("/dashboard"); // logs "unloading home"</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135617Z" creationid="shibukawa.yoshiki" creationdate="20150502T135350Z">
        <seg>"/dashboard": Dashboard,
});

//dashboardに移動
m.route("/dashboard"); // 表示 "ホームをアンロード"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>"name": "project-name-goes-here",</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150642Z" creationid="shibukawa.yoshiki" creationdate="20150412T150642Z">
        <seg>"name": "プロジェクト名はこちら",</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>"version": "0.0.0", //must follow this format</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150613Z" creationid="shibukawa.yoshiki" creationdate="20150412T150613Z">
        <seg>"version": "0.0.0", //このsemver形式のフォーマットを必ず使用してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(An execution thread is basically any amount of code that runs before other asynchronous threads start to run.)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135558Z" creationid="shibukawa.yoshiki" creationdate="20150412T135548Z">
        <seg>(実行スレッドは基本的に、他の非同期スレッドが実行する前に、ある程度の量のコードを含んでいます。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>.then(function(value) {console.log(value)}); //logs "hello world" after 1 second</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135104Z" creationid="shibukawa.yoshiki" creationdate="20150415T135104Z">
        <seg>.then(function(value) {console.log(value)}); //1秒後に"hello world"と表示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>.then(null, error) //handle the application error: bind to a getter-setter for diplaying it on the template</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173433Z" creationid="shibukawa.yoshiki" creationdate="20150415T173433Z">
        <seg>.then(null, error) //アプリケーションのエラーをテンプレートで表示するためにsetter-getterにバインド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>.then(users, error); //on success, `users` will be populated, otherwise `error` will be populated
//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of User instances
//i.e. users()[0].name() == "John"</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135118Z" creationid="shibukawa.yoshiki" creationdate="20150414T135118Z">
        <seg>.then(users, error); //成功時には`users`が変更され、それ以外では`error`が変更される
//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users()[0].name() == "John"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/* draws stuff */
}

var view = [</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123532Z" creationid="shibukawa.yoshiki" creationdate="20150413T123532Z">
        <seg>/* 描画コード */
}

var view = [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Your tests here...
}</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161345Z" creationid="shibukawa.yoshiki" creationdate="20150416T161345Z">
        <seg>//テストはこちら
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//...so that Mithril autoredraws the view after calling the controller callback</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021758Z" creationid="shibukawa.yoshiki" creationdate="20150412T021758Z">
        <seg>//...Mithrilはコントローラのコールバックが呼ばれた後に再描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//Calling .map doesn't throw an error because we defined the initial value to be an empty array, instead of undefined</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151107T161403Z" creationid="shibukawa.yoshiki" creationdate="20150415T001934Z">
        <seg>//初期値としてundefinedに代わりに空の配列を定義したため、この.mapはエラーにならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//Note that the '#' is not required in `href`, thanks to the `config` setting.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013325Z" creationid="shibukawa.yoshiki" creationdate="20150410T013325Z">
        <seg>//`config`の設定を使うことで、`href`内に'#'を書かなくてもよくなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//Select2 component (assumes both jQuery and Select2 are included in the page)
var Select2 = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045128Z" creationid="shibukawa.yoshiki" creationdate="20150502T045128Z">
        <seg>//Select2コンポーネント(jQueryとSelect2が両方読み込まれている)
var Select2 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//This is a simplication for the sake of the example.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062229Z" creationid="shibukawa.yoshiki" creationdate="20150502T062229Z">
        <seg>//これはサンプル用として単純化している</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//This view gets rendered before the request above completes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151107T161147Z" creationid="shibukawa.yoshiki" creationdate="20150415T001852Z">
        <seg>//このビューはデータが利用可能になる前にレンダリングされる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//Typically, values are modified via model methods,</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071245Z" creationid="shibukawa.yoshiki" creationdate="20150502T071245Z">
        <seg>//通常はモデルのメソッドを使って値を変更する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//`background` option example
var component = m.component({</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114008Z" creationid="shibukawa.yoshiki" creationdate="20150502T114008Z">
        <seg>//`background`オプションのサンプル
var component = m.component({</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//a FP-friendly console.log
var log = function(value) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151107T161428Z" creationid="shibukawa.yoshiki" creationdate="20150414T175127Z">
        <seg>//関数プログラミングと相性の良いconsole.log
var log = function(value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//a component without a controller
var MyComponent = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072107Z" creationid="shibukawa.yoshiki" creationdate="20150502T072107Z">
        <seg>//コントローラなしのコンポーネント
var MyComponent = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//a contrived example of bi-directional data binding
var User = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125823Z" creationid="shibukawa.yoshiki" creationdate="20150502T125823Z">
        <seg>//双方向データバインディングのサンプル
var User = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//a data store
var name = m.prop("")

//binding the data store in a view
m("input", {oninput: m.withAttr("value", name), value: name()})</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014141Z" creationid="shibukawa.yoshiki" creationdate="20150413T014125Z">
        <seg>//データストア
var name = m.prop("")

//データをビューにバインド
m("input", {oninput: m.withAttr("value", name), value: name()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//a menu template
var menu = function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T134837Z" creationid="shibukawa.yoshiki" creationdate="20150413T134837Z">
        <seg>//メニューテンプレート
var menu = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//a running list of todos</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161604Z" creationid="shibukawa.yoshiki" creationdate="20150407T161555Z">
        <seg>//アクティブなToDoのリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//a sample component
var Dashboard = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135145Z" creationid="shibukawa.yoshiki" creationdate="20150502T135145Z">
        <seg>//サンプルコンポーネント
var Dashboard = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//a sample module
var dashboard = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003122Z" creationid="shibukawa.yoshiki" creationdate="20150410T003122Z">
        <seg>//サンプルモジュール
var dashboard = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//a simple MVC example

//a sample model that exposes a value
var model = {count: 0}

var MyComponent = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062209Z" creationid="shibukawa.yoshiki" creationdate="20150502T062135Z">
        <seg>//シンプルなMVCモデル

//値を公開するサンプルのモデル
var model = {count: 0}

var MyComponent = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//a slot to store the name of a new todo before it is created</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161736Z" creationid="shibukawa.yoshiki" creationdate="20150407T161736Z">
        <seg>//新しいToDoを作成する前の、入力中のToDoの名前を保持するスロット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//add one more user to the response</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175149Z" creationid="shibukawa.yoshiki" creationdate="20150414T175149Z">
        <seg>//レスポンスにユーザをもう一人追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//adds a todo to the list, and clears the description field for user convenience</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161944Z" creationid="shibukawa.yoshiki" creationdate="20150407T161944Z">
        <seg>//ToDoをリストに登録し、ユーザが使いやすいようにdescriptionフィールドをクリアする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//alerts the title of the body element when it's clicked</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140700Z" creationid="shibukawa.yoshiki" creationdate="20150414T140700Z">
        <seg>//bodyエレメントのタイトルがクリックされたらアラートを出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//an empty Mithril component
var myComponent = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040256Z" creationid="shibukawa.yoshiki" creationdate="20150502T040256Z">
        <seg>//空のMithrilコンポーネント
var myModule = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//an expensive-to-initialize DOM element</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T134955Z" creationid="shibukawa.yoshiki" creationdate="20150413T134955Z">
        <seg>//最初期化が非常に高価(つもり)のDOMエレメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//assume the file comes from an HTML5 drag-n-drop event
var file = e.dataTransfer.files[0]

var data = new FormData();
data.append("file", file)

m.request({</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175511Z" creationid="shibukawa.yoshiki" creationdate="20150414T175511Z">
        <seg>//ファイルはHTML5のドラッグアンドドロップイベントで渡されたとする
var file = e.dataTransfer.files[0]

var data = new FormData();
data.append("file", file)

m.request({</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//assume the variable `link` came from a web service
var link = {url: "http://google.com", title: "Google"}

m("a", {href: link.url}, link.title); //yields &lt;a href="http://google.com"&gt;Google&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002350Z" creationid="shibukawa.yoshiki" creationdate="20150413T002336Z">
        <seg>//この`link`変数の値はウェブサービスから返ってきた値という想定
var link = {url: "http://google.com", title: "Google"}

m("a", {href: link.url}, link.title); //&lt;a href="http://google.com"&gt;Google&lt;/a&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//assume this content comes from the server
var content = "<bpt i="1" x="1">&lt;h1&gt;</bpt>Error: invalid user<ept i="1">&lt;/h1&gt;</ept>";

m.render("body", [</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015415Z" creationid="shibukawa.yoshiki" creationdate="20150416T015355Z">
        <seg>//サーバから送られてきたコンテンツとする
var content = "<bpt i="1" x="1">&lt;h1&gt;</bpt>エラー: ユーザ名が違います<ept i="1">&lt;/h1&gt;</ept>";

m.render("body", [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//asynchronous service
var greetAsync = function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135205Z" creationid="shibukawa.yoshiki" creationdate="20150415T135205Z">
        <seg>//非同期サービス
var greetAsync = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//avoid using this idiom
m("li", selected ?</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144408Z" creationid="shibukawa.yoshiki" creationdate="20150413T144340Z">
        <seg>//このイディオムは避けること
m("li", selected ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//binding a model value to an input in a template
m("input", {value: todo.vm.description()})</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014920Z" creationid="shibukawa.yoshiki" creationdate="20150408T014920Z">
        <seg>//モデルの値と、テンプレート内のテキスト入力を結びつける
m("input", {value: todo.vm.description()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//by default `e` would be caught by Mithril's promise exception monitor and rethrown to the console</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181341Z" creationid="shibukawa.yoshiki" creationdate="20150414T181341Z">
        <seg>//デフォルトでは`e`はMithrilのpromiseの例外モニタがキャッチして、コンソールに向けて再度投げる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//controller
var controller = function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124657Z" creationid="shibukawa.yoshiki" creationdate="20150410T124657Z">
        <seg>//コントローラ
var controller = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//declare a component
var MyComponent = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075737Z" creationid="shibukawa.yoshiki" creationdate="20150502T075737Z">
        <seg>//コンポーネント宣言
var MyComponent = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//define a getter-setter with initial value `John`
var a_name = m.prop("John");

//read the value
var a = a_name(); //a == "John"

//set the value to `Mary`
a_name("Mary"); //Mary

//read the value
var b = a_name(); //b == "Mary"</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040805Z" creationid="shibukawa.yoshiki" creationdate="20150407T150547Z">
        <seg>//'John'を初期値として、getter-setterを定義する
var a_name = m.prop("John");

//値を取得する
var a = a_name(); //a == "John"

//値を`Mary`に設定する
a_name("Mary"); //Mary

//値を取得する
var b = a_name(); //b == "Mary"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//define a getter-setter with initial value `John`
var name = m.prop("John");

//read the value
var a = name(); //a == "John"

//set the value to `Mary`
name("Mary"); //Mary

//read the value
var b = name(); //b == "Mary"</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134314Z" creationid="shibukawa.yoshiki" creationdate="20150414T134217Z">
        <seg>/`John`という値でgetter-setterを初期化
var name = m.prop("John");

//値を取得する
var a = name(); //a == "John"

//値を`Mary`に設定する
name("Mary"); //Mary

//値を取得する
var b = name(); //b == "Mary"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//define some helper functions to be called from the view</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081234Z" creationid="shibukawa.yoshiki" creationdate="20150502T081234Z">
        <seg>//ビューから呼ばれるヘルパー関数をいくつか定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//define the view-model
todo.vm = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161524Z" creationid="shibukawa.yoshiki" creationdate="20150407T161524Z">
        <seg>//ビュー・モデルの定義
todo.vm = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//diff when routing, instead of redrawing from scratch
//this preserves the `&lt;input&gt;` element and its 3rd party plugin after route changes, since the `&lt;input&gt;` doesn't change
var Component1 = m.component({</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114130Z" creationid="shibukawa.yoshiki" creationdate="20150502T114130Z">
        <seg>//ゼロから再描画するのではなく、ラウト変更時にも差分検知をする
//ラウト変更後も`&lt;input&gt;`エレメントと、それに追加されたサードパーティプラグインが維持される
var Component1 = m.component({</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//diff when routing, instead of redrawing from scratch
//this preserves the `&lt;input&gt;` element and its 3rd party plugin after route changes, since the `&lt;input&gt;` doesn't change
var Component1 = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130834Z" creationid="shibukawa.yoshiki" creationdate="20150502T130834Z">
        <seg>//ゼロから再描画するのではなく、ラウト変更時にも差分検知をする
//ラウト変更後も`&lt;input&gt;`エレメントと、それに追加されたサードパーティプラグインが維持される
var Component1 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//don't redraw if we did once already</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123518Z" creationid="shibukawa.yoshiki" creationdate="20150413T123518Z">
        <seg>//一度描画したら再描画はしない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//don't wait for this service; redraw right away</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135932Z" creationid="shibukawa.yoshiki" creationdate="20150415T135932Z">
        <seg>//サービスを待たずに即座に再描画する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//dynamic variables are not updated here</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124628Z" creationid="shibukawa.yoshiki" creationdate="20150416T124628Z">
        <seg>//ここの動的変数は更新されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//dynamic variables here still update on every redraw</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124654Z" creationid="shibukawa.yoshiki" creationdate="20150416T124654Z">
        <seg>//ここの動的変数は再描画のたびに更新される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//end integration</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021809Z" creationid="shibukawa.yoshiki" creationdate="20150412T021809Z">
        <seg>//統合処理の完了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//here's the view
m("table", [</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152907Z" creationid="shibukawa.yoshiki" creationdate="20150408T152907Z">
        <seg>//これがビュー
m("table", [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//if the location bar is "http://example.com/?/foo/bar"
//and m.route.mode is `search`
//then `currentRoute == "/foo/bar"`
var currentRoute = m.route();</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172156Z" creationid="shibukawa.yoshiki" creationdate="20150414T172156Z">
        <seg>//もしロケーションバーが"http://example.com/?/foo/bar"
//で、m.route.modeが`search`の場合は、
//`currentRoute == "/foo/bar"`
var currentRoute = m.route();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//in the first redraw, there's no user, so ensure we don't throw an error</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134843Z" creationid="shibukawa.yoshiki" creationdate="20150502T134843Z">
        <seg>//最初の描画時はユーザがいないが、エラーにはならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//in this case, it simply assumes data has changed the first time, and never changes after that.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124552Z" creationid="shibukawa.yoshiki" creationdate="20150416T124552Z">
        <seg>//この場合、初回だけ変更されてその後は変更されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//initialize our view-model
todo.vm.init();

todo.vm.description(); //[empty string]

//try adding a to-do
todo.vm.add(todo.vm.description);
todo.vm.list.length; //0, because you can't add a to-do with an empty description

//add it properly
todo.vm.description("Write code");
todo.vm.add(todo.vm.description);
todo.vm.list.length; //1</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163852Z" creationid="shibukawa.yoshiki" creationdate="20150407T163731Z">
        <seg>//ビュー・モデルの初期化
todo.vm.init();

todo.vm.description(); //[空文字列]

//Todoを登録してみる
todo.vm.add(todo.vm.description);
todo.vm.list.length; //空のdescriptionは登録できないので、0

//正しく登録できた
todo.vm.description("コードを書く");
todo.vm.add(todo.vm.description);
todo.vm.list.length; //1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//integrate with the auto-redrawing system...</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021727Z" creationid="shibukawa.yoshiki" creationdate="20150412T021727Z">
        <seg>//再描画システムと統合...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//list of users to show</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021945Z" creationid="shibukawa.yoshiki" creationdate="20150412T021945Z">
        <seg>//ユーザ一覧のリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//model
var Page = {
	list: function() {
		return m.request({method: "GET", url: "pages.json"});
	}
};

var Demo = {
	//controller
	controller: function() {
		var pages = Page.list();
		return {
			pages: pages,
			rotate: function() {
				pages().push(pages().shift());
			}
		}
	},

	//view
	view: function(ctrl) {
		return m("div", [
			ctrl.pages().map(function(page) {
				return m("a", {href: page.url}, page.title);
			}),
			m("button", {onclick: ctrl.rotate}, "Rotate links")
		]);
	};
};


//initialize
m.mount(document.getElementById("example"), Demo);</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114928Z" creationid="shibukawa.yoshiki" creationdate="20151106T114928Z">
        <seg>//model
var Page = {
	list: function() {
		return m.request({method: "GET", url: "pages.json"});
	}
};

var Demo = {
	//controller
	controller: function() {
		var pages = Page.list();
		return {
			pages: pages,
			rotate: function() {
				pages().push(pages().shift());
			}
		}
	},

	//view
	view: function(ctrl) {
		return m("div", [
			ctrl.pages().map(function(page) {
				return m("a", {href: page.url}, page.title);
			}),
			m("button", {onclick: ctrl.rotate}, "Rotate links")
		]);
	}
};


//initialize
m.mount(document.getElementById("example"), Demo);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//model
var User = {}

User.listEven = function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124209Z" creationid="shibukawa.yoshiki" creationdate="20150410T124209Z">
        <seg>//モデル
var User = {}

User.listEven = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//model
var saved = false
function save(e) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144851Z" creationid="shibukawa.yoshiki" creationdate="20150416T144851Z">
        <seg>//モデル
var saved = false
function save(e) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//model layer observer
Observable.on(["saveContact"], function(data) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031145Z" creationid="shibukawa.yoshiki" creationdate="20150502T031145Z">
        <seg>//モデルレイヤのオブザーバ
Observable.on(["saveContact"], function(data) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//nested component</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080106Z" creationid="shibukawa.yoshiki" creationdate="20150502T080106Z">
        <seg>//ネストされたコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//note how the controller does not handle the input arguments</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081219Z" creationid="shibukawa.yoshiki" creationdate="20150502T081216Z">
        <seg>//このコントローラは引数には触れない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//note that we are not updating the value of the `name` getter-setter via an event handler
//redraws will always overwrite the current UI value with the value of `name()`
m("input", {value: name()})</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015357Z" creationid="shibukawa.yoshiki" creationdate="20150413T015357Z">
        <seg>//このサンプルではイベントハンドラが`name` getter-setterの値を変更することはない
//再描画があるたびに現在のUI上の値が`name()`の値を使って書き換えられる
m("input", {value: name()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//now `deferred.resolve` has been called</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135304Z" creationid="shibukawa.yoshiki" creationdate="20150415T135304Z">
        <seg>//ここで `deferred.resolve` が呼ばれた</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//only runs once, even if you move back and forth between `/` and `/contact`</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135135Z" creationid="shibukawa.yoshiki" creationdate="20150413T135135Z">
        <seg>// `/` と`/contact` の間を何度行き来しても、一度だけ実行される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//onunload's preventDefault was called</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092405Z" creationid="shibukawa.yoshiki" creationdate="20150502T092405Z">
        <seg>//onunloadのpreventDefaultが呼ばれた</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//pressing the button reverses the list</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080401Z" creationid="shibukawa.yoshiki" creationdate="20150502T080401Z">
        <seg>//ボタンを押すとリストの順序が逆転する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//private store
var description;

//public getter-setter
this.description = function(value) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002509Z" creationid="shibukawa.yoshiki" creationdate="20150409T002456Z">
        <seg>//プライベート変数
var description;

//パブリックなgetter-setter
this.description = function(value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//rather than modified directly</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071253Z" creationid="shibukawa.yoshiki" creationdate="20150502T071253Z">
        <seg>//ここでは直接変更している</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//redraw again</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135940Z" creationid="shibukawa.yoshiki" creationdate="20150415T135940Z">
        <seg>//再び再描画する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//refactor the binding to a simple helper
var binds = function(prop) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015537Z" creationid="shibukawa.yoshiki" creationdate="20150413T015537Z">
        <seg>//バインディングをヘルパ関数にリファクタリング
var binds = function(prop) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//refactor the binding to a simple helper
var input = function(prop) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015642Z" creationid="shibukawa.yoshiki" creationdate="20150413T015642Z">
        <seg>//バインディングをシンプルなヘルパにリファクタリング
var input = function(prop) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//render the todo component inside the document DOM node
m.mount(document, {controller: todo.controller, view: todo.view});</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041712Z" creationid="shibukawa.yoshiki" creationdate="20150502T041712Z">
        <seg>//todoコンポーネントはdocument DOMノードの中でレンダリングする
m.mount(document, {controller: todo.controller, view: todo.view});</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//select Mary</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021951Z" creationid="shibukawa.yoshiki" creationdate="20150412T021951Z">
        <seg>//Maryを選択する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//set up select2 (only if not initialized already)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021656Z" creationid="shibukawa.yoshiki" creationdate="20150412T021656Z">
        <seg>//初期化されていなければselect2を初期化します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//setting `background` allows the component to redraw immediately, without waiting for the request to complete</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114043Z" creationid="shibukawa.yoshiki" creationdate="20150502T114043Z">
        <seg>//`background`を設定すると、リクエストの完了を待たずにすぐに再描画を行う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//simply pass the FormData object intact to the underlying XMLHttpRequest, instead of JSON.stringify'ing it</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034320Z" creationid="shibukawa.yoshiki" creationdate="20150502T034320Z">
        <seg>//JSON.stringifyをしないで、FormDataをそのままバックエンドのXMLHttpRequestに渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//standalone usage
document.body.onclick = m.withAttr("title", function(value) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140641Z" creationid="shibukawa.yoshiki" creationdate="20150414T140641Z">
        <seg>//単独での使用
document.body.onclick = m.withAttr("title", function(value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//standalone usage
var greetAsync = function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135043Z" creationid="shibukawa.yoshiki" creationdate="20150415T135043Z">
        <seg>//単体での利用
var greetAsync = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//swallow all errors
m.deferred.onerror = function() {}

//only log errors
m.deferred.onerror = function(e) {console.error(e)}</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174841Z" creationid="shibukawa.yoshiki" creationdate="20150415T174826Z">
        <seg>//すべてのエラーを無視する
m.deferred.onerror = function() {}

//エラーを単にログに出力する
m.deferred.onerror = function(e) {console.error(e)}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//tell Mithril to wait for this service to complete before redrawing</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135537Z" creationid="shibukawa.yoshiki" creationdate="20150415T135537Z">
        <seg>//Mithrilにサービス呼び出しが終わるまで再描画を待つように伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//test a transformation function in the controller
var ctrl = new TemperatureConverter.controller();
assert(ctrl.kelvinToCelsius(273.15) == 0)

//test the template
var tpl = TemperatureConverter.view(null, {value: 273.15})
assert(tpl.children[1] == 0)

//test with real DOM
var testRoot = document.createElement("div")
m.render(testRoot, TemperatureConverter.view(null, {value: 273.15}))
assert(testRoot.innerHTML.indexOf("celsius:0") &gt; -1)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081642Z" creationid="shibukawa.yoshiki" creationdate="20150502T081557Z">
        <seg>//controller内の変換関数のテスト
var ctrl = new TemperatureConverter.controller();
assert(ctrl.kelvinToCelsius(273.15) == 0)

//テンプレートのテスト
var tpl = TemperatureConverter.view(null, {value: 273.15})
assert(tpl.children[1] == 0)

//実際のDOMのテスト
var testRoot = document.createElement("div")
m.render(testRoot, TemperatureConverter.view(null, {value: 273.15}))
assert(testRoot.innerHTML.indexOf("celsius:0") &gt; -1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//the key ensures the components aren't recreated from scratch, if they merely exchanged places</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080435Z" creationid="shibukawa.yoshiki" creationdate="20150502T080435Z">
        <seg>//キーがあると、場所の移動時にDOMが再生成されるのを防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//the service is done, tell Mithril that it may redraw</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135600Z" creationid="shibukawa.yoshiki" creationdate="20150415T135600Z">
        <seg>//サービスが完了したら、Mithrilに再描画するように伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//this allows config contexts to live across route changes, if its element does not need to be recreated by the diff</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143800Z" creationid="shibukawa.yoshiki" creationdate="20150416T143800Z">
        <seg>//これにより、エレメントの再生成が不要な時は、configコンテキストがラウト変更時にも破棄されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//this causes a redraw, since event handlers active auto-redrawing by default</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144817Z" creationid="shibukawa.yoshiki" creationdate="20150416T144817Z">
        <seg>//デフォルトでイベントハンドラは自動再描画を起動するため再描画が行われる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//this component will attempt to diff its template when routing, as opposed to re-creating the view from scratch.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130645Z" creationid="shibukawa.yoshiki" creationdate="20150502T130645Z">
        <seg>//このコンポーネントはラウトの変更時にもゼロからビューを作りなおすのではなく、差分検知を行う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//this event handler updates the controller when the view changes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021716Z" creationid="shibukawa.yoshiki" creationdate="20150412T021716Z">
        <seg>//このイベントハンドラはビューが変更されたときにコントローラを更新します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//this link can use any of Mithril's routing system modes
//(i.e. it can use either the hash, the querystring or the pathname as the router implementation)
//without needing to hard-code any syntax (`#` or `?`) in the `href` attribute.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124305Z" creationid="shibukawa.yoshiki" creationdate="20150413T124131Z">
        <seg>//このリンクはどのMithrilのラウティングシステムのモードでも使用できる。
//ラウティングのモードにはhash, querystring, pathnameがあるが、
//`href`属性で、ラウティングの文法(`#`, `?`)をハードコードする必要はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//this new error follows Promises/A+ specifications and triggers a rejection in the downstream promises without hitting the console.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181833Z" creationid="shibukawa.yoshiki" creationdate="20150414T181833Z">
        <seg>//このエラーはPromises/A+の仕様にしたがって下流のpromiseのリジェクトに渡される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//this only runs once in order to boost performance</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124613Z" creationid="shibukawa.yoshiki" creationdate="20150416T124613Z">
        <seg>//パフォーマンスの最適化のために、一度しか実行されない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//this service waits 1 second, logs "hello" and then notifies the view that
//it may start redrawing (if no other asynchronous operations are pending)
var doStuff = function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192927Z" creationid="shibukawa.yoshiki" creationdate="20150411T192927Z">
        <seg>//このサービスは1秒間待ってログに"hello"と出力し、その後ビューに
//再描画を行うように知らせています (他の非同期処理により延期されないかぎり)
var doStuff = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//this view implements select2's `&lt;select&gt;` progressive enhancement mode</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045157Z" creationid="shibukawa.yoshiki" creationdate="20150502T045157Z">
        <seg>//このビューはselect2の`&lt;select&gt;`プログレッシブ拡張モードを実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//this view renders twice (once immediately, and once after the request above completes)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012109Z" creationid="shibukawa.yoshiki" creationdate="20150415T012109Z">
        <seg>//このビューは初回と上記のリクエストの完了後の2回再描画が行われる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//update the view with the latest controller value</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021827Z" creationid="shibukawa.yoshiki" creationdate="20150412T021827Z">
        <seg>//最新のコントローラの値を使ってビューを更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//usage demo 1: standalone multipart/form-data upload when files are dropped into the component
var Demo1 = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034723Z" creationid="shibukawa.yoshiki" creationdate="20150502T034723Z">
        <seg>//デモ1: コンポーネントにファイルがドロップされた時にmultipart/form-dataでアップロード
var Demo1 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//usage demo 2: upload as base-64 encoded data url from a parent form
var Demo2 = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034820Z" creationid="shibukawa.yoshiki" creationdate="20150502T034820Z">
        <seg>//デモ2: base64のデータURLとしてデータをアップロード
var Demo2 = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//we don't care about other keys, so don't redraw</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144836Z" creationid="shibukawa.yoshiki" creationdate="20150416T144836Z">
        <seg>//他のキーについては無視したいので、再描画も行わない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>//we only want to make this call once</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084510Z" creationid="shibukawa.yoshiki" creationdate="20150502T084510Z">
        <seg>//このコードは一度しか呼ばれない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;!doctype html&gt;
&lt;script src="mithril.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
//this application only has one component: todo
var todo = {};

//for simplicity, we use this component to namespace the model classes

//the Todo class has two properties
todo.Todo = function(data) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041742Z" creationid="shibukawa.yoshiki" creationdate="20150502T041732Z">
        <seg>&lt;!doctype html&gt;
&lt;script src="mithril.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
//このアプリケーションは、todoコンポーネントを1つだけ持つ
var todo = {};

//コードをシンプルにするために、このコンポーネントをモデルクラスの名前空間としても流用する

//Todoクラスは2つのプロパティを持つ
todo.Todo = function(data) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;!doctype html&gt;
&lt;title&gt;Todo app&lt;/title&gt;
&lt;script src="mithril.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
//app goes here
&lt;/script&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142715Z" creationid="shibukawa.yoshiki" creationdate="20150407T142701Z">
        <seg>&lt;!doctype html&gt;
&lt;title&gt;ToDoアプリケーション&lt;/title&gt;
&lt;script src="mithril.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
//アプリケーションコードはここ
&lt;/script&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;a href="/item1"&gt;item 1&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002523Z" creationid="shibukawa.yoshiki" creationdate="20150413T002523Z">
        <seg>&lt;a href="/item1"&gt;アイテム 1&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> (if your app only has one page)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071721Z" creationid="shibukawa.yoshiki" creationdate="20150502T071721Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> (ページを1つしか持たない場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.prop<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> is a simple but surprisingly versatile tool: it's functionally composable, it enables <bpt i="2" x="2">&lt;a2&gt;</bpt>uniform data access<ept i="2">&lt;/a2&gt;</ept> and allows a higher degree of decoupling when major refactoring is required.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114149Z" creationid="shibukawa.yoshiki" creationdate="20150409T001957Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.prop<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>はシンプルですが、とても幅広く使えるツールです。関数型のパラダイムを使えるようにしたり、<bpt i="2" x="2">&lt;a2&gt;</bpt>データアクセスの統一化<ept i="2">&lt;/a2&gt;</ept>をしたり、リファクタリングが必要になったときに簡単に行えるように高度な疎結合化をするのに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.prop<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> is simply a factory for a getter-setter function.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150505Z" creationid="shibukawa.yoshiki" creationdate="20150407T150505Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.prop<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>はgetter-setter関数を作るための、単純なファクトリです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.render<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> (if you are integrating Mithril's rendering engine into a larger framework and wish to manage redrawing yourself).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071757Z" creationid="shibukawa.yoshiki" creationdate="20150502T071757Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.render<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> (Mithrilのレンダリングエンジンを他のシステムに統合し、レンダリングを自分で制御したい場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.route<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> (if you are building a single-page application that has multiple pages)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071657Z" creationid="shibukawa.yoshiki" creationdate="20150502T071657Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.route<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> (複数ページ持つシングルページアプリケーションを作りたい場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>○<ept i="1">&lt;/s1&gt;</ept> Mithril<ept i="0">&lt;/a0&gt;</ept> <bpt i="2" x="2">&lt;a2&gt;</bpt>Guide<ept i="2">&lt;/a2&gt;</ept> <bpt i="3" x="3">&lt;a3&gt;</bpt>API<ept i="3">&lt;/a3&gt;</ept> <bpt i="4" x="4">&lt;a4&gt;</bpt>Community<ept i="4">&lt;/a4&gt;</ept> <bpt i="5" x="5">&lt;a5&gt;</bpt>Learn<ept i="5">&lt;/a5&gt;</ept> <bpt i="6" x="6">&lt;a6&gt;</bpt>Download<ept i="6">&lt;/a6&gt;</ept> <bpt i="7" x="7">&lt;a7&gt;</bpt>Github<ept i="7">&lt;/a7&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T132024Z" creationid="shibukawa.yoshiki" creationdate="20150407T131933Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>○<ept i="1">&lt;/s1&gt;</ept> Mithril<ept i="0">&lt;/a0&gt;</ept> <bpt i="2" x="2">&lt;a2&gt;</bpt>ガイド<ept i="2">&lt;/a2&gt;</ept> <bpt i="3" x="3">&lt;a3&gt;</bpt>API<ept i="3">&lt;/a3&gt;</ept> <bpt i="4" x="4">&lt;a4&gt;</bpt>コミュニティ<ept i="4">&lt;/a4&gt;</ept> <bpt i="5" x="5">&lt;a5&gt;</bpt>もっと知る<ept i="5">&lt;/a5&gt;</ept> <bpt i="6" x="6">&lt;a6&gt;</bpt>ダウンロード<ept i="6">&lt;/a6&gt;</ept> <bpt i="7" x="7">&lt;a7&gt;</bpt>Github<ept i="7">&lt;/a7&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>Bower<ept i="0">&lt;/a0&gt;</ept> is a package manager for <bpt i="1" x="1">&lt;a1&gt;</bpt>NodeJS<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T170224Z" creationid="shibukawa.yoshiki" creationdate="20150407T170224Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>Bower<ept i="0">&lt;/a0&gt;</ept>は<bpt i="1" x="1">&lt;a1&gt;</bpt>NodeJS<ept i="1">&lt;/a1&gt;</ept>のためのパッケージマネージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>Component<ept i="0">&lt;/a0&gt;</ept> is another package manager for <bpt i="1" x="1">&lt;a1&gt;</bpt>NodeJS<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235559Z" creationid="shibukawa.yoshiki" creationdate="20150407T235559Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>Component<ept i="0">&lt;/a0&gt;</ept>も、<bpt i="1" x="1">&lt;a1&gt;</bpt>NodeJS<ept i="1">&lt;/a1&gt;</ept>向けのパッケージマネージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>ES5 Shim<ept i="0">&lt;/a0&gt;</ept> or Mozilla.org's <bpt i="1" x="1">&lt;a1&gt;</bpt>Array::indexOf<ept i="1">&lt;/a1&gt;</ept>, <bpt i="2" x="2">&lt;a2&gt;</bpt>Array::map<ept i="2">&lt;/a2&gt;</ept> and <bpt i="3" x="3">&lt;a3&gt;</bpt>Object::keys<ept i="3">&lt;/a3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014856Z" creationid="shibukawa.yoshiki" creationdate="20150417T014856Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>ES5 Shim<ept i="0">&lt;/a0&gt;</ept>もしくは、Mozillaの<bpt i="1" x="1">&lt;a1&gt;</bpt>Array::indexOf<ept i="1">&lt;/a1&gt;</ept>、<bpt i="2" x="2">&lt;a2&gt;</bpt>Array::map<ept i="2">&lt;/a2&gt;</ept>、<bpt i="3" x="3">&lt;a3&gt;</bpt>Object::keys<ept i="3">&lt;/a3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>Read more<ept i="0">&lt;/a0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135001Z" creationid="shibukawa.yoshiki" creationdate="20150407T135001Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>より詳しい説明<ept i="0">&lt;/a0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;a2&gt;</bpt>IE9 and lower<ept i="2">&lt;/a2&gt;</ept> do not support this feature and will gracefully degrade to page refreshes instead.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015322Z" creationid="shibukawa.yoshiki" creationdate="20150417T015218Z">
        <seg><bpt i="2" x="2">&lt;a2&gt;</bpt>IE9とそれ以下のブラウザ<ept i="2">&lt;/a2&gt;</ept>はこの機能をサポートしていないため、リフレッシュが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>m.redraw<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept> forces a redraw to happen in the next available frame (or optionally, it can redraw immediately for synchronous processing).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192020Z" creationid="shibukawa.yoshiki" creationdate="20150411T192020Z">
        <seg><bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>m.redraw<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>を呼び出すと次のフレーム更新時に強制的に再描画を行います。また、オプションで同期処理として再描画を行わせることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>m.redraw.strategy<ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept> can change the way Mithril runs the next scheduled redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000533Z" creationid="shibukawa.yoshiki" creationdate="20150506T000533Z">
        <seg><bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>m.redraw.strategy<ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>を使うと、Mithrilが次に再描画を計画する方法を変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;button onclick={app.vm.add}&gt;Add&lt;/button&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013912Z" creationid="shibukawa.yoshiki" creationdate="20150417T013912Z">
        <seg>&lt;button onclick={app.vm.add}&gt;追加&lt;/button&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;button&gt;Add&lt;/button&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013845Z" creationid="shibukawa.yoshiki" creationdate="20150408T013845Z">
        <seg>&lt;button&gt;追加&lt;/button&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>"/grid?sortby=date"<ept i="0">&lt;/c0&gt;</ept> - here, <bpt i="1" x="1">&lt;c1&gt;</bpt>m.route.param("sortby")<ept i="1">&lt;/c1&gt;</ept> returns <bpt i="2" x="2">&lt;c2&gt;</bpt>"date"<ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170756Z" creationid="shibukawa.yoshiki" creationdate="20150414T170756Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>"/grid?sortby=date"<ept i="0">&lt;/c0&gt;</ept> - ここでは、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.route.param("sortby")<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>"date"<ept i="2">&lt;/c2&gt;</ept>を返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>"/path/to/page/:id"<ept i="0">&lt;/c0&gt;</ept> - here, <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept> is the name of the route parameter</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170625Z" creationid="shibukawa.yoshiki" creationdate="20150414T170618Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>"/path/to/page/:id"<ept i="0">&lt;/c0&gt;</ept> - ここでは、<bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>がラウトパラメータの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>"all"<ept i="0">&lt;/c0&gt;</ept> - recreates the DOM tree from scratch</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152312Z" creationid="shibukawa.yoshiki" creationdate="20150416T152312Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>"all"<ept i="0">&lt;/c0&gt;</ept> - すべて破棄してDOMツリーを再構築する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>"diff"<ept i="0">&lt;/c0&gt;</ept> - updates only DOM elements if needed</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152326Z" creationid="shibukawa.yoshiki" creationdate="20150416T152326Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>"diff"<ept i="0">&lt;/c0&gt;</ept> - 必要があればDOMエレメントを更新する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>"none"<ept i="0">&lt;/c0&gt;</ept> - leaves the DOM tree intact</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152341Z" creationid="shibukawa.yoshiki" creationdate="20150416T152341Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>"none"<ept i="0">&lt;/c0&gt;</ept> - DOMツリーを変更せずにそのままにする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ContactsWidget<ept i="0">&lt;/c0&gt;</ept> is the top level module being rendered to <bpt i="1" x="1">&lt;c1&gt;</bpt>document.body<ept i="1">&lt;/c1&gt;</ept>, and it is the module that has the responsibility of talking to our Model entity <bpt i="2" x="2">&lt;c2&gt;</bpt>Contact<ept i="2">&lt;/c2&gt;</ept>, which we defined earlier.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T001544Z" creationid="shibukawa.yoshiki" creationdate="20150502T001544Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ContactsWidget<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>document.body<ept i="1">&lt;/c1&gt;</ept>にレンダリングされる、最上位のモジュールです。また、これは先に定義していた<bpt i="2" x="2">&lt;c2&gt;</bpt>Contact<ept i="2">&lt;/c2&gt;</ept>モデルのエンティティと話をする責務を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hash<ept i="0">&lt;/c0&gt;</ept> mode uses the hash (i.e. <bpt i="1" x="1">&lt;c1&gt;</bpt>#<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170025Z" creationid="shibukawa.yoshiki" creationdate="20150414T170025Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hash<ept i="0">&lt;/c0&gt;</ept>モードはハッシュ(<bpt i="1" x="1">&lt;c1&gt;</bpt>#以降<ept i="1">&lt;/c1&gt;</ept>)を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hash<ept i="0">&lt;/c0&gt;</ept> mode uses the hash.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005129Z" creationid="shibukawa.yoshiki" creationdate="20150410T005129Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hash<ept i="0">&lt;/c0&gt;</ept>モードはハッシュを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept> can also be used in conjunction with <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.request<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> and <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>m.deferred<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept> to bind data on completion of an asynchronous operation.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134821Z" creationid="shibukawa.yoshiki" creationdate="20150414T134821Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.request<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>や<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>m.deferred<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>と組み合わせて、非同期操作の結果に対してデータを束縛することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw<ept i="0">&lt;/c0&gt;</ept> is a method that allows you to render a template outside the scope of Mithril's auto-redrawing system.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015835Z" creationid="shibukawa.yoshiki" creationdate="20150421T015835Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw<ept i="0">&lt;/c0&gt;</ept>を使うと、Mithrilの自動再描画システムのスコープ外から、再描画を行わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.render<ept i="0">&lt;/c0&gt;</ept> accepts a special low level SubtreeDirective object as a node in a virtual DOM tree: if a tree contains a node that looks exactly like the object below, Mithril will abort the diff algorithm for that node.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123617Z" creationid="shibukawa.yoshiki" creationdate="20150416T123617Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.render<ept i="0">&lt;/c0&gt;</ept>は、特別なSubtreeDirectiveオブジェクトを仮想DOMツリーのノードとして受け取ることができます。もし、ツリーが次のようなオブジェクトを含んでいると、Mithrilはこのノードに対する差分検知アルゴリズムを中断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.route()<ept i="0">&lt;/c0&gt;</ept> - returns the currently active route</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152813Z" creationid="shibukawa.yoshiki" creationdate="20150414T152813Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.route()<ept i="0">&lt;/c0&gt;</ept> - 現在アクティブなラウトの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.route(element)<ept i="0">&lt;/c0&gt;</ept> - an extension to link elements that unobtrusively abstracts away the routing mode</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153031Z" creationid="shibukawa.yoshiki" creationdate="20150414T153031Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.route(element)<ept i="0">&lt;/c0&gt;</ept> - ラウトのモードを抽象化し、現在のモードで利用可能なエレメントの実リンクを取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.route(path)<ept i="0">&lt;/c0&gt;</ept> - redirects to another route</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152759Z" creationid="shibukawa.yoshiki" creationdate="20150414T152759Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.route(path)<ept i="0">&lt;/c0&gt;</ept> - 他のラウトへリダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.route(rootElement, defaultRoute, routes)<ept i="0">&lt;/c0&gt;</ept> - defines the available URLs in an application, and their respective components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135009Z" creationid="shibukawa.yoshiki" creationdate="20150502T135009Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.route(rootElement, defaultRoute, routes)<ept i="0">&lt;/c0&gt;</ept> - アプリケーションで使用できるURLとその時にロードされるコンポーネントの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>pathname<ept i="0">&lt;/c0&gt;</ept> mode allows routing URLs that contain no special characters, however this mode requires server-side setup in order to support bookmarking and page refreshes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005430Z" creationid="shibukawa.yoshiki" creationdate="20150410T005430Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>pathname<ept i="0">&lt;/c0&gt;</ept>モードは特別な文字を含まないURLを許可します。しかし、このモードでブックマークとページリフレッシュをサポートするためには、サーバ側にも手を加える必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>pathname<ept i="0">&lt;/c0&gt;</ept> mode allows routing URLs that contains no special characters, however this mode requires server-side setup in order to support bookmarking and page refreshes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170054Z" creationid="shibukawa.yoshiki" creationdate="20150414T170054Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>pathname<ept i="0">&lt;/c0&gt;</ept>モードは特別な文字を含まないURLを許可します。しかし、このモードでブックマークとページリフレッシュをサポートするためには、サーバ側にも手を加える必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>search<ept i="0">&lt;/c0&gt;</ept> mode uses the querystring (i.e. <bpt i="1" x="1">&lt;c1&gt;</bpt>?<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165825Z" creationid="shibukawa.yoshiki" creationdate="20150414T165825Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>search<ept i="0">&lt;/c0&gt;</ept>モードはクエリー文字列 (<bpt i="1" x="1">&lt;c1&gt;</bpt>?<ept i="1">&lt;/c1&gt;</ept>以降)を利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>search<ept i="0">&lt;/c0&gt;</ept> mode uses the querystring.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004858Z" creationid="shibukawa.yoshiki" creationdate="20150410T004858Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>search<ept i="0">&lt;/c0&gt;</ept>モードはクエリー文字列を利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>select2.config<ept i="0">&lt;/c0&gt;</ept> is a factory that creates a <bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept> function based on a given controller.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133322Z" creationid="shibukawa.yoshiki" creationdate="20150412T133322Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>select2.config<ept i="0">&lt;/c0&gt;</ept>は、与えられたコントローラに対応する<bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept>関数を作成するファクトリー関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>update<ept i="0">&lt;/c0&gt;</ept> is the controller function itself, so defining it as a promise callback simply means that the controller is re-initialized after the previous asynchronous operation (<bpt i="1" x="1">&lt;c1&gt;</bpt>Contact.save()<ept i="1">&lt;/c1&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T003837Z" creationid="shibukawa.yoshiki" creationdate="20150502T003837Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>update<ept i="0">&lt;/c0&gt;</ept>はコントローラの関数そのものです。それをPromiseのコールバックとして定義するとということは、非同期操作(<bpt i="1" x="1">&lt;c1&gt;</bpt>Contact.save()<ept i="1">&lt;/c1&gt;</ept>)が完了したあとにコントローラを再初期化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>{'/path/to/page/': pageComponent}<ept i="0">&lt;/c0&gt;</ept> - a route with a basic pathname</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135713Z" creationid="shibukawa.yoshiki" creationdate="20150502T135713Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>{'/path/to/page/': pageComponent}<ept i="0">&lt;/c0&gt;</ept> - 基本パス名のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>{'/path/to/page/:id': pageComponent}<ept i="0">&lt;/c0&gt;</ept> - a route with a pathname that contains a dynamic parameter called <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135725Z" creationid="shibukawa.yoshiki" creationdate="20150502T135725Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>{'/path/to/page/:id': pageComponent}<ept i="0">&lt;/c0&gt;</ept> - <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>と呼ばれる動的パラメータを含むパス名のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>{'/user/:userId/book/:bookId': userBookComponent}<ept i="0">&lt;/c0&gt;</ept> - a route with a pathname that contains two parameters</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135735Z" creationid="shibukawa.yoshiki" creationdate="20150502T135735Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>{'/user/:userId/book/:bookId': userBookComponent}<ept i="0">&lt;/c0&gt;</ept> - 2つのパラメータを含むパス名のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Home<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Login<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Dashboard<ept i="3">&lt;/c3&gt;</ept> are components.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135125Z" creationid="shibukawa.yoshiki" creationdate="20150502T135125Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>home<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>login<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>dashboard<ept i="3">&lt;/c3&gt;</ept>はそれぞれコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>home<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>login<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>dashboard<ept i="3">&lt;/c3&gt;</ept> are modules.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002830Z" creationid="shibukawa.yoshiki" creationdate="20150410T002811Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>home<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>login<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>dashboard<ept i="3">&lt;/c3&gt;</ept>はそれぞれモジュールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="1" x="1">&lt;h1&gt;</bpt>Error: invalid user<ept i="1">&lt;/h1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015426Z" creationid="shibukawa.yoshiki" creationdate="20150416T015426Z">
        <seg><bpt i="1" x="1">&lt;h1&gt;</bpt>エラー: ユーザ名が違います<ept i="1">&lt;/h1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;li&gt;&lt;a href="/item1"&gt;item 1&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121631Z" creationid="shibukawa.yoshiki" creationdate="20150502T121631Z">
        <seg>&lt;li&gt;&lt;a href="/item1"&gt;アイテム 1&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;li&gt;&lt;a href="/item2"&gt;item 2&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121634Z" creationid="shibukawa.yoshiki" creationdate="20150502T121634Z">
        <seg>&lt;li&gt;&lt;a href="/item2"&gt;アイテム 2&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;li&gt;&lt;a href="/item3"&gt;item 3&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121637Z" creationid="shibukawa.yoshiki" creationdate="20150502T121637Z">
        <seg>&lt;li&gt;&lt;a href="/item3"&gt;アイテム 3&lt;/a&gt;&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;li&gt;item 1&lt;/li&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000617Z" creationid="shibukawa.yoshiki" creationdate="20150413T000617Z">
        <seg>&lt;li&gt;アイテム 1&lt;/li&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;li&gt;item 2&lt;/li&gt;
&lt;/ul&gt;
*/</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000620Z" creationid="shibukawa.yoshiki" creationdate="20150413T000620Z">
        <seg>&lt;li&gt;アイテム 2&lt;/li&gt;
&lt;/ul&gt;
*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;script&gt;
//this application only has one component: todo
var todo = {};
&lt;/script&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040351Z" creationid="shibukawa.yoshiki" creationdate="20150502T040351Z">
        <seg>&lt;script&gt;
//このアプリケーションはtodoコンポーネントのみを含む
var todo = {};
&lt;/script&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>&lt;td&gt;task description&lt;/td&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013941Z" creationid="shibukawa.yoshiki" creationdate="20150408T013941Z">
        <seg>&lt;td&gt;タスクの説明&lt;/td&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Todo<ept i="0">&lt;/c0&gt;</ept> can be instantiated, and have its properties changed.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151837Z" creationid="shibukawa.yoshiki" creationdate="20150407T151837Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Todo<ept i="0">&lt;/c0&gt;</ept>は初期化をして、プロパティの変更を行うことができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A DOM element which will contain the template represented by <bpt i="0" x="0">&lt;c0&gt;</bpt>children<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124732Z" creationid="shibukawa.yoshiki" creationdate="20150416T124732Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>children<ept i="0">&lt;/c0&gt;</ept>で表現されるテンプレートの結果が入るDOMエレメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A DOM element which will contain the view's template.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T020744Z" creationid="shibukawa.yoshiki" creationdate="20150414T020744Z">
        <seg>ビューのテンプレートの結果が作成されるDOMエレメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Javascript Framework for Building Brilliant Applications</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T132054Z" creationid="shibukawa.yoshiki" creationdate="20150407T132054Z">
        <seg>輝かしいアプリケーションを構築するためのJavaScriptフレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Knockout view model is an amalgamation of model and controller layers in a single class.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105558Z" creationid="shibukawa.yoshiki" creationdate="20150420T105558Z">
        <seg>Knockoutのビュー・モデルはモデルとコントローラレイヤーを1つに融合させるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Promise aggregator</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153843Z" creationid="shibukawa.yoshiki" creationdate="20150412T153843Z">
        <seg>Promiseを集約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Promise factory</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153806Z" creationid="shibukawa.yoshiki" creationdate="20150412T153800Z">
        <seg>Promiseのファクトリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Simple Application</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142412Z" creationid="shibukawa.yoshiki" creationdate="20150407T142412Z">
        <seg>シンプルなアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A component can be re-initialized from scratch by changing the <bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept> associated with it.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085454Z" creationid="shibukawa.yoshiki" creationdate="20150502T085454Z">
        <seg>コンポーネントを再初期化したい場合は、<bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept>属性を書き換えると行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A component is said to be stateless when it does not store data internally.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080503Z" creationid="shibukawa.yoshiki" creationdate="20150502T080503Z">
        <seg>コンポーネントは、内部にデータを保持しなければステートレスになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A component is supposed to be an Object with two keys: <bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>view<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100430Z" creationid="shibukawa.yoshiki" creationdate="20150502T100430Z">
        <seg>コンポーネントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>view<ept i="1">&lt;/c1&gt;</ept>のキーを持つオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A component with arguments bound</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100704Z" creationid="shibukawa.yoshiki" creationdate="20150502T100704Z">
        <seg>引数が束縛されたコンポーネント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A contact has an id, a name and an email.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T224101Z" creationid="shibukawa.yoshiki" creationdate="20150501T224101Z">
        <seg>この連絡先には、id、名前、eメールが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A contrived example of bi-directional data binding</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140721Z" creationid="shibukawa.yoshiki" creationdate="20150414T140721Z">
        <seg>双方向データバインディングのサンプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A controller can also be used as a class constructor (i.e. it's possible to attach properties to the <bpt i="0" x="0">&lt;c0&gt;</bpt>this<ept i="0">&lt;/c0&gt;</ept> object within the constructor, instead of returning a value).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072300Z" creationid="shibukawa.yoshiki" creationdate="20150502T072300Z">
        <seg>controllerはクラスコンストラクタとしても使用できます。その時は値を返すのではなく、コンストラクタ内で<bpt i="0" x="0">&lt;c0&gt;</bpt>this<ept i="0">&lt;/c0&gt;</ept>オブジェクトに値を追加していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A deferred is an asynchrony monad.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015925Z" creationid="shibukawa.yoshiki" creationdate="20150415T015925Z">
        <seg>deferredは非同時性モナドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A event handler factory utility</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153211Z" creationid="shibukawa.yoshiki" creationdate="20150412T153211Z">
        <seg>イベントハンドラを生成するユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A flag that drives the rendering strategy for the next redraw</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154128Z" creationid="shibukawa.yoshiki" creationdate="20150412T154128Z">
        <seg>次の再描画をどのような戦略で行うかを決定するフラグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A getter-setter method.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135818Z" creationid="shibukawa.yoshiki" creationdate="20150414T135818Z">
        <seg>getter-setterメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A getter-setter utility</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153150Z" creationid="shibukawa.yoshiki" creationdate="20150412T153150Z">
        <seg>getter-setterユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A high-level AJAX utility</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153752Z" creationid="shibukawa.yoshiki" creationdate="20150412T153752Z">
        <seg>高レベルなAJAXユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A high-level explicit rendering method</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153952Z" creationid="shibukawa.yoshiki" creationdate="20150412T153952Z">
        <seg>高レベルな明示的なレンダリングメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A key-value map of possible routes and their respective components.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135659Z" creationid="shibukawa.yoshiki" creationdate="20150502T135659Z">
        <seg>利用可能なラウトと、そのラウトに対応するコンポーネントの対応が格納されたキー・バリュー・マップ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A key/value map of attributes that gets bound as an argument to both the <bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>view<ept i="1">&lt;/c1&gt;</ept> functions of the component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100617Z" creationid="shibukawa.yoshiki" creationdate="20150502T100617Z">
        <seg>コンポーネントの<bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>view<ept i="1">&lt;/c1&gt;</ept>の両方の関数に束縛される属性のキー/バリューマップです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A list of promises to synchronize</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180752Z" creationid="shibukawa.yoshiki" creationdate="20150415T180718Z">
        <seg>同期を取りたいpromiseの配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A map of options for JSONP requests</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014502Z" creationid="shibukawa.yoshiki" creationdate="20150415T014502Z">
        <seg>JSONPリクエストのためのオプションのマップ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A map of options for the XMLHttpRequest</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002049Z" creationid="shibukawa.yoshiki" creationdate="20150415T002036Z">
        <seg>XMLHttpRequestに渡すオプションのマップ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A method to unescape HTML</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153905Z" creationid="shibukawa.yoshiki" creationdate="20150412T153905Z">
        <seg>エスケープしないHTMLのためのメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A more intellectually interesting aspect of the framework is that event handling is encouraged to be done via functional composition (i.e. by using tools like <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.withAttr<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>, <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>m.prop<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept> and the native <bpt i="4" x="4">&lt;c4&gt;</bpt>.bind()<ept i="4">&lt;/c4&gt;</ept> method for partial application).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T022010Z" creationid="shibukawa.yoshiki" creationdate="20150409T015513Z">
        <seg>Mithril実装の中で、これよりも知的で面白い点としては、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.withAttr<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>、<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>m.prop<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>や、ネイティブの<bpt i="4" x="4">&lt;c4&gt;</bpt>.bind()<ept i="4">&lt;/c4&gt;</ept>メソッドを使って部分適用させていくことで、イベントハンドリングが関数合成の文脈で行うことができる点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A noteworthy difference between Angular and Mithril is in framework complexity: Angular implements several subsystems that would seem more logical in programming language implementations (e.g. a parser, a dynamic scoping mechanism, decorators, etc).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095100Z" creationid="shibukawa.yoshiki" creationdate="20150420T095100Z">
        <seg>AngularとMithrilの大きな違いといえば、フレームワークの複雑さです。Angularは数々のサブシステムを持ち、パーサ、動的スコープシステム、デコレータなどより多くのプログラミング言語によるロジックを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A particularly nasty instance of this problem that sometimes occurs in "real-time" applications is when event triggering chains become circular due to a conditional statement bug, causing infinite loops and browser crashes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T021258Z" creationid="shibukawa.yoshiki" creationdate="20150420T021047Z">
        <seg>「リアルタイム」を標榜するアプリケーションでこの問題をこじらせると、条件判断を間違えてイベントのトリガーが循環し、無限ループができてしまってブラウザが応答しなくなることもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A password for HTTP authentication.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002357Z" creationid="shibukawa.yoshiki" creationdate="20150415T002357Z">
        <seg>HTTP認証のパスワード。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A preprocessor function to unwrap the data from a success response in case the response contains metadata wrapping the data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012651Z" creationid="shibukawa.yoshiki" creationdate="20150415T012651Z">
        <seg>レスポンス成功時に、レスポンスに含まれるメタデータなどからデータを取り出す時に使用するプリプロセッサです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A preprocessor function to unwrap the data from an error response in case the response contains metadata wrapping the data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013033Z" creationid="shibukawa.yoshiki" creationdate="20150415T013033Z">
        <seg>レスポンス失敗時に、レスポンスに含まれるメタデータなどからデータを取り出す時に使用するプリプロセッサです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A promise has a method called <bpt i="0" x="0">&lt;c0&gt;</bpt>then<ept i="0">&lt;/c0&gt;</ept> which takes two computation callbacks as parameters.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174919Z" creationid="shibukawa.yoshiki" creationdate="20150415T174919Z">
        <seg>promiseは、2つの計算のコールバックを持つ<bpt i="0" x="0">&lt;c0&gt;</bpt>then<ept i="0">&lt;/c0&gt;</ept>メソッドを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A promise is also a getter-setter (see <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.prop<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175059Z" creationid="shibukawa.yoshiki" creationdate="20150415T175059Z">
        <seg>promiseはgetter-setter (<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.prop<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A route with parameters might look like this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170600Z" creationid="shibukawa.yoshiki" creationdate="20150414T170600Z">
        <seg>パラメータ付きのラウトは次のような文字列です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A route without parameters looks like this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170538Z" creationid="shibukawa.yoshiki" creationdate="20150414T170538Z">
        <seg>パラメータのないラウトは次のようなものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A routing utility</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153221Z" creationid="shibukawa.yoshiki" creationdate="20150412T153221Z">
        <seg>ラウティングユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string containing HTML markup</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015438Z" creationid="shibukawa.yoshiki" creationdate="20150416T015438Z">
        <seg>HTMLマークアップを含む文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A user for HTTP authentication.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002342Z" creationid="shibukawa.yoshiki" creationdate="20150415T002331Z">
        <seg>HTTP認証のユーザ名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A utility to create virtual elements</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153122Z" creationid="shibukawa.yoshiki" creationdate="20150412T153122Z">
        <seg>仮想エレメントを作るためのユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A view-model is a model level entity that stores UI state.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152444Z" creationid="shibukawa.yoshiki" creationdate="20150407T152444Z">
        <seg>ビュー・モデルはモデルレベルのエンティティで、UIの状態を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Aborting a request</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174655Z" creationid="shibukawa.yoshiki" creationdate="20150414T174655Z">
        <seg>リクエストの中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Above, <bpt i="0" x="0">&lt;c0&gt;</bpt>dashboard<ept i="0">&lt;/c0&gt;</ept> is a component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135159Z" creationid="shibukawa.yoshiki" creationdate="20150502T135159Z">
        <seg>上記のサンプルの<bpt i="0" x="0">&lt;c0&gt;</bpt>dashboard<ept i="0">&lt;/c0&gt;</ept>はコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Above, <bpt i="0" x="0">&lt;c0&gt;</bpt>dashboard<ept i="0">&lt;/c0&gt;</ept> is a module.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003508Z" creationid="shibukawa.yoshiki" creationdate="20150410T003508Z">
        <seg>上記のサンプルの<bpt i="0" x="0">&lt;c0&gt;</bpt>dashboard<ept i="0">&lt;/c0&gt;</ept>はモジュールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing the real DOM element</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T234151Z" creationid="shibukawa.yoshiki" creationdate="20150412T234151Z">
        <seg>本物のDOM要素へアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>According to the classic definition of the MVC pattern, the model layer is responsible for data storage, state management and business logic.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151156Z" creationid="shibukawa.yoshiki" creationdate="20150407T151156Z">
        <seg>昔ながらのMVCパターンの定義によると、モデルレイヤはデータの保持、状態の管理、ビジネスロジックについての責務を負っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>According to the specs, the <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;html&gt;<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;head&gt;<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;body&gt;<ept i="2">&lt;/c2&gt;</ept> tags can be omitted, but their respective DOM elements will still be there implicitly when a browser renders that markup.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T144133Z" creationid="shibukawa.yoshiki" creationdate="20150407T144133Z">
        <seg>HTMLの規格によると、<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;html&gt;<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;head&gt;<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;body&gt;<ept i="2">&lt;/c2&gt;</ept>タグは省略できますが、ブラウザがマークアップをレンダリングするときに暗黙的にそれぞれのDOMエレメントを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Additionally, calling <bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw<ept i="0">&lt;/c0&gt;</ept> synchronously after calling <bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw.strategy("none")<ept i="1">&lt;/c1&gt;</ept> resets the strategy to <bpt i="2" x="2">&lt;c2&gt;</bpt>"diff"<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150834Z" creationid="shibukawa.yoshiki" creationdate="20150416T150834Z">
        <seg>また、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw.strategy("none")<ept i="1">&lt;/c1&gt;</ept>を呼んだ後に<bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw<ept i="0">&lt;/c0&gt;</ept>を同期的に呼んだ場合には、戦略は<bpt i="2" x="2">&lt;c2&gt;</bpt>"diff"<ept i="2">&lt;/c2&gt;</ept>にリセットされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Advanced Topics</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140749Z" creationid="shibukawa.yoshiki" creationdate="20150407T140749Z">
        <seg>上級トピック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After a call to either <bpt i="2" x="2">&lt;c2&gt;</bpt>resolve<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>reject<ept i="3">&lt;/c3&gt;</ept>, it holds the result of the parent's computation (or the <bpt i="4" x="4">&lt;c4&gt;</bpt>resolve<ept i="4">&lt;/c4&gt;</ept>/<bpt i="5" x="5">&lt;c5&gt;</bpt>reject<ept i="5">&lt;/c5&gt;</ept> value, if the promise has no parent promises)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175418Z" creationid="shibukawa.yoshiki" creationdate="20150415T175418Z">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>resolve<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>reject<ept i="3">&lt;/c3&gt;</ept>のどちらを呼んでも、promiseは親の計算結果の値 (もしくはpromiseが親を持っていなければ<bpt i="4" x="4">&lt;c4&gt;</bpt>resolve<ept i="4">&lt;/c4&gt;</ept>/<bpt i="5" x="5">&lt;c5&gt;</bpt>reject<ept i="5">&lt;/c5&gt;</ept>)を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After that, Mithril resets the <bpt i="2" x="2">&lt;c2&gt;</bpt>m.redraw.strategy<ept i="2">&lt;/c2&gt;</ept> flag to either "all" or "diff" depending on whether the redraw was due to a route change or whether it was triggered by some other action.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155843Z" creationid="shibukawa.yoshiki" creationdate="20150416T155843Z">
        <seg>再描画が完了すると、Mithrilは再描画がの原因が他のアクションにあるかどうかをを元にして、<bpt i="2" x="2">&lt;c2&gt;</bpt>m.redraw.strategy<ept i="2">&lt;/c2&gt;</ept>の設定を"all"か"diff"に変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the redraw, Mithril resets the value of the flag to either "all" or "diff", depending on whether the redraw was due to a route change or not.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T140302Z" creationid="shibukawa.yoshiki" creationdate="20150416T140302Z">
        <seg>再描画が完了すると、Mithrilは再描画がラウトの変更に起因するものかどうかによって、この設定を"all"か"diff"に変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Aggregating requests in a top-level component makes it easier to replay the request chain (i.e. fetching an updated list of items after you've saved something that changes that list), and it ensures the entire data set is loaded in memory before drilling down into nested components, avoiding redundant AJAX calls for sibling components that need the same data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084936Z" creationid="shibukawa.yoshiki" creationdate="20150502T084822Z">
        <seg>リクエストをトップレベルのコンポーネントに集約することは、リスト内のデータを変更した後などに再度リクエストを行うのが簡単になります。ネストされたコンポーネントをたどっていく前に必要なデータセットが確実に存在することを保証できますし、兄弟コンポーネントで同じデータを何度もリクエストするのを防げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Aggregating responsibility in a top-level component allows the developer to manage multiple model entities easily: any given AJAX request only needs to be performed once regardless of how many components need its data, and refreshing the data set is simple.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T005427Z" creationid="shibukawa.yoshiki" creationdate="20150502T005427Z">
        <seg>責務とトップレベルのコンポーネントで統合するという方法は、複数のモデルエンティティを持つ場合の管理を楽にします。多くのコンポーネントがサーバ側のデータを必要としても、AJAXアクセスをまとめて通信をシンプルにしたり、データのリフレッシュが行い易くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Aggregation of responsibility</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180047Z" creationid="shibukawa.yoshiki" creationdate="20150501T180047Z">
        <seg>責務の集約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All API points are explained in prose, and have code examples.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114416Z" creationid="shibukawa.yoshiki" creationdate="20150417T114416Z">
        <seg>すべてのAPIは人間に読みやすいように書かれており、サンプルコードもたくさん書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Also note that concatenating or splitting a trusted string removes the trust flag.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015655Z" creationid="shibukawa.yoshiki" creationdate="20150416T015655Z">
        <seg>また、文字列を結合したり、分割すると、信頼フラグは削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Also note that the <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> callback only runs after a rendering lifecycle is done.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124801Z" creationid="shibukawa.yoshiki" creationdate="20150413T124801Z">
        <seg>また、<bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>コールバックはレンダリングのライフサイクルが終わった時にしか呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Also note that, unlike observable-based frameworks like Knockout.js, setting a value in a <bpt i="4" x="4">&lt;c4&gt;</bpt>m.prop<ept i="4">&lt;/c4&gt;</ept> getter-setter does NOT trigger redrawing side-effects in Mithril.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014658Z" creationid="shibukawa.yoshiki" creationdate="20150408T014658Z">
        <seg>MithrilはKnockout.jsのようなObservableベースのフレームワークとは異なり、<bpt i="4" x="4">&lt;c4&gt;</bpt>m.prop<ept i="4">&lt;/c4&gt;</ept>のgetter-setterに値を設定しても、再描画が起動されるような副作用は発生しないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Also, keys must be either strings or numbers.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142219Z" creationid="shibukawa.yoshiki" creationdate="20150413T142219Z">
        <seg>キーは文字列でも数値でも大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Also, notice that since these components are designed to encapsulate their behavior, they cannot easily affect other components.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015346Z" creationid="shibukawa.yoshiki" creationdate="20150502T015346Z">
        <seg>また、それぞれのコンポーネントの動作はカプセル化されているため、他のモジュールを外部から操作することは簡単にはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, you can also explore other techniques in order to achieve better <bpt i="0" x="0">&lt;a0&gt;</bpt>performance<ept i="0">&lt;/a0&gt;</ept> and <bpt i="1" x="1">&lt;a1&gt;</bpt>expressiveness<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015842Z" creationid="shibukawa.yoshiki" creationdate="20150413T015842Z">
        <seg>バインディングに関して<bpt i="0" x="0">&lt;a0&gt;</bpt>パフォーマンス<ept i="0">&lt;/a0&gt;</ept>と<bpt i="1" x="1">&lt;a1&gt;</bpt>表現<ept i="1">&lt;/a1&gt;</ept>を改善する他の方法についてはブログの記事で学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An URI encoded querystring to be deserialized</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135935Z" creationid="shibukawa.yoshiki" creationdate="20150502T135935Z">
        <seg>デシリアライズするURIエンコーディングされたクエリー文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An alert box will appear when the upload finishes"),</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034917Z" creationid="shibukawa.yoshiki" creationdate="20150502T034917Z">
        <seg>アップロードが完了するとアラートボックスが表示されます。"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An element is considered "different enough" if:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135347Z" creationid="shibukawa.yoshiki" creationdate="20150413T135347Z">
        <seg>「大きく異る」の判定基準は:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An execution thread is basically any amount of code that runs before other asynchronous threads start to run.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155935Z" creationid="shibukawa.yoshiki" creationdate="20150412T004720Z">
        <seg>実行スレッドは基本的に、他の非同期スレッドが実行する前に、ある程度の量のコードを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An initialization function that runs after <bpt i="0" x="0">&lt;c0&gt;</bpt>open<ept i="0">&lt;/c0&gt;</ept> and before <bpt i="1" x="1">&lt;c1&gt;</bpt>send<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013955Z" creationid="shibukawa.yoshiki" creationdate="20150415T013943Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>open<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>send<ept i="1">&lt;/c1&gt;</ept>の間に呼ばれる初期化関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An initialization value.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135822Z" creationid="shibukawa.yoshiki" creationdate="20150414T135712Z">
        <seg>初期値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance of the controller constructor</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T024717Z" creationid="shibukawa.yoshiki" creationdate="20150414T024717Z">
        <seg>コントローラコンストラクタのインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An object that retains its state across redraws.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155255Z" creationid="shibukawa.yoshiki" creationdate="20150413T155255Z">
        <seg>再描画間で状態を保持するオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An object to be serialized</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170954Z" creationid="shibukawa.yoshiki" creationdate="20150414T170954Z">
        <seg>シリアライズしたいオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And because Mithril views are Javascript, the developer has full freedom to abstract common patterns - from bidirectional binding helpers to full blown components - using standard Javascript refactoring techniques.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021942Z" creationid="shibukawa.yoshiki" creationdate="20150409T015129Z">
        <seg>MithrilのビューがJavaScriptであることから、破壊的なコンポーネントに対する双方向バインディングヘルパーといった、抽象的な一般化のパターンから開発者が開放されます。一般的なJavaScriptのリファクタリングテクニックが利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And if you really do want to use HTML syntax after all, <bpt i="0" x="0">&lt;a0&gt;</bpt>you can use a package called MSX<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T014543Z" creationid="shibukawa.yoshiki" creationdate="20150409T014543Z">
        <seg>それでもHTMLの文法を使いたいということであれば、<bpt i="0" x="0">&lt;a0&gt;</bpt>MSXと呼ばれるパッケージが使えます<ept i="0">&lt;/a0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And moving the responsibility of saving to the <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactForm<ept i="0">&lt;/c0&gt;</ept> component alleviates the need to send data back up the component tree, making the handling of non-idempotent operations less prone to pass-through argument noise.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031049Z" creationid="shibukawa.yoshiki" creationdate="20150502T031049Z">
        <seg>また、保存の責務を<bpt i="0" x="0">&lt;c0&gt;</bpt>ContactForm<ept i="0">&lt;/c0&gt;</ept>コンポーネントに移動したことで、コンポーネントツリーをさかのぼってデータを渡す必要は軽減されています。 引数を使ってパススルーするノイズも減らしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And so on.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152205Z" creationid="shibukawa.yoshiki" creationdate="20150407T152205Z">
        <seg>他にもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And the data is <bpt i="0" x="0">&lt;c0&gt;</bpt>[{name: "John"}, {name: "Mary"}]<ept i="0">&lt;/c0&gt;</ept>, then the response will contain an array of two User instances.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013928Z" creationid="shibukawa.yoshiki" creationdate="20150415T013928Z">
        <seg>そして、サーバから<bpt i="0" x="0">&lt;c0&gt;</bpt>[{name: "John"}, {name: "Mary"}]<ept i="0">&lt;/c0&gt;</ept>というデータが帰ってくると、レスポンスはUserクラスのインスタンスを2つ含む配列になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And this is for every list that needs to be displayed in some way.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014441Z" creationid="shibukawa.yoshiki" creationdate="20150420T014441Z">
        <seg>リストを表示するコードを実装するときは、毎回この作業が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And you can download Mithril by typing this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235523Z" creationid="shibukawa.yoshiki" creationdate="20150407T235523Z">
        <seg>このあと、次のようにタイプするとMithrilをダウンロードすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Angular is an MVC framework maintained by Google, and it provides a declarative view layer and an emphasis on testability.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025013Z" creationid="shibukawa.yoshiki" creationdate="20150420T025013Z">
        <seg>AngularはGoogleにより開発が行われているMVCフレームワークで、宣言的なビューとテストしやすさに重点が置かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another difference is that Mithril, being an MVC framework, rather than a templating engine, provides an auto-redrawing system that is aware of network asynchrony and that can render views efficiently without cluttering application code with redraw calls, and without letting the developer unintentionally bleed out of the MVC pattern.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105303Z" creationid="shibukawa.yoshiki" creationdate="20150420T105303Z">
        <seg>他に違う点といえば、Mithrilは単なるテンプレートエンジンではなく、MVCフレームワークとして統一的に動作するように作られているため、アプリケーションコードに再描画命令を挟み込んでMVCフレームワークのパターンを逸脱することなく、非同期通信のネットワークアクセスなどを探知して適切に再描画行う再描画エンジンを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another feature - the optional <bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept> utility - allows writing terse templates in a declarative style using CSS shorthands, similar to popular HTML preprocessors from server-side MVC frameworks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021918Z" creationid="shibukawa.yoshiki" creationdate="20150409T014927Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept>ユーティリティが持つ他の機能としては、CSS的な記述方法で完結にテンプレートが記述できます。これは一般的なサーバサイドMVCフレームワークのHTML処理と似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another marking difference is that Backbone is workflow agnostic, providing no idiomatic way to organize applications.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020252Z" creationid="shibukawa.yoshiki" creationdate="20150420T020252Z">
        <seg>他に異なる点としては、Backboneはワークフローに関しては関与しません。アプリケーションを組み立てていくための手順に関しては特に定めていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another point of comparison is documentation.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113935Z" creationid="shibukawa.yoshiki" creationdate="20150417T113935Z">
        <seg>もう１つの比較ポイントはドキュメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another side-effect is that UI state like input focus is not tracked correctly if the focused element moves around, and likewise, state for 3rd party plugins that are added via <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> can also end up in the wrong element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141431Z" creationid="shibukawa.yoshiki" creationdate="20150413T141431Z">
        <seg>他の副作用としては、フォーカスを持ったエレメントが移動してしまったり、<bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>を通じて追加されたサードパーティのプラグインが違うエレメントの内側に移動してしまう可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another significant difference between Backbone and Mithril is in their approach to familiarity: Backbone appeals to people familiar w/ jQuery; Mithril is designed to be familiar to people with server-side MVC framework experience.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T024834Z" creationid="shibukawa.yoshiki" creationdate="20150420T024834Z">
        <seg>それ以外の違いとしては、フレームワークがターゲットとしている層です。BackboneはjQueryに慣れている人にアプローチしています。MithrilはサーバサイドMVCフレームワークの経験を持っている人が親しみやすいように設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another way of organizing code is to distribute concrete responsibilities across multiple modules.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013600Z" creationid="shibukawa.yoshiki" creationdate="20150502T013600Z">
        <seg>他のコードの構築方法としては、具体的な責務をモジュール間に分配する方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any code that is between a <bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept> and its respective <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept> call is said to live in the <bpt i="4" x="4">&lt;e4&gt;</bpt>context<ept i="4">&lt;/e4&gt;</ept> of its respective pair of function calls.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T185444Z" creationid="shibukawa.yoshiki" creationdate="20150411T185444Z">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept>呼び出しと、対応する<bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept>呼び出しにあるコードは、Mithrilの文脈では、「同じペアの関数呼び出しの<bpt i="4" x="4">&lt;e4&gt;</bpt>コンテキスト<ept i="4">&lt;/e4&gt;</ept>内に存在する」と表現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any time an exception is thrown inside a promise callback, Mithril calls <bpt i="0" x="0">&lt;c0&gt;</bpt>m.deferred.onerror(e)<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174241Z" creationid="shibukawa.yoshiki" creationdate="20150415T174241Z">
        <seg>promiseコールバックの中で例外が発生すると、Mithrilは<bpt i="0" x="0">&lt;c0&gt;</bpt>m.deferred.onerror(e)<ept i="0">&lt;/c0&gt;</ept>を呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Application architecture with components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180000Z" creationid="shibukawa.yoshiki" creationdate="20150501T180000Z">
        <seg>アプリケーションアーキテクチャとコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Architecture</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114907Z" creationid="shibukawa.yoshiki" creationdate="20150417T114907Z">
        <seg>アーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, the controller runs again, the DOM is re-generated, and any applicable 3rd party plugins in configs are re-initialized.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090552Z" creationid="shibukawa.yoshiki" creationdate="20150502T090552Z">
        <seg>これにより、コントローラが再実行され、DOMが再生成されます。また、サードパーティのプラグインがconfigで設定されていた場合には、これも最初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a rule of thumb, controllers should not change model entity properties on an individual basis.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T031859Z" creationid="shibukawa.yoshiki" creationdate="20150421T014126Z">
        <seg>経験則として、コントローラがモデルのプロパティを直接変更すべきではない、というものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a rule of thumb, you should <bpt i="0" x="0">&lt;e0&gt;</bpt>never<ept i="0">&lt;/e0&gt;</ept> implement performance optimizations if another solution is available.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142929Z" creationid="shibukawa.yoshiki" creationdate="20150412T142929Z">
        <seg>一般的な方針として、他のソリューションがある場合には、<bpt i="0" x="0">&lt;e0&gt;</bpt>絶対に<ept i="0">&lt;/e0&gt;</ept>パフォーマンスの最適化を行わないほうが良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As it turns out, this design decision is actually a compromise: it offers the benefit of decreased application code complexity at the cost of some performance loss.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014911Z" creationid="shibukawa.yoshiki" creationdate="20150420T014911Z">
        <seg>通常、このような設計の決定は折衷案になりがちです。アプリケーションコードの複雑さを減らそうとすると、パフォーマンスのコストが必要になったりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As soon as the event handler returns, the strategy is set back to "diff".</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150525Z" creationid="shibukawa.yoshiki" creationdate="20150416T150525Z">
        <seg>イベントハンドラが完了すると、再び"diff"に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As summarized above, Mithril differs from jQuery by allowing DOM-related code to be written largely in a declarative style (thereby decreasing code complexity), in addition to providing an idiomatic way to structure applications.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015629Z" creationid="shibukawa.yoshiki" creationdate="20150420T015629Z">
        <seg>言い換えると、MithrilとjQueryの書き方は大きく異なっています。Mithrilは宣言的なスタイルでDOM関連のコードを書くことが可能で、コードの複雑さは低減されています。それに加えて、共通のアプリケーションの構造を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with Angular, Knockout templates are written in HTML, and therefore have the same pros and cons as Angular templates.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105833Z" creationid="shibukawa.yoshiki" creationdate="20150420T105833Z">
        <seg>また、Angularと同様にテンプレートがHTMLに書かれるため、Angularのテンプレートと同じ利点・欠点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with input focus, we can maintain referential integrity between data in a list and the respective DOM representation by using keys.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150247Z" creationid="shibukawa.yoshiki" creationdate="20150413T150247Z">
        <seg>入力のフォーカスと同様に、キーを使うとリスト内のデータとそのDOM表現間の参照の整合性を維持できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with jQuery, Mithril differs from Backbone by enforcing view code to be written in a declarative style.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020128Z" creationid="shibukawa.yoshiki" creationdate="20150420T020128Z">
        <seg>BackboneとjQueryとの組み合わせたスタイルを使う場合、Mithrilではビューコードの記述に宣言的なスタイルが強要されるため、大きくことなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you can see, flow control is done with vanilla Javascript.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002654Z" creationid="shibukawa.yoshiki" creationdate="20150413T002559Z">
        <seg>このように、普通のJavaScriptの文法を利用してフロー制御を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you can see, it paints a much less flattering picture for some frameworks than when we look at gzipped size alone.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113909Z" creationid="shibukawa.yoshiki" creationdate="20150417T113909Z">
        <seg>すでにご覧になられたとおり、大げさではなくて、gzipされたサイズ以上のパフォーマンスが出ている事がわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you can see, we return a partial template with two <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;td&gt;<ept i="0">&lt;/c0&gt;</ept>'s.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153237Z" creationid="shibukawa.yoshiki" creationdate="20150408T153237Z">
        <seg>このメソッドは、ご覧のとおりに、2つの<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;td&gt;<ept i="0">&lt;/c0&gt;</ept>タグを持つ、部分テンプレートを返しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you can see, you can use CSS selectors to specify attributes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004324Z" creationid="shibukawa.yoshiki" creationdate="20150408T004324Z">
        <seg>CSSセレクタを使って要素を選択することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you may recall, models are responsible for encapsulating business logic, and view-models encapsulate logic that pertains specifically to UI state, so there's really nothing else for a controller to abstract away, and all it needs to do is expose a slice of the model layer that pertains to the UI that is currently in view.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004036Z" creationid="shibukawa.yoshiki" creationdate="20150408T004036Z">
        <seg>ここで今まで出てきたロールを思い出してみてください。モデルはビジネスロジックのカプセル化、ビュー・モデルは特定のUI状態に関するロジックのカプセル化を行います。抽象化された役割の中でコントローラが行うべきものは、モデルの中から、現在の表示されているものを切り出して表示するという役割以外は残っていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you saw, you can chain operations that act on the response data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125423Z" creationid="shibukawa.yoshiki" creationdate="20150410T125423Z">
        <seg>これまで見てきたとおり、レスポンスで返されたデータに対して処理のオペレーションをいくつもチェーンさせて追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assuming NodeJS is already installed, run the following command to install GruntJS:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150453Z" creationid="shibukawa.yoshiki" creationdate="20150412T150453Z">
        <seg>NodeJSがすでにインストールされているとすると、次のコマンドをタイプするとGruntJSがインストールされます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assuming a document has an empty <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;body&gt;<ept i="0">&lt;/c0&gt;</ept> element, the code below:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123317Z" creationid="shibukawa.yoshiki" creationdate="20150416T081357Z">
        <seg>ドキュメントは空の<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;body&gt;<ept i="0">&lt;/c0&gt;</ept>エレメントを持っているとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assuming you have NodeJS installed, you can download Mithril by typing this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235211Z" creationid="shibukawa.yoshiki" creationdate="20150407T170054Z">
        <seg>NodeJSがインストールされているものとすると，次のようにタイプすることでMithrilをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assuming you have NodeJS installed, you can install Bower by typing this in the command line:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235149Z" creationid="shibukawa.yoshiki" creationdate="20150407T235149Z">
        <seg>NodeJSがインストールされているものとすると，次のようにタイプすることでBowerをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assuming you have NodeJS installed, you can install Component by typing this in the command line:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000021Z" creationid="shibukawa.yoshiki" creationdate="20150408T000021Z">
        <seg>NodeJSがインストールされているものとすると，次のようにタイプすることでComponentをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assuming your templates have appropriate null checks in place, <bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw<ept i="0">&lt;/c0&gt;</ept> is useful for transient DOM state such as loading indicators and to commit state to the DOM for the purposes of reading back computed values (for example, <bpt i="1" x="1">&lt;c1&gt;</bpt>offsetWidth<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>scrollHeight<ept i="2">&lt;/c2&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130458Z" creationid="shibukawa.yoshiki" creationdate="20150502T130458Z">
        <seg>テンプレートでは適切にnullチェックが行われていると仮定すると、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw<ept i="0">&lt;/c0&gt;</ept>はローディングのインジケータ表示したり、 <bpt i="1" x="1">&lt;c1&gt;</bpt>offsetWidth<ept i="1">&lt;/c1&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>scrollHeight<ept i="2">&lt;/c2&gt;</ept>の値を元にDOMの状態を変更しにいく時には便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At a glance it may seem like we're doing something very expensive by redrawing, but as it turns out, calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>todo.view<ept i="0">&lt;/c0&gt;</ept> method multiple times does not actually re-render the entire template.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015426Z" creationid="shibukawa.yoshiki" creationdate="20150408T015426Z">
        <seg>一見すると、このコードは再描画を何度も行っていて、とても実行コストが高そうに見えますが、<bpt i="0" x="0">&lt;c0&gt;</bpt>todo.view<ept i="0">&lt;/c0&gt;</ept>メソッドを何度呼び出しても、実際にはテンプレート全体が再描画されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attempting to unwrap its value early will likely result in errors.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015311Z" creationid="shibukawa.yoshiki" creationdate="20150410T015311Z">
        <seg>そのため、データを早期にアンラップしようとするとおそらくエラーになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Automatic HTML-to-Mithril Template Converter</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013614Z" creationid="shibukawa.yoshiki" creationdate="20150417T013614Z">
        <seg>自動HTML→Mithirilテンプレートコンバータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Automating Compilation</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150242Z" creationid="shibukawa.yoshiki" creationdate="20150412T150242Z">
        <seg>自動コンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Backbone was originally designed as a way to structure jQuery-based applications.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015758Z" creationid="shibukawa.yoshiki" creationdate="20150420T015758Z">
        <seg>Backboneは当初、jQueryベースのアプリケーションの構造化をする目的で設計されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Basic usage</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014521Z" creationid="shibukawa.yoshiki" creationdate="20150410T014521Z">
        <seg>基本的な使い方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be aware that by using the native Array class, we're making an implicit statement that we are going to support all of the standard Array methods as part of our API.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002837Z" creationid="shibukawa.yoshiki" creationdate="20150409T002837Z">
        <seg>ネイティブのArrayクラスを使ったお陰で、標準のArrayクラスのメソッドを自分自身のAPIとして暗黙的に使えるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be aware that even though Mithril has tests running in a continuous integration environment, the bleeding edge version might occasionally break.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000533Z" creationid="shibukawa.yoshiki" creationdate="20150408T000533Z">
        <seg>Mithrilは継続的インテグレーション環境を使ってテストされていますが、最先端のバージョンは頻繁に機能しなくなる可能性がありますので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be sure to read the <bpt i="0" x="0">&lt;a0&gt;</bpt>Application Architecture section<ept i="0">&lt;/a0&gt;</ept> to learn more about organizing componentized code.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085142Z" creationid="shibukawa.yoshiki" creationdate="20150502T085142Z">
        <seg>コンポーネント化されたコードの構成については、<bpt i="0" x="0">&lt;a0&gt;</bpt>アプリケーションアーキテクチャのセクション<ept i="0">&lt;/a0&gt;</ept>をお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because Mithril encourages all entity logic to be done in the model layer, it's idiomatic to create modules with model-level classes that deal specifically with relationships between entities, when there isn't already a model entity that can logically hold the relational business logic.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033306Z" creationid="shibukawa.yoshiki" creationdate="20150421T033306Z">
        <seg>Mithrilでは、エンティティのロジックはすべてモデルレイヤ内に置かれるのが推奨されます。エンティティ間の関係を取り扱う必要が出てきたら、コントローラのレイヤーにコードを足すのではなく、新たに専門のモデルレベルのクラスを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the DOM is by far the largest bottleneck in rendering engines, Mithril's approach of running a diff against a virtual representation of the DOM and only batching changes to the real DOM as needed is surprisingly performant.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184338Z" creationid="shibukawa.yoshiki" creationdate="20150411T184338Z">
        <seg>DOMはレンダリングエンジンにとって最大のボトルネックであるため、MithrilのDOMの仮想表現に対して差分をとり、必要に応じてバッチで実際のDOMを変更するアプローチは、驚くべきパフォーマンスを達成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the entire documentation is hand-crafted, you get the benefit of actually having explanations for things that documentation-generator tools don't support well (for example, interfaces and callback parameter documentation).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114600Z" creationid="shibukawa.yoshiki" creationdate="20150417T114600Z">
        <seg>すべてのドキュメントが人の手で書かれているため、ドキュメントに知りたい情報がきちんとかかれているというメリットがあります。ドキュメント生成ツールではインタフェースやコールバックのパラメータなどが抜けがちです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because this handler is not created using Mithril's templating engine (i.e. we're not defining an attribute in a virtual element), we must manually integrate it to the auto-redrawing system.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134225Z" creationid="shibukawa.yoshiki" creationdate="20150412T134225Z">
        <seg>仮想エレメントの中でこの属性を使用しなかった場合など、もしこのハンドラがMithrilのテンプレートで作成されていない場合は、手動で自動再描画システムに統合する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Below are some examples of consuming the <bpt i="0" x="0">&lt;c0&gt;</bpt>Uploader<ept i="0">&lt;/c0&gt;</ept> component:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034534Z" creationid="shibukawa.yoshiki" creationdate="20150502T034534Z">
        <seg>次のコードは<bpt i="0" x="0">&lt;c0&gt;</bpt>Uploader<ept i="0">&lt;/c0&gt;</ept>コンポーネントの使用例です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Below is an example where various methods implemented with a third party library can be integrated in layered fashion: any of the methods can be used in isolation or in combination.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T005157Z" creationid="shibukawa.yoshiki" creationdate="20150412T005157Z">
        <seg>次のサンプルは、多くのメソッドがサードパーティ製ライブラリを使っているコードを、階層に分けて統合したコードになります。メソッドの中には個別に使われるものもあれば、組み合わせて使われるものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Benchmarks</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141004Z" creationid="shibukawa.yoshiki" creationdate="20150407T141004Z">
        <seg>ベンチマーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bind redirection code</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124256Z" creationid="shibukawa.yoshiki" creationdate="20150410T124256Z">
        <seg>リダイレクトするコードのバインド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Binding errors</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124707Z" creationid="shibukawa.yoshiki" creationdate="20150410T124707Z">
        <seg>エラーのバインド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Binding to data</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T160146Z" creationid="shibukawa.yoshiki" creationdate="20150412T160146Z">
        <seg>データへバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both can be compiled, but React's compiled code still has function calls for each virtual DOM element; Mithril templates compile into static Javascript data structures.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T100330Z" creationid="shibukawa.yoshiki" creationdate="20150420T100330Z">
        <seg>どちらもコンパイルは可能ですが、Reactのコンパイル済みのコードには仮想DOMエレメントごとの関数呼び出しが残っています。Mithrilのテンプレートは静的なJavaScriptのデータ構造になるため、関数呼び出しはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both components use a <bpt i="0" x="0">&lt;c0&gt;</bpt>menu<ept i="0">&lt;/c0&gt;</ept> template, which contains links for navigation between the two components, and an expensive-to-reinitialize element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124841Z" creationid="shibukawa.yoshiki" creationdate="20150502T124841Z">
        <seg>どちらのコンポーネントも<bpt i="0" x="0">&lt;c0&gt;</bpt>menu<ept i="0">&lt;/c0&gt;</ept>テンプレートを使用しています。このテンプレーには2つのコンポーネント間をナビゲートするリンクがあります。そして、最初期化のコストが非常に高いエレメントだとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Browsers do, however, allow scripts to be run asynchronously via a number of execution points, such as the <bpt i="0" x="0">&lt;c0&gt;</bpt>onload<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>onerror<ept i="1">&lt;/c1&gt;</ept> attributes in <bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;img&gt;<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;iframe&gt;<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014634Z" creationid="shibukawa.yoshiki" creationdate="20150416T014634Z">
        <seg>しかし、ブラウザが非同期でスクリプトの実行を行うポイントがいくつかあります。<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;img&gt;<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;iframe&gt;<ept i="3">&lt;/c3&gt;</ept>に含まれる<bpt i="0" x="0">&lt;c0&gt;</bpt>onload<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>onerror<ept i="1">&lt;/c1&gt;</ept>属性などです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Build a simple application.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135538Z" creationid="shibukawa.yoshiki" creationdate="20150407T135538Z">
        <seg>小さなアプリケーションを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By bundling model methods in the component, we avoid hard-coding how files are handled once they're dropped in, and instead, we provide a useful library of functions that can be consumed flexibly to meet the demands on an application.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034046Z" creationid="shibukawa.yoshiki" creationdate="20150502T034046Z">
        <seg>コンポーネントにモデルメソッドをバンドルするときは、どのようにファイルを取り扱うかをハードコーディングするのを避けます。アプリケーションの需要に応じて柔軟に使用できる関数ライブラリを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, <bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept> uses JSON to send and receive data to web services.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174901Z" creationid="shibukawa.yoshiki" creationdate="20150410T174901Z">
        <seg>デフォルトでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept>はウェブサービスとのデータの送受信にJSONを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, <bpt i="1" x="1">&lt;c1&gt;</bpt>serialize<ept i="1">&lt;/c1&gt;</ept> converts an object to JSON, but in the case of a FormData payload, you want to pass the object intact.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175449Z" creationid="shibukawa.yoshiki" creationdate="20150414T175449Z">
        <seg>デフォルトでは<bpt i="1" x="1">&lt;c1&gt;</bpt>serialize<ept i="1">&lt;/c1&gt;</ept>はオブジェクトをJSONに変換しますが、FormDataをペイロードとして使う場合には、オブジェクトをそのまま流します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, Mithril assumes both success and error responses are in JSON format, but some servers may not return JSON responses when returning HTTP error codes (e.g. 404)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175634Z" creationid="shibukawa.yoshiki" creationdate="20150414T175634Z">
        <seg>デフォルトでは、Mithrilは成功時も失敗時もレスポンスはJSONフォーマットで帰ってくるものとみなしてパースしようとしますが、サーバの中には404のようなエラーコードを返す時にJSONを返さないものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, Mithril does not swallow errors if these errors are subclasses of the Error class.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T141042Z" creationid="shibukawa.yoshiki" creationdate="20150415T141042Z">
        <seg>デフォルトでは、MithrilはエラーがErrorクラスのサブクラスであれば、必ずフレームワーク外までそれを届けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, Mithril escapes HTML strings in order to help prevent XSS attacks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020908Z" creationid="shibukawa.yoshiki" creationdate="20150413T020908Z">
        <seg>デフォルトでは、MithrilはXSS攻撃を防ぐためにHTMLの文字列をエスケープします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, Mithril is configured to auto-redraw from scratch after component controllers are initialized, and it is configured to diff after event handlers are triggered.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150505T234934Z" creationid="shibukawa.yoshiki" creationdate="20150505T234934Z">
        <seg>デフォルトでは、コンポーネントのコントローラが初期化されるとゼロから再描画を行う設定になっていて、イベントハンドラが起動されると差分描画が行われるように設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, Mithril sets this value to <bpt i="4" x="4">&lt;c4&gt;</bpt>"all"<ept i="4">&lt;/c4&gt;</ept> before running controller constructors, and it sets it to <bpt i="5" x="5">&lt;c5&gt;</bpt>"diff"<ept i="5">&lt;/c5&gt;</ept> before event handlers are triggered.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T131100Z" creationid="shibukawa.yoshiki" creationdate="20150416T131055Z">
        <seg>Mithirlのデフォルト<bpt i="4" x="4">&lt;c4&gt;</bpt>"all"<ept i="4">&lt;/c4&gt;</ept>で、コントローラのコンストラクタが実行される・イベントハンドラが起動される前に、差分を取得します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, Mithril uses <bpt i="0" x="0">&lt;c0&gt;</bpt>window<ept i="0">&lt;/c0&gt;</ept> itself as the dependency.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161043Z" creationid="shibukawa.yoshiki" creationdate="20150416T161043Z">
        <seg>デフォルトではMithrilは依存先として<bpt i="0" x="0">&lt;c0&gt;</bpt>window<ept i="0">&lt;/c0&gt;</ept>自身を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, Mithril waits for web service requests to complete before attempting a redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235712Z" creationid="shibukawa.yoshiki" creationdate="20150414T235712Z">
        <seg>デフォルトでは、Mithrilはウェブサービスへのリクエストが完了するまでは再描画を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, event handlers schedule redraws to be done asynchronously in order to allow simultaneous events to run before redrawing (for example, the keypress and input are often used together for inputs).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152141Z" creationid="shibukawa.yoshiki" creationdate="20150416T152141Z">
        <seg>デフォルトでは、イベントハンドラは非同期で再描画を行うようにスケジュールします。これにより、同じ入力フォームに対して同時に使われるkeypressとinputなどの複数のイベントを再描画前にまとめて実行し、再描画の回数を減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, it assumes server responses are in JSON format and optionally instantiates a class with the response data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174821Z" creationid="shibukawa.yoshiki" creationdate="20150414T174821Z">
        <seg>デフォルトではサーバのレスポンスはJSONとみなして解釈します。また、オプションでレスポンスデータを元にクラスのインスタンスを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, it rethrows to the console if an error is a subclass of Error (but not an instance of Error itself).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180334Z" creationid="shibukawa.yoshiki" creationdate="20150415T180334Z">
        <seg>デフォルトでは、このイベントハンドラはこのエラーがErrorのサブクラスの例外で、Errorそのもののインスタンスでなければコンソールにその例外を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, promises are not integrated to the Mithril auto-redrawing system.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135332Z" creationid="shibukawa.yoshiki" creationdate="20150415T135332Z">
        <seg>デフォルトでは、promiseはMithrilの自動再描画システムとは統合しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, the querystring is considered the URL component to test against the routes collection</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165457Z" creationid="shibukawa.yoshiki" creationdate="20150414T165457Z">
        <seg>デフォルトではラウト集に対してクエリー文字列がURLの構成要素として解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, the spec requires that all thrown errors trigger rejection, which result in silent failures if the developer forgets to explicitly handle the failure case.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172608Z" creationid="shibukawa.yoshiki" creationdate="20150415T172355Z">
        <seg>デフォルトでは、Promise/A+の仕様ではすべての例外はrejectionを起動しますが、開発者がこの失敗時のコールバックを設定し忘れると、誰もエラーを受け取らずに例外は握りつぶされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, this event handler rethrows the exception to the console if an error is a subclass of Error (but not an instance of Error itself).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174340Z" creationid="shibukawa.yoshiki" creationdate="20150415T174340Z">
        <seg>デフォルトでは、このイベントハンドラはこのエラーがErrorのサブクラスの例外で、Errorそのもののインスタンスでなければコンソールにその例外を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By freezing APIs and swapping implementations, the developer can completely avoid touching other layers in the application while refactoring.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003758Z" creationid="shibukawa.yoshiki" creationdate="20150409T003758Z">
        <seg>APIをフリーズしたり実装を交換したりするだけであれば、リファクタリングを行う際に他のレイヤをまったく触る必要はなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By nature, optimizing performance make aggressive assumptions that can break in edge cases and it yields difficult to understand code.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142625Z" creationid="shibukawa.yoshiki" creationdate="20150412T142625Z">
        <seg>パフォーマンスの最適化でやりがちなこととしては、特殊なケースですぐに成り立たなくなるような思い込みを行い、コードの理解が極めて難しいコードを書いてしまうということがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By strategically placing calls to this pair of functions, it is possible to stack asynchronous data services in any number of ways within a context without the need to pass state variables around the entire application.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190231Z" creationid="shibukawa.yoshiki" creationdate="20150411T190231Z">
        <seg>この関数呼び出しのペアを戦略的に配置することで、アプリケーションコード全体で状態変数を管理する必要性をなくし、データを取得する非同期のサービスをいくつもスタックさせることが可能になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>CDNs (Content Delivery Networks)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165147Z" creationid="shibukawa.yoshiki" creationdate="20150407T165147Z">
        <seg>CDN (コンテンツデリバリネットワーク)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Call it at the beginning of your test file to supply a mock <bpt i="0" x="0">&lt;c0&gt;</bpt>window<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161336Z" creationid="shibukawa.yoshiki" creationdate="20150416T161336Z">
        <seg>テストファイルの最初でこの関数を呼んで、モックの<bpt i="0" x="0">&lt;c0&gt;</bpt>window<ept i="0">&lt;/c0&gt;</ept>を設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling <bpt i="0" x="0">&lt;c0&gt;</bpt>e.preventDefault()<ept i="0">&lt;/c0&gt;</ept> from a component's <bpt i="1" x="1">&lt;c1&gt;</bpt>onunload<ept i="1">&lt;/c1&gt;</ept> function aborts route changes, but it does not abort rollback or affect the current redraw in any way.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092934Z" creationid="shibukawa.yoshiki" creationdate="20150502T092934Z">
        <seg>コンポーネントの<bpt i="1" x="1">&lt;c1&gt;</bpt>onunload<ept i="1">&lt;/c1&gt;</ept>関数から<bpt i="0" x="0">&lt;c0&gt;</bpt>e.preventDefault()<ept i="0">&lt;/c0&gt;</ept>を呼ぶと、ラウターの変更を中断しますが、ロールバックしたり、現在の再描画への変更を辞めることはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling <bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept> with a DOM element as the first argument and a component as the second argument will call the component's controller function, and then call the component's view function.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125441Z" creationid="shibukawa.yoshiki" creationdate="20150502T125441Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept>を呼ぶ時は、DOMエレメントを最初の引数に設定し、2つ目の引数にコンポーネントを設定します。まずコンポーネントのcontroller関数が呼ばれ、次にview関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling <bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw<ept i="0">&lt;/c0&gt;</ept> triggers a redraw regardless of whether AJAX requests (and other asynchronous services) are completed.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130115Z" creationid="shibukawa.yoshiki" creationdate="20150502T130115Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw<ept i="0">&lt;/c0&gt;</ept>を呼ぶと、AJAXリクエストや他の非同期サービスが完了しているかどうかに関わらず、再描画処理を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the <bpt i="8" x="8">&lt;c8&gt;</bpt>then<ept i="8">&lt;/c8&gt;</ept> method attaches the computations represented by <bpt i="9" x="9">&lt;c9&gt;</bpt>successCallback<ept i="9">&lt;/c9&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt>errorCallback<ept i="10">&lt;/c10&gt;</ept> to the promise, which will be called when either <bpt i="11" x="11">&lt;c11&gt;</bpt>resolve<ept i="11">&lt;/c11&gt;</ept> or <bpt i="12" x="12">&lt;c12&gt;</bpt>reject<ept i="12">&lt;/c12&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134626Z" creationid="shibukawa.yoshiki" creationdate="20150415T134626Z">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt>then<ept i="8">&lt;/c8&gt;</ept>メソッドを呼ぶと、 <bpt i="9" x="9">&lt;c9&gt;</bpt>successCallback<ept i="9">&lt;/c9&gt;</ept>と、 <bpt i="10" x="10">&lt;c10&gt;</bpt>errorCallback<ept i="10">&lt;/c10&gt;</ept>で表される計算表現をpromiseに追加します。これは、<bpt i="11" x="11">&lt;c11&gt;</bpt>resolve<ept i="11">&lt;/c11&gt;</ept>か<bpt i="12" x="12">&lt;c12&gt;</bpt>reject<ept i="12">&lt;/c12&gt;</ept>が呼ばれると呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling this function without arguments returns the currently assigned redraw strategy.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152649Z" creationid="shibukawa.yoshiki" creationdate="20150416T152649Z">
        <seg>引数を渡さずにこの関数を呼ぶと、現在の再描画戦略を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling this method while using <bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>m.route<ept i="1">&lt;/c1&gt;</ept> should only be done if you have recurring asynchronous view updates (i.e. something that uses setInterval).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045615Z" creationid="shibukawa.yoshiki" creationdate="20150502T045615Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>m.route<ept i="1">&lt;/c1&gt;</ept>を使っている場合は、このメソッド呼び出しはsetIntervalを使っている場合など、非同期にビューを繰り返し更新したい場合に限定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Casting the Response Data to a Class</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130540Z" creationid="shibukawa.yoshiki" creationdate="20150410T130440Z">
        <seg>ウェブサービスから帰ってきたデータをクラスにキャスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Change log</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154309Z" creationid="shibukawa.yoshiki" creationdate="20150412T154309Z">
        <seg>変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Changes to controller and model values in this fashion will only render on the next <bpt i="2" x="2">&lt;c2&gt;</bpt>m.render<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>m.mount<ept i="3">&lt;/c3&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121719Z" creationid="shibukawa.yoshiki" creationdate="20150502T121719Z">
        <seg>この方法でコントローラやモデルの値を変更しても、次の<bpt i="2" x="2">&lt;c2&gt;</bpt>m.render<ept i="2">&lt;/c2&gt;</ept>呼び出しか、<bpt i="3" x="3">&lt;c3&gt;</bpt>m.mount<ept i="3">&lt;/c3&gt;</ept>呼び出しがあるまでは描画されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Changing redraw strategy</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T125045Z" creationid="shibukawa.yoshiki" creationdate="20150416T125045Z">
        <seg>再描画戦略の変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Changing the flag outside of a redrawable context does nothing since the flag gets reset when entering one of the documented redrawable contexts above.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T140537Z" creationid="shibukawa.yoshiki" creationdate="20150416T140537Z">
        <seg>上記の説明に書かれているように、再描画のコンテキストに入る時にこのフラグはリセットされるため、再描画コンテキスト外でこのフラグを設定しても無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Changing the temperature value from the input updates the temperature value, which is passed to the TemperatureConverter view directly, and transformation functions are called from there.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081444Z" creationid="shibukawa.yoshiki" creationdate="20150502T081444Z">
        <seg>入力フォームから温度を入力すると、温度値が変更されてTemperatureConverterに直接渡されます。ここから変換関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classic MVC</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180205Z" creationid="shibukawa.yoshiki" creationdate="20150501T180205Z">
        <seg>クラシックなMVC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Clever readers will probably notice that we can refactor the <bpt i="0" x="0">&lt;c0&gt;</bpt>add<ept i="0">&lt;/c0&gt;</ept> method to make it much simpler:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152348Z" creationid="shibukawa.yoshiki" creationdate="20150408T152348Z">
        <seg>賢い読者の方は、<bpt i="0" x="0">&lt;c0&gt;</bpt>add<ept i="0">&lt;/c0&gt;</ept>メソッドをもっとシンプルなコードにリファクタリングすることができることに気づいたかもしれません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Code Size</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015915Z" creationid="shibukawa.yoshiki" creationdate="20150417T015915Z">
        <seg>コードサイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Common reasons why one might need to change redraw strategy are:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143924Z" creationid="shibukawa.yoshiki" creationdate="20150416T143924Z">
        <seg>再描画戦略を変更する一般的な理由としては次のようなものがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compiling Templates</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140943Z" creationid="shibukawa.yoshiki" creationdate="20150407T140943Z">
        <seg>テンプレートのコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compiling a template transforms the nested function calls of a template into a raw virtual DOM tree (which is merely a collection of native Javascript objects that is ready to be rendered via <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.render<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144245Z" creationid="shibukawa.yoshiki" creationdate="20150412T144245Z">
        <seg>テンプレートをコンパイルすると、ネストされた関数呼び出しを生の仮想DOMツリーに変換します。これはネイティブのJavaScriptオブジェクトの集合体で、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.render<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を使って即座にレンダリングできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compiling templates</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143611Z" creationid="shibukawa.yoshiki" creationdate="20150412T143611Z">
        <seg>テンプレートのコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Component views can include other components:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080057Z" creationid="shibukawa.yoshiki" creationdate="20150502T080057Z">
        <seg>コンポーネントのビューは他のコンポーネントを持つことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140744Z" creationid="shibukawa.yoshiki" creationdate="20150407T140744Z">
        <seg>コンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T180346Z" creationid="shibukawa.yoshiki" creationdate="20150410T180346Z">
        <seg>コンポーネント - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components <bpt i="1" x="1">&lt;e1&gt;</bpt>can<ept i="1">&lt;/e1&gt;</ept> be stateful, but the purpose of component state is to prevent the pollution of the model layer with aspects that are inherently related to the component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T082912Z" creationid="shibukawa.yoshiki" creationdate="20150502T082912Z">
        <seg>コンポーネントはステートフルにすることも<bpt i="1" x="1">&lt;e1&gt;</bpt>できます<ept i="1">&lt;/e1&gt;</ept>が、コンポーネントに状態を持たせる目的は、モデルレイヤーが、コンポーネント内の情報で汚染されるのを防ぐことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components are building blocks for Mithril applications.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061139Z" creationid="shibukawa.yoshiki" creationdate="20150502T061139Z">
        <seg>コンポーネントはMithrilのアプリケーションを作成するのに使うブロックです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components are merely structures that represent a viewable "page" or a part of a page.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040205Z" creationid="shibukawa.yoshiki" creationdate="20150502T040205Z">
        <seg>コンポーネントは見ることが可能な「ページ」もしくはページの一部を表す、単なる構造体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components are versatile tools to organize code and can be used in a variety of ways.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180342Z" creationid="shibukawa.yoshiki" creationdate="20150501T180342Z">
        <seg>コンポーネントはコードを組織化するのに使える多目的なツールで、さまざまな用途があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components can be placed anywhere a regular element can.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080202Z" creationid="shibukawa.yoshiki" creationdate="20150502T080202Z">
        <seg>コンポーネントは、通常のエレメントが置けるところであればどこにでも置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components can be rendered without enabling the <bpt i="0" x="0">&lt;a0&gt;</bpt>auto-redrawing system<ept i="0">&lt;/a0&gt;</ept>, via <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.render<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100144Z" creationid="shibukawa.yoshiki" creationdate="20150502T100144Z">
        <seg>コンポーネントは<bpt i="0" x="0">&lt;a0&gt;</bpt>自動再描画システム<ept i="0">&lt;/a0&gt;</ept>を有効にせずに描画を行わせることができます。<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.render<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>を使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components can have arguments "preloaded".</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075023Z" creationid="shibukawa.yoshiki" creationdate="20150502T075023Z">
        <seg>コンポーネントは「事前にロードされた」引数を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Components that are nested inside other components can also call <bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept> and its <bpt i="1" x="1">&lt;c1&gt;</bpt>e.preventDefault()<ept i="1">&lt;/c1&gt;</ept> like top-level components.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092543Z" creationid="shibukawa.yoshiki" creationdate="20150502T092510Z">
        <seg>トップレベルのコンポーネントと同様に、他のコンポーネント内にネストされたコンポーネントの<bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept>を呼び出し、その中の<bpt i="1" x="1">&lt;c1&gt;</bpt>e.preventDefault()<ept i="1">&lt;/c1&gt;</ept>を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comprehensive integration</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010403Z" creationid="shibukawa.yoshiki" creationdate="20150412T010403Z">
        <seg>統括的な統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comprehensive integration is recommended if integrating a monolithic series of asynchronous operations.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010451Z" creationid="shibukawa.yoshiki" creationdate="20150412T010451Z">
        <seg>非同期の操作が、常に同じ手順で使われている場合には、統括的な統合がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Configuring the underlying XMLHttpRequest</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174649Z" creationid="shibukawa.yoshiki" creationdate="20150414T174649Z">
        <seg>バックエンドのXMLHttpRequestの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the spec requires either a <bpt i="0" x="0">&lt;c0&gt;</bpt>setImmediate<ept i="0">&lt;/c0&gt;</ept> polyfill (which is a significantly large library), or <bpt i="1" x="1">&lt;c1&gt;</bpt>setTimeout<ept i="1">&lt;/c1&gt;</ept> (which is required to take at least 4 milliseconds per call, according to its specs).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140848Z" creationid="shibukawa.yoshiki" creationdate="20150415T140848Z">
        <seg>仕様を満たすには、<bpt i="0" x="0">&lt;c0&gt;</bpt>setImmediate<ept i="0">&lt;/c0&gt;</ept>ポリフィル(将来のバージョンのJavaScriptと互換性を持たせるための、非常に巨大なライブラリ)か、<bpt i="1" x="1">&lt;c1&gt;</bpt>setTimeout<ept i="1">&lt;/c1&gt;</ept>(仕様により、最低でも4ミリ秒の待ちが発生する)が要求されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Contact.save(data.contact).then(Observable.trigger("updateContact"))
})

//ContactsWidget is the same as before
var ContactsWidget = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031258Z" creationid="shibukawa.yoshiki" creationdate="20150502T031258Z">
        <seg>Contact.save(data.contact).then(Observable.trigger("updateContact"))
})

//ContactsWidgetは以前と同じ
var ContactsWidget = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Content delivery networks allow the library to be cached across different websites that use the same version of the framework, and help reduce latency by serving the files from a server that is physically near the user's location.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165709Z" creationid="shibukawa.yoshiki" creationdate="20150407T165709Z">
        <seg>CDNを使うと、同じバージョンのフレームワーク使用する、さまざまなウェブサイト間でライブラリの共有が可能になります。また、ユーザの場所から物理的に近いサーバからダウンロードが行われるため、表示の遅延を減らすのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Controller</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163857Z" creationid="shibukawa.yoshiki" creationdate="20150407T163857Z">
        <seg>コントローラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Controller as a class constructor</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045949Z" creationid="shibukawa.yoshiki" creationdate="20150502T045949Z">
        <seg>クラスコンストラクタ形式のコントローラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Controllers are deregistered when their <bpt i="4" x="4">&lt;c4&gt;</bpt>onunload<ept i="4">&lt;/c4&gt;</ept> event is triggered.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021025Z" creationid="shibukawa.yoshiki" creationdate="20150502T021025Z">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>onunload<ept i="4">&lt;/c4&gt;</ept>イベントが起動されるとコントローラの登録は解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Controllers may explicitly call <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>m.redraw<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>, but, if possible, it's preferable to abstract this into a service which integrates with Mithril's auto-redrawing system (see <bpt i="5" x="5">&lt;a5&gt;</bpt><bpt i="6" x="6">&lt;c6&gt;</bpt>m.startComputation<ept i="6">&lt;/c6&gt;</ept> / <bpt i="7" x="7">&lt;c7&gt;</bpt>m.endComputation<ept i="7">&lt;/c7&gt;</ept><ept i="5">&lt;/a5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033711Z" creationid="shibukawa.yoshiki" creationdate="20150421T033711Z">
        <seg>コントローラで明示的に<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>m.redraw<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>を呼び出すことも出来ますが、操作を抽象化してMithrilの自動再描画システムと統合する方が望ましいです(<bpt i="5" x="5">&lt;a5&gt;</bpt><bpt i="6" x="6">&lt;c6&gt;</bpt>m.startComputation<ept i="6">&lt;/c6&gt;</ept> / <bpt i="7" x="7">&lt;c7&gt;</bpt>m.endComputation<ept i="7">&lt;/c7&gt;</ept><ept i="5">&lt;/a5&gt;</ept>参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Core</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153107Z" creationid="shibukawa.yoshiki" creationdate="20150412T153107Z">
        <seg>コア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Core Topics</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140757Z" creationid="shibukawa.yoshiki" creationdate="20150407T140623Z">
        <seg>基本トピック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Cross-communication in single-purpose components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180149Z" creationid="shibukawa.yoshiki" creationdate="20150501T180149Z">
        <seg>単一目的のコンポーネント間のコミュニケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Custom request rejections</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174633Z" creationid="shibukawa.yoshiki" creationdate="20150414T174633Z">
        <seg>カスタムリクエストのリジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>DOM manipulation should be done in the view via <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m()<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>config<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T021348Z" creationid="shibukawa.yoshiki" creationdate="20150421T021246Z">
        <seg>DOM操作は、ビュー内の<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m()<ept i="1">&lt;/c1&gt;</ept>と、<bpt i="2" x="2">&lt;c2&gt;</bpt>config<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept>でのみ行うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Data</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153741Z" creationid="shibukawa.yoshiki" creationdate="20150412T153741Z">
        <seg>データ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Data Bindings</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014703Z" creationid="shibukawa.yoshiki" creationdate="20150408T014703Z">
        <seg>データバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Data bindings connect a DOM element to a Javascript variable so that updating one updates the other.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014842Z" creationid="shibukawa.yoshiki" creationdate="20150408T014842Z">
        <seg>データバインディングは、DOM要素とJavaScriptの変数変数を結びつけて、片方の変更をもう片方に反映させるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Data manipulation should be done in model classes, such that controllers never have entities lying around in temporarily invalid states.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032029Z" creationid="shibukawa.yoshiki" creationdate="20150421T014232Z">
        <seg>データ操作はモデルクラス内で行われるべきです。コントローラが一時的にとはいえ、不完全な状態のモデルを取り扱うべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Data to be deserialized</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013247Z" creationid="shibukawa.yoshiki" creationdate="20150415T013247Z">
        <seg>デシリアライズするデータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Data to be sent.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002405Z" creationid="shibukawa.yoshiki" creationdate="20150415T002405Z">
        <seg>送信するデータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Data to be serialized</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013135Z" creationid="shibukawa.yoshiki" creationdate="20150415T013135Z">
        <seg>シリアライズするデータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Data-driven component identity</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050634Z" creationid="shibukawa.yoshiki" creationdate="20150502T050634Z">
        <seg>データ駆動コンポーネントの同一性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dealing with focus</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235035Z" creationid="shibukawa.yoshiki" creationdate="20150412T235035Z">
        <seg>フォーカスの操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dealing with sorting and deleting in lists</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235054Z" creationid="shibukawa.yoshiki" creationdate="20150412T235054Z">
        <seg>リスト内のソートと削除の操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dealing with state</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050550Z" creationid="shibukawa.yoshiki" creationdate="20150502T050550Z">
        <seg>状態の取り扱い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default value is "search".</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165706Z" creationid="shibukawa.yoshiki" creationdate="20150414T165706Z">
        <seg>デフォルトは"search"です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defaults to "callback"</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014628Z" creationid="shibukawa.yoshiki" creationdate="20150415T014628Z">
        <seg>デフォルト値は"callback"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defaults to <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152156Z" creationid="shibukawa.yoshiki" creationdate="20150416T152156Z">
        <seg>デフォルト値は<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defaults to <bpt i="0" x="0">&lt;c0&gt;</bpt>undefined<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002340Z" creationid="shibukawa.yoshiki" creationdate="20150415T002340Z">
        <seg>デフォルトは<bpt i="0" x="0">&lt;c0&gt;</bpt>undefined<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defaults to false.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171614Z" creationid="shibukawa.yoshiki" creationdate="20150414T171614Z">
        <seg>デフォルトはfalseです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defending against nullables can typically be achieved via the <bpt i="0" x="0">&lt;c0&gt;</bpt>initialValue<ept i="0">&lt;/c0&gt;</ept> option in <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.request<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> and basic null checks (e.g. <it pos="begin" x="3">&lt;c3&gt;</it>data ?</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121023Z" creationid="shibukawa.yoshiki" creationdate="20150502T121023Z">
        <seg>nullになる可能性がある場合の対処法としては、<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.request<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>に<bpt i="0" x="0">&lt;c0&gt;</bpt>initialValue<ept i="0">&lt;/c0&gt;</ept>オプションを指定するか、基本的なnullチェック(例: <it pos="begin" x="3">&lt;c3&gt;</it>data ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defines the property of the DOM element whose value will be passed to the callback.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140830Z" creationid="shibukawa.yoshiki" creationdate="20150414T140830Z">
        <seg>この関数のコールバックに渡したい値を持つ、DOMエレメントのプロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defines what routes exist</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153238Z" creationid="shibukawa.yoshiki" creationdate="20150412T153238Z">
        <seg>存在するラウトの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defining routes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162438Z" creationid="shibukawa.yoshiki" creationdate="20150409T162432Z">
        <seg>ラウトの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Demo</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034741Z" creationid="shibukawa.yoshiki" creationdate="20150502T034741Z">
        <seg>デモ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deserializes an object from an URI encoded querystring representation, following the same deserialization conventions as <bpt i="0" x="0">&lt;a0&gt;</bpt>URI.js<ept i="0">&lt;/a0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135909Z" creationid="shibukawa.yoshiki" creationdate="20150502T135909Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>URI.js<ept i="0">&lt;/a0&gt;</ept>のデシリアライズ規約を用いて、URIエンコードされたクエリー文字列表現されたオブジェクトをデシリアライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Destructors</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T234210Z" creationid="shibukawa.yoshiki" creationdate="20150412T234210Z">
        <seg>デストラクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Determines whether the <bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept> can affect template rendering.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002601Z" creationid="shibukawa.yoshiki" creationdate="20150415T002601Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept>中にテンプレートのレンダリング行うかどうかの設定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Difference between computation methods and m.redraw</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T112333Z" creationid="shibukawa.yoshiki" creationdate="20150502T112333Z">
        <seg>computationメソッドとm.redrawの違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Differences from Other MVC Frameworks</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140957Z" creationid="shibukawa.yoshiki" creationdate="20150407T140957Z">
        <seg>他のMVCフレームワークとの違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Differences from Promises/A+</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015805Z" creationid="shibukawa.yoshiki" creationdate="20150415T015805Z">
        <seg>Promises/A+との違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Direct download</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164448Z" creationid="shibukawa.yoshiki" creationdate="20150407T164448Z">
        <seg>直接ダウンロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Distribution of concrete responsibilities</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180130Z" creationid="shibukawa.yoshiki" creationdate="20150501T180130Z">
        <seg>具体的な責務の分担</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not create or manipulate trust flags manually.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015611Z" creationid="shibukawa.yoshiki" creationdate="20150416T015611Z">
        <seg>信頼するフラグを手で作成したり変更しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Docs and code samples for your reference</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135618Z" creationid="shibukawa.yoshiki" creationdate="20150407T135618Z">
        <seg>参照用のドキュメントとコードサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Documentation</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113916Z" creationid="shibukawa.yoshiki" creationdate="20150417T113916Z">
        <seg>ドキュメンテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Doing it in the controller level is also possible, but philosophically not recommended, because by tying logic to a controller, the code becomes harder to reuse due to unrelated controller dependencies.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124045Z" creationid="shibukawa.yoshiki" creationdate="20150410T124045Z">
        <seg>この処理をコントローラのレベルで行うことができますが、Mithrilの哲学としては推奨していません。コントローラと関係ない処理であったとしても、コントローラとロジックが結びついてしまうと再利用が難しくなるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Doing it in the model level is also possible, but generally leads to more code in order to connect all the dots.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125012Z" creationid="shibukawa.yoshiki" creationdate="20150410T125012Z">
        <seg>もちろん、モデルレベルで行うこともできますが、全ての関連する機能を正しく動かすためには、多くのコードを書く必要がああります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Doing it in the model level is also possible, but philosophically not recommended, because by tying redirection to the model, the code becomes harder to reuse due to overly tight coupling.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124425Z" creationid="shibukawa.yoshiki" creationdate="20150410T124425Z">
        <seg>この処理をモデル例やで行うことも出来ますが、Mithrilの哲学としては非推奨です。リダイレクト処理とモデルが結びついてしまうと、再利用が難しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Doing so will trigger another redraw, which will result in an infinite loop.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094851Z" creationid="shibukawa.yoshiki" creationdate="20150502T094851Z">
        <seg>再描画処理の中で再描画を行ってしまうと、無限ループになってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dynamic parameters are wild cards that allow selecting a component based on a URL pattern.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135745Z" creationid="shibukawa.yoshiki" creationdate="20150502T135745Z">
        <seg>動的パラメータは、URLパターンに応じてコンポーネント選択する時に使用できるワイルドカードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dynamic parameters are words preceded by a colon <bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T160002Z" creationid="shibukawa.yoshiki" creationdate="20150414T160002Z">
        <seg>動的パラメータはコロン(<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>)で始まっている単語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each <bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept> call creates a virtual DOM element, that is, a Javascript object that represents a DOM element, and which is eventually converted into one.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000527Z" creationid="shibukawa.yoshiki" creationdate="20150413T000527Z">
        <seg>それぞれの<bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept>呼び出して作成される仮想DOM要素は、DOMエレメントに対応する情報を持つJavaScriptオブジェクトで、最終的にDOMエレメントに変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each computation function takes a value as a parameter and is expected to return another value, which in turns is forwarded along to the next computation function (or functions) in the tree.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T133903Z" creationid="shibukawa.yoshiki" creationdate="20150415T133903Z">
        <seg>それぞれの計算関数はその値を引数として受け取り、他の値を返すことが期待されています。その値は、木の中の次の計算関数に渡されていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each of these should point to a Javascript function.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100447Z" creationid="shibukawa.yoshiki" creationdate="20150502T100447Z">
        <seg>それぞれ、JavaScriptの関数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each of those should point to a Javascript function</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125556Z" creationid="shibukawa.yoshiki" creationdate="20150502T125556Z">
        <seg>このどちらの属性も、JavaScriptの関数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Elements are recreated if either their node name changes, or if the list of attribute names change, or if the ID attribute changes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144131Z" creationid="shibukawa.yoshiki" creationdate="20150413T144131Z">
        <seg>ノード名が変更されたり、属性名のリストが変更されたり、ID属性が変更されれば、エレメントは再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Ember is a highly comprehensive MVC framework, providing a large API that covers not only traditional MVC patterns, but also a vast range of helper utilities as well.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095246Z" creationid="shibukawa.yoshiki" creationdate="20150420T095246Z">
        <seg>Emberは伝統的なMVCフレームワークだけではなく、さまざまな大量のヘルパーコードを含む、非常に大きなAPIセットを提供する広範囲に渡るMVCフレームワークです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Ember is also more opinionated in terms of how application architecture should look, and as a result, tends to be less transparent in terms of what is actually happening under the hood.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095555Z" creationid="shibukawa.yoshiki" creationdate="20150420T095555Z">
        <seg>Emberはまた、アプリケーションのアーキテクチャがどうあるべきかを厳しく規定しています。そのため、裏で何が起こっているのかが不透明で見通しにくくなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Error binding is meant to be done in the controller layer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124907Z" creationid="shibukawa.yoshiki" creationdate="20150410T124907Z">
        <seg>Mithrilではエラーのバインディングはコントローラレベルで行われることを想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Example URL: <bpt i="0" x="0">&lt;c0&gt;</bpt>http://server/#/path/to/page<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005232Z" creationid="shibukawa.yoshiki" creationdate="20150410T005232Z">
        <seg>サンプルURL: <bpt i="0" x="0">&lt;c0&gt;</bpt>http://server/#/path/to/page<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Example URL: <bpt i="0" x="0">&lt;c0&gt;</bpt>http://server/?/path/to/page<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005115Z" creationid="shibukawa.yoshiki" creationdate="20150410T005115Z">
        <seg>サンプルURL: <bpt i="0" x="0">&lt;c0&gt;</bpt>http://server/?/path/to/page<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Example URL: <bpt i="0" x="0">&lt;c0&gt;</bpt>http://server/path/to/page<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005502Z" creationid="shibukawa.yoshiki" creationdate="20150410T005502Z">
        <seg>サンプルURL: <bpt i="0" x="0">&lt;c0&gt;</bpt>http://server/path/to/page<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Example: HTML5 drag-n-drop file uploader component</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031809Z" creationid="shibukawa.yoshiki" creationdate="20150501T180240Z">
        <seg>サンプル: HTML5ドラッグ・アンド・ドロップでファイルアップロードするコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Examples:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153334Z" creationid="shibukawa.yoshiki" creationdate="20150413T153334Z">
        <seg>サンプル:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Expressiveness can be achieved using standard refactoring techniques:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015459Z" creationid="shibukawa.yoshiki" creationdate="20150413T015459Z">
        <seg>一般的なリファクタリングのテクニックを使うと、表現力を向上させることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extracting Metadata from the Response</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174624Z" creationid="shibukawa.yoshiki" creationdate="20150414T174624Z">
        <seg>レスポンス中のメタデータの分解</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Falls back to <bpt i="0" x="0">&lt;c0&gt;</bpt>window.setTimeout<ept i="0">&lt;/c0&gt;</ept>/<bpt i="1" x="1">&lt;c1&gt;</bpt>window.clearTimeout<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T162112Z" creationid="shibukawa.yoshiki" creationdate="20150416T162112Z">
        <seg>利用できないときは代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt>window.setTimeout<ept i="0">&lt;/c0&gt;</ept>/<bpt i="1" x="1">&lt;c1&gt;</bpt>window.clearTimeout<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fast</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133849Z" creationid="shibukawa.yoshiki" creationdate="20150407T133849Z">
        <seg>高速</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>File Separation</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015007Z" creationid="shibukawa.yoshiki" creationdate="20150421T015007Z">
        <seg>ファイル分割</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>File uploads with FormData</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174538Z" creationid="shibukawa.yoshiki" creationdate="20150414T174538Z">
        <seg>FormDataによるファイルのアップロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, the low-level <bpt i="8" x="8">&lt;a8&gt;</bpt><bpt i="9" x="9">&lt;c9&gt;</bpt>m.render<ept i="9">&lt;/c9&gt;</ept><ept i="8">&lt;/a8&gt;</ept> can also be used if a developer chooses to opt out of rest of the framework altogether.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000546Z" creationid="shibukawa.yoshiki" creationdate="20150506T000546Z">
        <seg>また、開発者が再描画の仕組みを完全に止める選択をした場合にも、<bpt i="8" x="8">&lt;a8&gt;</bpt><bpt i="9" x="9">&lt;c9&gt;</bpt>m.render<ept i="9">&lt;/c9&gt;</ept><ept i="8">&lt;/a8&gt;</ept>関数を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First and foremost, you should think hard about whether performance optimization is truly your last resort.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142408Z" creationid="shibukawa.yoshiki" creationdate="20150412T142408Z">
        <seg>まず第一に、パフォーマンスの最適化が自分にとって最後の手段であるかどうかを真剣に考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For developer convenience, Mithril makes an exception for the <bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept> attribute: if there are classes defined in both parameters, they are concatenated as a space separated list.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153249Z" creationid="shibukawa.yoshiki" creationdate="20150413T153249Z">
        <seg>開発者の利便性のために、Mithrilは<bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept>属性は特別扱いをします。もし両方で定義されていた場合には、スペース区切りのリストとして2つのパラメータを統合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For each <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> call a library makes, it MUST also make one and ONLY one corresponding <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193257Z" creationid="shibukawa.yoshiki" creationdate="20150411T193257Z">
        <seg>ライブラリ内のそれぞれの<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept>呼び出しに対して、「かならず」「１回だけ」<bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example a form might have an input and a cancel button.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T160654Z" creationid="shibukawa.yoshiki" creationdate="20150407T153100Z">
        <seg>例えば、テキスト入力とキャンセルのボタンを持っているフォームがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an autocompleter component may need to internally store a flag to indicate whether the dropdown is visible, but this kind of state is not relevant to an application's business logic.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T083342Z" creationid="shibukawa.yoshiki" creationdate="20150502T083342Z">
        <seg>例えば、自動補完コンポーネントはドロップダウンが表示されているかどうかのフラグを持っています。しかしこの種の状態はアプリケーションのビジネスロジックは関係ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, both <bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>className<ept i="1">&lt;/c1&gt;</ept> are valid.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153529Z" creationid="shibukawa.yoshiki" creationdate="20150413T153529Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept>も<bpt i="1" x="1">&lt;c1&gt;</bpt>className<ept i="1">&lt;/c1&gt;</ept>も使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if <bpt i="0" x="0">&lt;c0&gt;</bpt>type<ept i="0">&lt;/c0&gt;</ept> is the following class:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013847Z" creationid="shibukawa.yoshiki" creationdate="20150415T013847Z">
        <seg>もし<bpt i="0" x="0">&lt;c0&gt;</bpt>type<ept i="0">&lt;/c0&gt;</ept>として次のクラスが渡されたとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if the response is <bpt i="0" x="0">&lt;c0&gt;</bpt>{data: [{name: "John"}, {name: "Mary"}]}<ept i="0">&lt;/c0&gt;</ept> and the unwrap function is <bpt i="1" x="1">&lt;c1&gt;</bpt>function(response) {return response.data}<ept i="1">&lt;/c1&gt;</ept>, then the response will be considered to be <bpt i="2" x="2">&lt;c2&gt;</bpt>[{name: "John"}, {name: "Mary"}]<ept i="2">&lt;/c2&gt;</ept> when processing the <bpt i="3" x="3">&lt;c3&gt;</bpt>type<ept i="3">&lt;/c3&gt;</ept> parameter</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012946Z" creationid="shibukawa.yoshiki" creationdate="20150415T012946Z">
        <seg>もし返り値が<bpt i="0" x="0">&lt;c0&gt;</bpt>{data: [{name: "John"}, {name: "Mary"}]}<ept i="0">&lt;/c0&gt;</ept>というJSONで、unwrap関数として<bpt i="1" x="1">&lt;c1&gt;</bpt>function(response) {return response.data}<ept i="1">&lt;/c1&gt;</ept>という関数が渡された場合には、<bpt i="3" x="3">&lt;c3&gt;</bpt>type<ept i="3">&lt;/c3&gt;</ept>パラメータの評価時に<bpt i="2" x="2">&lt;c2&gt;</bpt>[{name: "John"}, {name: "Mary"}]<ept i="2">&lt;/c2&gt;</ept>というデータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if todo descriptions needed to always be uppercased, one could simply change the <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> getter-setter:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002402Z" creationid="shibukawa.yoshiki" creationdate="20150409T002402Z">
        <seg>例えば、ToDoの説明(description)が大文字でなければならないとしたら、<bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> getter-setterだけを置き換えればこれが実現できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if we wanted to change the application to make the list be persisted, a native Array would most certainly not be a suitable class to use.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003136Z" creationid="shibukawa.yoshiki" creationdate="20150409T003136Z">
        <seg>例えば、リストを永続化させる機能をアプリケーションに追加したくなったとすると、ネイティブのArrayクラスはもっとも適切なクラスとは言えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you are building a table with thousands of rows and finding that the template is slow, you should first consider making the table show less items, because from a user experience perspective, no one is realistically going to scan through thousands of records.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143359Z" creationid="shibukawa.yoshiki" creationdate="20150412T143359Z">
        <seg>もし、数千行の行を持つテーブルの構築を行っていて、そのテンプレートの動作が遅いことが分かったとしても、まずはユーザビリティの観点から表示行数を少なくすることを検討すべきです。だれも数千行のレコードを実際に読み込もうとする人などいないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you were to call a web service using <bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept>, you would not need to add more calls to <bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> / <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept> (you would still need the first pair in the event handler, though).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134719Z" creationid="shibukawa.yoshiki" creationdate="20150412T134719Z">
        <seg>例えば、もし非同期のウェブサービス呼び出しに<bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept>を使っていれば、これ以上<bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> / <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept>呼び出しを追加する必要はありませんが、イベントハンドラには追加しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, let's say that you're generating a link from an entry that comes from a web service:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002254Z" creationid="shibukawa.yoshiki" creationdate="20150413T002254Z">
        <seg>ウェブサービスから帰ってきたエントリーを元に、動的にリンクが書き換わるようなリンクを作成するには次のようにします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the value for <bpt i="0" x="0">&lt;c0&gt;</bpt>className<ept i="0">&lt;/c0&gt;</ept> should be a string.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153641Z" creationid="shibukawa.yoshiki" creationdate="20150413T153641Z">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>className<ept i="0">&lt;/c0&gt;</ept>の値は文字列である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the value for the <bpt i="0" x="0">&lt;c0&gt;</bpt>onclick<ept i="0">&lt;/c0&gt;</ept> attribute should be a function.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153914Z" creationid="shibukawa.yoshiki" creationdate="20150413T153914Z">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>onclick<ept i="0">&lt;/c0&gt;</ept>属性は関数を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, there is simply never a case where a developer would want to programmatically handle the error of accessing the property of a nullable entity without first checking for its existence.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172742Z" creationid="shibukawa.yoshiki" creationdate="20150415T172742Z">
        <seg>開発者は、最初にその存在を把握しなければ、nullになる可能性のあるオブジェクトのプロパティのアクセスエラーのハンドリングをしたいとは思わないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you might have a <bpt i="0" x="0">&lt;c0&gt;</bpt>UserForm<ept i="0">&lt;/c0&gt;</ept> component that lives alongside other unrelated components on a bigger page, but it probably doesn't make sense for the parent page to be aware of the unsaved user data stored within the <bpt i="1" x="1">&lt;c1&gt;</bpt>UserForm<ept i="1">&lt;/c1&gt;</ept> component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084102Z" creationid="shibukawa.yoshiki" creationdate="20150502T084102Z">
        <seg>例えば、大きなページ内に、他の関係ないコンポーネントと一緒に<bpt i="0" x="0">&lt;c0&gt;</bpt>UserForm<ept i="0">&lt;/c0&gt;</ept>コンポーネントがあったとします。<bpt i="1" x="1">&lt;c1&gt;</bpt>UserForm<ept i="1">&lt;/c1&gt;</ept>コンポーネント内に未保存のデータがあった場合は、親ページに知らせる必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you might only be interested in running a redraw if a user presses the space bar, and you might not want to waste a redraw if the user presses any other key.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150203Z" creationid="shibukawa.yoshiki" creationdate="20150416T150203Z">
        <seg>例えば、ユーザがスペースバーを推した時だけ再描画を行い、そうでない場合は再描画はムダなのでやりたいくない、ということもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013232Z" creationid="shibukawa.yoshiki" creationdate="20150410T013232Z">
        <seg>サンプル:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on components, see <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.component<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125538Z" creationid="shibukawa.yoshiki" creationdate="20150502T125538Z">
        <seg>より詳細な情報は<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.component<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information see this page:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014234Z" creationid="shibukawa.yoshiki" creationdate="20150417T014234Z">
        <seg>詳細についてはこのページを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For simplicity, our application will have only one component, and we're going to use it as the namespace for our application.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040232Z" creationid="shibukawa.yoshiki" creationdate="20150502T040232Z">
        <seg>サンプルを簡単にするために、これから作るアプリケーションにはコンポーネントを1つだけ作ることにします。そしてそれをアプリケーションの名前空間として使っていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the most part, Mithril promises behave as you'd expect a <bpt i="0" x="0">&lt;a0&gt;</bpt>Promise/A+<ept i="0">&lt;/a0&gt;</ept> promise to behave, but have one difference: Mithril promises attempt to execute synchronously if possible.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140147Z" creationid="shibukawa.yoshiki" creationdate="20150415T140022Z">
        <seg>ほとんどの部分で、Mithrilのpromiseは<bpt i="0" x="0">&lt;a0&gt;</bpt>Promise/A+<ept i="0">&lt;/a0&gt;</ept>の仕様通りの動作をしますが1つ異なる点があります。Mithrilのpromiseは、可能であれば同期で処理を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the purposes of testing out our code so far, the view can be rendered using the <bpt i="0" x="0">&lt;c0&gt;</bpt>m.render<ept i="0">&lt;/c0&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013558Z" creationid="shibukawa.yoshiki" creationdate="20150408T013537Z">
        <seg>コードをテストする目的で表示したい場合は、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.render<ept i="0">&lt;/c0&gt;</ept>メソッドを呼ぶことでビューをレンダリングすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For this reason, <bpt i="0" x="0">&lt;c0&gt;</bpt>m.trust<ept i="0">&lt;/c0&gt;</ept> will not auto-run <bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;script&gt;<ept i="1">&lt;/c1&gt;</ept> tags from trusted strings.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014430Z" creationid="shibukawa.yoshiki" creationdate="20150416T014430Z">
        <seg>このため、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.trust<ept i="0">&lt;/c0&gt;</ept>が自動的に<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;script&gt;<ept i="1">&lt;/c1&gt;</ept>タグを実行することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Forcing redraw</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T125110Z" creationid="shibukawa.yoshiki" creationdate="20150416T125110Z">
        <seg>強制再描画</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fortunately, bindings can also be <bpt i="0" x="0">&lt;s0&gt;</bpt>bi-directional<ept i="0">&lt;/s0&gt;</ept>: that is, they can be coded in such a way that, in addition to setting the DOM value, it's also possible to read it as a user types, and then update the <bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept> getter-setter in the view-model.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T110549Z" creationid="shibukawa.yoshiki" creationdate="20150408T020207Z">
        <seg>幸い、バインディングは<bpt i="0" x="0">&lt;s0&gt;</bpt>双方向<ept i="0">&lt;/s0&gt;</ept>で行うように設定することができます。双方向になると、DOMの値を設定するだけでなく、ユーザが入力した内容を読み込んで、ビューモデル内の<bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept> setter-getterの内容を更新することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fortunately, with Mithril, it's possible for developers to attach an identity key to elements so that array operations like shift, splice and sort only affect the minimum amount of elements required, leaving the rest of the DOM elements untouched when a redraw happens.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141643Z" creationid="shibukawa.yoshiki" creationdate="20150413T141643Z">
        <seg>幸い、Mithrilでは、開発が各エレメントに識別子のキーを付与できるため、シフト、スプライス、ソートといった配列操作が行われても、再描画時に最小のエレメントだけを変更し、残りのDOMエレメントは変更されないようにする、といったことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>From the get-go, Mithril's build system produces archived versions of the code and documentation so that you'll never be stuck without docs for out-of-date versions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114752Z" creationid="shibukawa.yoshiki" creationdate="20150417T114752Z">
        <seg>Mithrilのビルドシステムは、過去のバージョンのコードとドキュメントをすべてアーカイブします。過去のバージョンの情報がなくて困ることもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getter-setters are JSON-serializable:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135617Z" creationid="shibukawa.yoshiki" creationdate="20150414T135617Z">
        <seg>getter-setterはJSONにシリアライズすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getter-setters work like this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150526Z" creationid="shibukawa.yoshiki" creationdate="20150407T150526Z">
        <seg>getter-setterは次のように動作します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getting Started</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140635Z" creationid="shibukawa.yoshiki" creationdate="20150407T140635Z">
        <seg>はじめよう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getting Started - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140640Z" creationid="shibukawa.yoshiki" creationdate="20150407T140554Z">
        <seg>はじめよう - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Given how young Mithril is, hopefully you can appreciate the level of commitment for providing good documentation.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114904Z" creationid="shibukawa.yoshiki" creationdate="20150417T114904Z">
        <seg>Mithrilはまだまだ若いのですが、良いドキュメントを提供することに対してどれだけのコミットメントをしているかを理解してもらえれば幸いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Given the code above, the replacement class would only need to implement the <bpt i="0" x="0">&lt;c0&gt;</bpt>.push()<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>.map()<ept i="1">&lt;/c1&gt;</ept> methods.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003616Z" creationid="shibukawa.yoshiki" creationdate="20150409T003616Z">
        <seg>上記のコードの場合は、新しいクラスに必要なメソッド<bpt i="0" x="0">&lt;c0&gt;</bpt>.push()<ept i="0">&lt;/c0&gt;</ept>メソッドと<bpt i="1" x="1">&lt;c1&gt;</bpt>.map()<ept i="1">&lt;/c1&gt;</ept>メソッドだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Given the example in the "Defining Routes" section:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013027Z" creationid="shibukawa.yoshiki" creationdate="20150410T013027Z">
        <seg>ラウトの定義のセクションのサンプルですでに使っています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Go to mailing list</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135804Z" creationid="shibukawa.yoshiki" creationdate="20150407T135804Z">
        <seg>メーリングリストへ飛ぶ(英語)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Good Practices</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141019Z" creationid="shibukawa.yoshiki" creationdate="20150407T141019Z">
        <seg>良いプラクティス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Guide</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135500Z" creationid="shibukawa.yoshiki" creationdate="20150407T135500Z">
        <seg>ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>HTML-to-Mithril Template Converter</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013413Z" creationid="shibukawa.yoshiki" creationdate="20150417T013413Z">
        <seg>HTML→Mithrilテンプレートコンバータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here are the highlights of the template above:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153647Z" creationid="shibukawa.yoshiki" creationdate="20150408T153647Z">
        <seg>このテンプレートの大事なポイントを個別に説明していきます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here we've moved <bpt i="0" x="0">&lt;c0&gt;</bpt>Contact.save(contact).then(Observable.broadcast("updateContact"))<ept i="0">&lt;/c0&gt;</ept> out of the <bpt i="1" x="1">&lt;c1&gt;</bpt>ContactForm<ept i="1">&lt;/c1&gt;</ept> component and into the model layer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031438Z" creationid="shibukawa.yoshiki" creationdate="20150502T031438Z">
        <seg>このコードでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Contact.save(contact).then(Observable.broadcast("updateContact"))<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>ContactForm<ept i="1">&lt;/c1&gt;</ept>コンポーネントの中から、モデルレイヤの中に移動しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's a less trivial example:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002409Z" creationid="shibukawa.yoshiki" creationdate="20150413T002409Z">
        <seg>ちょっと応用的なサンプルです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's a refactored version of the sample app above to illustrate:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013615Z" creationid="shibukawa.yoshiki" creationdate="20150502T013615Z">
        <seg>以下のコードは上記のコードをリファクタリングしたものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's an example of a more aggressive refactor:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015627Z" creationid="shibukawa.yoshiki" creationdate="20150413T015627Z">
        <seg>もっとアグレッシブなリファクタリングを行うとこうなります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's an example of a not-so-trivial component: a drag-n-drop file uploader.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031830Z" creationid="shibukawa.yoshiki" creationdate="20150502T031802Z">
        <seg>１つ面白いサンプルを紹介します。ドラッグ・アンド・ドロップでファイルをアップロードするコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's an example using the <bpt i="0" x="0">&lt;a0&gt;</bpt>Q<ept i="0">&lt;/a0&gt;</ept> promise library:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135433Z" creationid="shibukawa.yoshiki" creationdate="20150414T135433Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>Q<ept i="0">&lt;/a0&gt;</ept>というpromiseライブラリを使うサンプルがこちらです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's one last, but relevant variation of the pattern above.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031135Z" creationid="shibukawa.yoshiki" creationdate="20150502T031135Z">
        <seg>次は最後のパターンです。上記で説明したものの変形バージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's one way to implement cross-communication between single purpose components:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015605Z" creationid="shibukawa.yoshiki" creationdate="20150502T015605Z">
        <seg>以下のコードは、上記の単一機能を提供するコンポーネント間のコミュニケーションを提供する方法です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's the application code in its entirety:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T162102Z" creationid="shibukawa.yoshiki" creationdate="20150408T162102Z">
        <seg>完全なアプリケーションのコードはこちらになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here's the most basic way of implementing the view-to-model part of the binding:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021122Z" creationid="shibukawa.yoshiki" creationdate="20150408T020244Z">
        <seg>次のコードが、ビューからモデルへのバインディングを行う、最小限の実装になります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the data fetching is still centralized in the top-level component, so that we can avoid duplicate AJAX requests when fetching data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T030721Z" creationid="shibukawa.yoshiki" creationdate="20150502T030721Z">
        <seg>この場合データの取得コードはトップレーベルモジュールに集約されています。これによりAJAXリクエストを何度も行うことを避けられるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, we've defined a class called <bpt i="0" x="0">&lt;c0&gt;</bpt>Contact<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T224039Z" creationid="shibukawa.yoshiki" creationdate="20150501T224023Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Contact<ept i="0">&lt;/c0&gt;</ept>(連絡先)クラスを定義しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hierarchical MVC via components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133844Z" creationid="shibukawa.yoshiki" creationdate="20150407T133844Z">
        <seg>コンポーネントによる階層型MVC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>History</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154247Z" creationid="shibukawa.yoshiki" creationdate="20150412T154247Z">
        <seg>履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hopefully by now, you're starting to see why Mithril encourages the usage of <bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept>: Because Mithril getter-setters are functions, they naturally compose well with functional programming tools, and allow for some very powerful idioms.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152126Z" creationid="shibukawa.yoshiki" creationdate="20150408T152126Z">
        <seg>これまでの説明の中で、なぜMithrilが<bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept>を使うことを推奨しているのか、お気づきの方もいると思います。Mithrilのgetter-setterは関数です。それにより、関数型プログラミングの道具と、相性良く組みわせることができて、強力な書き方が使えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hopefully these examples give you an idea of ways requirements can change over time and how Mithril's philosophy allows developers to use standard OOP techniques to refactor their codebases, rather than needing to modify large portions of the application.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T012924Z" creationid="shibukawa.yoshiki" creationdate="20150409T012924Z">
        <seg>要件は時間とともに変化しますが、これらの例から、Mithrilがどのような哲学を持って、開発者がコードベースをリファクタリングする際に、どのように標準的なオブジェクト指向プログラミングのテクニックを使って欲しいと思っているか、アプリケーションを大きな塊にしないで小さくして欲しいと考えているのかが伝われば幸いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How Should Code Be Organized</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110751Z" creationid="shibukawa.yoshiki" creationdate="20150420T110751Z">
        <seg>推奨されるコード構成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How Should Code Be Organized - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110757Z" creationid="shibukawa.yoshiki" creationdate="20150420T110706Z">
        <seg>推奨されるコード構成 - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How auto-redrawing works</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152913Z" creationid="shibukawa.yoshiki" creationdate="20150416T152913Z">
        <seg>どのように再描画が行われるか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How is Mithril Different from Other Frameworks</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015649Z" creationid="shibukawa.yoshiki" creationdate="20150417T015649Z">
        <seg>Mithrilと他のフレームワークの違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How is Mithril Different from Other Frameworks - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015419Z" creationid="shibukawa.yoshiki" creationdate="20150417T015419Z">
        <seg>Mithrilと他のフレームワークの違い - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How to read signatures</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150434Z" creationid="shibukawa.yoshiki" creationdate="20150413T150434Z">
        <seg>シグニチャの読み方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, as I mentioned before, you can enable an <bpt i="1" x="1">&lt;a1&gt;</bpt>auto-redrawing system<ept i="1">&lt;/a1&gt;</ept>, by initializing the <bpt i="2" x="2">&lt;c2&gt;</bpt>todo<ept i="2">&lt;/c2&gt;</ept> component via <bpt i="3" x="3">&lt;c3&gt;</bpt>m.mount<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041650Z" creationid="shibukawa.yoshiki" creationdate="20150502T041650Z">
        <seg>しかし、前に説明したとおり、<bpt i="3" x="3">&lt;c3&gt;</bpt>m.mount<ept i="3">&lt;/c3&gt;</ept>を通じて<bpt i="2" x="2">&lt;c2&gt;</bpt>todo<ept i="2">&lt;/c2&gt;</ept>コンポーネントを初期化すると、<bpt i="1" x="1">&lt;a1&gt;</bpt>自動再描画システム<ept i="1">&lt;/a1&gt;</ept>が有効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, as the performance tests in the homepage show, this does not necessarily hurt Mithril in a meaningful way.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015016Z" creationid="shibukawa.yoshiki" creationdate="20150420T015016Z">
        <seg>しかし、ホームページのパフォーマンス比較が示す通り、Mithrilではこの両方を達成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, bindings can be implemented easily:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014119Z" creationid="shibukawa.yoshiki" creationdate="20150413T014119Z">
        <seg>しかし、簡単に実現できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it's important to always write conditional tests in templates to account for the possibility of nullables, because redraws may come to occur more aggressively than data is available (perhaps because a newly introduced 3rd party library calls <bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw<ept i="0">&lt;/c0&gt;</ept>, or because you might want a more aggressive redraw policy to implement a specific feature down the road).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T120834Z" creationid="shibukawa.yoshiki" creationdate="20150502T120834Z">
        <seg>しかし、テンプレート内でnullになりえる可能性がある場合は常にチェックコードを書くことが大切です。新しく導入したサードパーティライブラリが<bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw<ept i="0">&lt;/c0&gt;</ept>を呼び出す可能性がありますし、何かしらの機能を実装する時に積極的な再描画を行う必要が出てくる可能性があるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it's recommended that you aggregate all of your requests in a single place instead of scattering them across multiple components.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084713Z" creationid="shibukawa.yoshiki" creationdate="20150502T084713Z">
        <seg>しかし、複数のコンポーネントに散らばっている複数のリクエストは一箇所にあつめるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, sometimes we do want to be able to redraw before a web service request completes, either because one web service out of many is slow, or because we don't need its response in order to redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T000147Z" creationid="shibukawa.yoshiki" creationdate="20150415T000147Z">
        <seg>しかし、時々ウェブサービスのリクエストが完了する前に再描画を行いたいと思うことがあります。多くのウェブサービスに並行でアクセスして、アクセスが遅いのがその中の１つだけだったり、もしくは再描画するのにレスポンスがいらない、といったこともありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, this mode does not support named anchors and browser history lists.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005228Z" creationid="shibukawa.yoshiki" creationdate="20150410T005228Z">
        <seg>しかし、このモードでは名前付きアンカーが使えなくなりますし、ブラウザの履歴のリストがサポートされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, this mode does not support named anchors.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170041Z" creationid="shibukawa.yoshiki" creationdate="20150414T170041Z">
        <seg>しかし、このモードでは名前付きアンカーが使えなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, using <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.render<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> is only recommended if you want to use Mithril as part of a larger framework that manages the rendering lifecycle on its own.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100251Z" creationid="shibukawa.yoshiki" creationdate="20150502T100218Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.render<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を使用するのは、他のフレームワークを利用していて、描画の管理はそのシステムに従う場合にのみにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, using its entire toolset idiomatically can bring lots of benefits: learning to use functional programming in real world scenarios and solidifying good coding practices for OOP and MVC are just some of them.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142406Z" creationid="shibukawa.yoshiki" creationdate="20150407T142253Z">
        <seg>しかし、このツールセットのレールに乗ることで多くの利益を得ることができます。その中には、実用的なシナリオ上で関数型プログラミングを学んだり、しっかりとしたオブジェクト指向プログラミングやMVCの良いコーディングプラクティスを学ぶことも含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hybrid architecture</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180200Z" creationid="shibukawa.yoshiki" creationdate="20150501T180200Z">
        <seg>ハイブリッドアーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>IE also allows running of Javascript via CSS behaviors in <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;link&gt;<ept i="0">&lt;/c0&gt;</ept>/<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;style&gt;<ept i="1">&lt;/c1&gt;</ept> tags and <bpt i="2" x="2">&lt;c2&gt;</bpt>style<ept i="2">&lt;/c2&gt;</ept> attributes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014743Z" creationid="shibukawa.yoshiki" creationdate="20150416T014743Z">
        <seg>IEはCSSの処理の中でのJavaScriptの実行を認めています。<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;link&gt;<ept i="0">&lt;/c0&gt;</ept>/<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;style&gt;<ept i="1">&lt;/c1&gt;</ept> タグと、<bpt i="2" x="2">&lt;c2&gt;</bpt>style<ept i="2">&lt;/c2&gt;</ept>属性です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>IE7 and lower do not support cross-domain AJAX requests.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015040Z" creationid="shibukawa.yoshiki" creationdate="20150417T015040Z">
        <seg>IE7以下のブラウザは、クロスドメインのAJAXリクエストをサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Ideally, temperature conversion functions (and any functions that deal strictly within the domain of the data) should go in the model layer, not in a component's controller.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081933Z" creationid="shibukawa.yoshiki" creationdate="20150502T081933Z">
        <seg>理想的には温度変換処理や、データの領域で行われるその他の処理はコンポーネントのコントローラではなく、モデルレイヤーに移動すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Idiomatic Mithril code is meant to apply good programming conventions and be easy to refactor.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T234007Z" creationid="shibukawa.yoshiki" creationdate="20150408T234007Z">
        <seg>Mithril風のコードとは、良いプログラミングの規約に従っていて、リファクタリングしやすいコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a component A contains another component B that calls asynchronous services, when component A is rendered, a <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;placeholder&gt;<ept i="0">&lt;/c0&gt;</ept> tag is rendered in place of component B until B's asynchronous services resolve.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094529Z" creationid="shibukawa.yoshiki" creationdate="20150502T094529Z">
        <seg>もし、コンポーネントAが、非同期処理を行う他のコンポーネントBを含んでいて、Bの非同期タスクが完了する前であれば、描画時に&lt;placeholder&gt;<it pos="end" x="0">&lt;/c0&gt;</it>タグがレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a component's controller contains the function <bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept>, it will be called under one of these circumstances:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090938Z" creationid="shibukawa.yoshiki" creationdate="20150502T090938Z">
        <seg>コンポーネントのコントローラが<bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept>関数を持っていた場合は、以下の状況のどれかに当てはまった時に呼ばれます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a component's controller implements an instance method called <bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept>, this method will be called when a route changes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135316Z" creationid="shibukawa.yoshiki" creationdate="20150502T135310Z">
        <seg>コンポーネントのコントローラが<bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept>インスタンスメソッドを定義している場合、ラウトが変更されるとこのメソッドが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a component's root element is a subtree directive on its first rendering pass, undefined behavior will occur.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100058Z" creationid="shibukawa.yoshiki" creationdate="20150502T100058Z">
        <seg>初回レンダリング時に、コンポーネントのルートのエレメントがサブツリーディレクティブを返した場合は未定義の動作になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a contoller is not specified, Mithril will automatically create an empty controller function.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100517Z" creationid="shibukawa.yoshiki" creationdate="20150502T100517Z">
        <seg>もしコントローラが指定されなければ、Mithrilは自動的に空のコントローラ関数を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a promise is passed into <bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop()<ept i="0">&lt;/c0&gt;</ept>, a Mithril promise is returned.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135230Z" creationid="shibukawa.yoshiki" creationdate="20150414T135230Z">
        <seg>promiseが<bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop()<ept i="0">&lt;/c0&gt;</ept>Mithrilのpromiseが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an attribute has the same name in Javascript and in HTML, then Mithril assumes you're setting the Javascript property.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T012442Z" creationid="shibukawa.yoshiki" creationdate="20150413T012442Z">
        <seg>JavaScriptとHTMLで同じ名前の属性があった場合は、MithrilはJavaScript側の属性を優先します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If calls are more expensive than a repaint window, the browser may drop frames, resulting in choppy animations.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020504Z" creationid="shibukawa.yoshiki" creationdate="20150421T020504Z">
        <seg>もし、このメソッドの呼び出しコストがウィンドウの再描画よりも重くなると、フレーム落ちが発生して、アニメーションがなめらかに実行されなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If doing such operations, the final string needs to be flagged as trusted.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015721Z" creationid="shibukawa.yoshiki" creationdate="20150416T015721Z">
        <seg>このような操作を行う場合には、最終的な文字列に対してこの関数を呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it's a SubtreeDirective with the value "retain", it will retain the existing DOM tree in place, if any.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160432Z" creationid="shibukawa.yoshiki" creationdate="20150413T160432Z">
        <seg>SubtreeDirectiveの値が"retain"だった場合は、もしあれば既存のDOMツリーをその場で保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it's a VirtualElement, it will be rendered as a DOM Element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155613Z" creationid="shibukawa.yoshiki" creationdate="20150413T155613Z">
        <seg>もし仮想エレメントが指定された場合には、DOMエレメントとしてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it's a list, its contents will recursively be rendered as appropriate and appended as children of the <bpt i="0" x="0">&lt;c0&gt;</bpt>root<ept i="0">&lt;/c0&gt;</ept> element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124825Z" creationid="shibukawa.yoshiki" creationdate="20150416T124825Z">
        <seg>配列だった場合には、配列の要素も再帰的にレンダリングされて、<bpt i="0" x="0">&lt;c0&gt;</bpt>root<ept i="0">&lt;/c0&gt;</ept>エレメントの子供として追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it's a list, its contents will recursively be rendered as appropriate and appended as children of the element being created.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160227Z" creationid="shibukawa.yoshiki" creationdate="20150413T160227Z">
        <seg>配列だった場合には、配列の要素も再帰的にレンダリングされて、生成されたエレメントの子供として追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If not provided, return the current internally stored value.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135923Z" creationid="shibukawa.yoshiki" creationdate="20150414T135923Z">
        <seg>もし渡されなければ、現在の内部ストアの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If not provided, the value of the getter-setter's internal store defaults to <bpt i="0" x="0">&lt;c0&gt;</bpt>undefined<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135745Z" creationid="shibukawa.yoshiki" creationdate="20150414T135745Z">
        <seg>もし初期値が与えられなければ、getter-setterの内部ストアのデフォルト値は<bpt i="0" x="0">&lt;c0&gt;</bpt>undefined<ept i="0">&lt;/c0&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If provided, it updates the getter-setter's internal store to the provided value.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135908Z" creationid="shibukawa.yoshiki" creationdate="20150414T135908Z">
        <seg>もし引数が渡された場合には、getter-setterの内部ストアの値を、渡された値に更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If set to true, forces the redraw to be synchronous.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151738Z" creationid="shibukawa.yoshiki" creationdate="20150416T151738Z">
        <seg>もしこれがtrueに設定されると、同期的に再描画を行う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If set to true, rendering a new virtual tree will completely overwrite an existing one without attempting to diff against it</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124954Z" creationid="shibukawa.yoshiki" creationdate="20150416T124954Z">
        <seg>もしこれがtrueに設定されると、差分検知せずに新しい仮想ツリーの完全なレンダリングが行われます。st it</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If set to true, replaces the current history entry, instead of adding a new one.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171606Z" creationid="shibukawa.yoshiki" creationdate="20150414T171606Z">
        <seg>もしこのパラメータがtrueに設定されると、新しいページを追加するのではなく、現在のヒストリのエントリーを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>context<ept i="0">&lt;/c0&gt;</ept> object that is passed to a <bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept> function has a property called <bpt i="2" x="2">&lt;c2&gt;</bpt>onunload<ept i="2">&lt;/c2&gt;</ept>, this function will be called when the element gets detached from the document by Mithril's diff engine.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130246Z" creationid="shibukawa.yoshiki" creationdate="20150413T130246Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept>関数に渡される<bpt i="0" x="0">&lt;c0&gt;</bpt>context<ept i="0">&lt;/c0&gt;</ept>オブジェクトには、<bpt i="2" x="2">&lt;c2&gt;</bpt>onunload<ept i="2">&lt;/c2&gt;</ept>と呼ばれるプロパティがあります。この関数は、Mithirilの差分検出エンジンによって対象のエレメントがドキュメントから切り離される時に呼ばされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the URL is not in the same domain as the application, the target server must be configured to accept cross-domain requests from the application's domain, i.e. its responses must include the header <bpt i="0" x="0">&lt;c0&gt;</bpt>Access-Control-Allow-Origin: *<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002310Z" creationid="shibukawa.yoshiki" creationdate="20150415T002310Z">
        <seg>もしURLが違うドメインであれば、対象となるサーバは <bpt i="0" x="0">&lt;c0&gt;</bpt>Access-Control-Allow-Origin: *<ept i="0">&lt;/c0&gt;</ept>ヘッダを付与するなど、クロスドメインのリクエストを許可する設定になっている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the controller doesn't already have a success callback to run after a request resolves, you can still bind errors like this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125324Z" creationid="shibukawa.yoshiki" creationdate="20150410T125324Z">
        <seg>もしコントローラが、サーバアクセスが成功した時に実行すべき処理がない場合でも、次のように書くことでエラー処理のバインドが行えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the current page URL matches a route, its respective component is activated.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135805Z" creationid="shibukawa.yoshiki" creationdate="20150502T135805Z">
        <seg>現在のページのURLが、設定されたラウトにマッチした場合には、対応するコンポーネントがアクティブになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the currently active route is <bpt i="0" x="0">&lt;c0&gt;</bpt>/dashboard/:userID<ept i="0">&lt;/c0&gt;</ept> and the current URL is <bpt i="1" x="1">&lt;c1&gt;</bpt>/dashboard/johndoe<ept i="1">&lt;/c1&gt;</ept>, then calling <bpt i="2" x="2">&lt;c2&gt;</bpt>m.route.param("userID")<ept i="2">&lt;/c2&gt;</ept> returns <bpt i="3" x="3">&lt;c3&gt;</bpt>"johndoe"<ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170711Z" creationid="shibukawa.yoshiki" creationdate="20150414T170711Z">
        <seg>もし、現在アクティブなラウトが<bpt i="0" x="0">&lt;c0&gt;</bpt>/dashboard/:userID<ept i="0">&lt;/c0&gt;</ept>で、現在のURLが<bpt i="1" x="1">&lt;c1&gt;</bpt>/dashboard/johndoe<ept i="1">&lt;/c1&gt;</ept>だとすると、<bpt i="2" x="2">&lt;c2&gt;</bpt>m.route.param("userID")<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>"johndoe"<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the method is run more than once with the same root element, it diffs the new tree against the existing one and intelligently modifies only the portions that have changed.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T020105Z" creationid="shibukawa.yoshiki" creationdate="20150416T020105Z">
        <seg>もしこのメソッドが、同じルートエレメントに対して2回以上呼ばれた場合には、このメソッドは新しいツリーと既存のツリーの差分を取り、変更のあった箇所だけ賢く更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the tag selector is omitted, it defaults to <bpt i="0" x="0">&lt;c0&gt;</bpt>div<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150640Z" creationid="shibukawa.yoshiki" creationdate="20150413T150640Z">
        <seg>もしタグセレクタが省略されると、<bpt i="0" x="0">&lt;c0&gt;</bpt>div<ept i="0">&lt;/c0&gt;</ept>がデフォルトで設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this argument is a string, it will be rendered as a text node.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155516Z" creationid="shibukawa.yoshiki" creationdate="20150413T155516Z">
        <seg>この属性が文字列の場合は、テキストノードとしてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this function returns undefined, then it passes the <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> argument to the next step in the thennable queue, if any</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175859Z" creationid="shibukawa.yoshiki" creationdate="20150415T175859Z">
        <seg>もしこの関数がundefinedを返してきたら、値がどんなでものであろうと、<bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>引数がthennableキューの次のキューに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this option is set to true, then the request does NOT call <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> / <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept> internally, and therefore the completion of the request does not trigger an update of the view, even if data has been changed.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134319Z" creationid="shibukawa.yoshiki" creationdate="20150502T134319Z">
        <seg>このオプションがtrueであれば、requestメソッドは<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> / <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を呼びません。そのため、リクエストの完了がビュー更新のトリガーにはならず、データ更新があってもビューが更新されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this parameter is falsy, the default value is a function that returns <bpt i="0" x="0">&lt;c0&gt;</bpt>xhr.responseText<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013502Z" creationid="shibukawa.yoshiki" creationdate="20150415T013502Z">
        <seg>この設定がfalsyな値だったときのデフォルトの動作は、<bpt i="0" x="0">&lt;c0&gt;</bpt>xhr.responseText<ept i="0">&lt;/c0&gt;</ept>を返す関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this parameter is falsy, the deserialized data will not be wrapped.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013825Z" creationid="shibukawa.yoshiki" creationdate="20150415T013825Z">
        <seg>もしこのパラメータがfalxyな値だった時は、デシリアライズされたデータはそのまま渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you already have your HTML written and want to convert it into a Mithril template, you can use the tool below for one-off manual conversion.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013549Z" creationid="shibukawa.yoshiki" creationdate="20150417T013549Z">
        <seg>もしすでにHTMLを作成済みで、それをMithirlのテンプレートに変換したい場合は、一度だけマニュアルの変換しかできませんが、下記のツールを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are developing an asynchronous model-level service and finding that Mithril is not redrawing the view after your code runs, you should consider using <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept> to integrate with Mithril's auto-redrawing system instead.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130208Z" creationid="shibukawa.yoshiki" creationdate="20150502T130208Z">
        <seg>もし非同期のモデルレベルのサービスを開発しているとします。コードが実行されていても、Mithrilがビューを更新しないことに気づきました。この場合は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を呼んで、Mithrilの自動再描画システムと統合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you call this method more often than that, Mithril may ignore calls or defer them to the next browser repaint cycle.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020407Z" creationid="shibukawa.yoshiki" creationdate="20150421T020407Z">
        <seg>もしこれよりも早いペースで呼び出すと、Mithrilは関数呼び出しを無視して、次のブラウザの再描画のサイクルまで実行を遅らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you do use it, you are responsible for determining what constitutes a scenario where the virtual DOM tree is changed/unchanged.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124157Z" creationid="shibukawa.yoshiki" creationdate="20150416T124157Z">
        <seg>この機能を使う場合は、仮想DOMツリーのどこに変更があったか/なかったかについて、開発者が決定する責任を持つことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you find yourself needing to redraw before the browsers normal redraw cycle, you can force a synchronous redraw by passing a boolean <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> as a parameter to <bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151336Z" creationid="shibukawa.yoshiki" creationdate="20150416T151336Z">
        <seg>もしブラウザの通常の再描画サイクルよりも前に再描画を行わせたい場合は、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw<ept i="1">&lt;/c1&gt;</ept>のオプションとして<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を渡すと、強制的に同期再描画を行わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you have a hierarchy of components, you can recursively call <bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept> on all the components in the tree or use a <bpt i="1" x="1">&lt;a1&gt;</bpt>pubsub<ept i="1">&lt;/a1&gt;</ept> library to unload specific components on demand.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T020118Z" creationid="shibukawa.yoshiki" creationdate="20150414T020118Z">
        <seg>コンポーネントが階層化されている場合は、階層の中のモジュールのすべての<bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept>を呼ぶこともできますし、特定のコンポーネントをアンロードするときには<bpt i="1" x="1">&lt;a1&gt;</bpt>pubsub<ept i="1">&lt;/a1&gt;</ept>ライブラリを呼ぶこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you have components inside a sortable list, you should add <bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept> attributes to your components to ensure that DOM elements are not recreated from scratch, but merely moved when possible.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080315Z" creationid="shibukawa.yoshiki" creationdate="20150502T080315Z">
        <seg>もしソート可能なリストの中にコンポーネントを置く場合には、<bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept> 属性をコンポーネントに追加して、単なる移動時にDOM要素が再生成されないようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to add separate widgets to different places on a same page, you can simply initialize each widget as you would a regular Mithril application (i.e. use <bpt i="0" x="0">&lt;c0&gt;</bpt>m.render<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>m.route<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045357Z" creationid="shibukawa.yoshiki" creationdate="20150502T045357Z">
        <seg>もし、個別のウィジェットを同じページ内の異なる場所に置きたい場合には、通常のMithrilアプリケーションと同じように、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.render<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>m.route<ept i="2">&lt;/c2&gt;</ept>などを使ってそれぞれのウィジェットを初期化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to change how Mithril performs a redraw, you can change the value of the <bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw.strategy<ept i="0">&lt;/c0&gt;</ept> getter-setter to either <bpt i="1" x="1">&lt;c1&gt;</bpt>"all"<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>"diff"<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>"none"<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T130801Z" creationid="shibukawa.yoshiki" creationdate="20150416T130801Z">
        <seg>Mithrilの再描画の実行パターンを変更する必要があれば、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw.strategy<ept i="0">&lt;/c0&gt;</ept> getter-setterを、<bpt i="1" x="1">&lt;c1&gt;</bpt>"all"<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>"diff"<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>"none"<ept i="3">&lt;/c3&gt;</ept>のどれかに設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to do custom asynchronous calls without using Mithril's API, and find that your views are not redrawing automatically, you should consider using <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> so that Mithril can intelligently auto-redraw once your custom code finishes running.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000610Z" creationid="shibukawa.yoshiki" creationdate="20150506T000610Z">
        <seg>MithrilのAPIを使わないで、カスタムの非同期呼び出しを行った時に、ビューが更新されていない時は、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を使用することを検討してください。カスタムコードの処理が終わった時にMithrilが賢く自動再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to do custom asynchronous calls without using Mithril's API, and find that your views are not redrawing, you should consider using <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> so that Mithril can intelligently auto-redraw once your custom code finishes running.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T113931Z" creationid="shibukawa.yoshiki" creationdate="20150502T113931Z">
        <seg>MithrilのAPIを使わないで、カスタムの非同期呼び出しを行った時に、ビューが更新されていない時は、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を使用することを検討してください。カスタムコードの処理が終わった時にMithrilが賢く自動再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to persist DOM state across route changes, it's recommended that you use the <bpt i="2" x="2">&lt;c2&gt;</bpt>ctx.retain<ept i="2">&lt;/c2&gt;</ept> flag instead of <bpt i="3" x="3">&lt;c3&gt;</bpt>m.redraw.strategy("diff")<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T133349Z" creationid="shibukawa.yoshiki" creationdate="20150502T133349Z">
        <seg>ラウト間でDOMの状態を維持する必要があるときは、<bpt i="3" x="3">&lt;c3&gt;</bpt>m.redraw.strategy("diff")<ept i="3">&lt;/c3&gt;</ept>ではなく、<bpt i="2" x="2">&lt;c2&gt;</bpt>ctx.retain<ept i="2">&lt;/c2&gt;</ept>フラグを使うのが推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to read DOM values, try to read them all at once, because alternating reading and writing to the DOM causes multiple browser repaints, and repaints are expensive.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151714Z" creationid="shibukawa.yoshiki" creationdate="20150416T151714Z">
        <seg>もしDOMの値を読む必要が出てきた場合は、すべての必要なDOMの値を一度に読むようにしてください。少しずつ読み書きすると、高価なブラウザの再描画が何度も発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to sort lists, or delete items from them, or splice them in any way, you should <bpt i="0" x="0">&lt;a0&gt;</bpt>use the <bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept> attribute<ept i="0">&lt;/a0&gt;</ept> to maintain referential integrity between the data and the DOM.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020944Z" creationid="shibukawa.yoshiki" creationdate="20150421T020944Z">
        <seg>リストをソートしたり、リストから要素を削除する場合や、スプライスを行う場合は、データとDOM間の参照を維持するために、 <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept>属性を使用してください<ept i="0">&lt;/a0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you see an alert box, ensuring security with that framework is more work for you.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135415Z" creationid="shibukawa.yoshiki" creationdate="20150407T135415Z">
        <seg>もしアラートボックスが表示された場合には、そのフレームワーク上ではセキュリティを維持するための仕事がたくさんあるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you set strategy to <bpt i="0" x="0">&lt;c0&gt;</bpt>"none"<ept i="0">&lt;/c0&gt;</ept> but then proceed to trigger a redraw asynchronously, either via <bpt i="1" x="1">&lt;c1&gt;</bpt>start/endComputation<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>m.redraw<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>m.request<ept i="3">&lt;/c3&gt;</ept>, a redraw <bpt i="4" x="4">&lt;e4&gt;</bpt>will<ept i="4">&lt;/e4&gt;</ept> occur, using the <bpt i="5" x="5">&lt;c5&gt;</bpt>"diff"<ept i="5">&lt;/c5&gt;</ept> strategy.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152806Z" creationid="shibukawa.yoshiki" creationdate="20150416T150752Z">
        <seg>このメソッドを使って<bpt i="0" x="0">&lt;c0&gt;</bpt>"none"<ept i="0">&lt;/c0&gt;</ept>に設定したにもかかわらず、<bpt i="1" x="1">&lt;c1&gt;</bpt>start/endComputation<ept i="1">&lt;/c1&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>m.redraw<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>m.request<ept i="3">&lt;/c3&gt;</ept>によって非同期での再描画のトリガーが引かれた場合は、 <bpt i="5" x="5">&lt;c5&gt;</bpt>"diff"<ept i="5">&lt;/c5&gt;</ept> 戦略で再描画が<bpt i="4" x="4">&lt;e4&gt;</bpt>先のフレーム<ept i="4">&lt;/e4&gt;</ept>で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to a recurring callback (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>setInterval<ept i="0">&lt;/c0&gt;</ept> or a web socket event handler) to trigger redraws, you should call <bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> at the beginning of the function, not outside of it.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T175327Z" creationid="shibukawa.yoshiki" creationdate="20150501T175327Z">
        <seg>もし、<bpt i="0" x="0">&lt;c0&gt;</bpt>setInterval<ept i="0">&lt;/c0&gt;</ept>やウェブソケットのイベントハンドラなど、繰り返し呼ばれるコールバックから再描画を行わせたい場合は、コールバックの外ではなく、コールバック関数の先頭で<bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept>を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to automate compilation, you can use <bpt i="0" x="0">&lt;a0&gt;</bpt>GruntJS<ept i="0">&lt;/a0&gt;</ept>, a task automation tool.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150401Z" creationid="shibukawa.yoshiki" creationdate="20150412T150401Z">
        <seg>テンプレートを自動コンパイルするには、タスク自動化ツールの<bpt i="0" x="0">&lt;a0&gt;</bpt>GruntJS<ept i="0">&lt;/a0&gt;</ept>を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to be able to handle a condition as an error in a promise rejection handler, you can throw an <bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept> from <bpt i="1" x="1">&lt;c1&gt;</bpt>extract<ept i="1">&lt;/c1&gt;</ept> to reject the promise.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181142Z" creationid="shibukawa.yoshiki" creationdate="20150414T181142Z">
        <seg>もし、promiseのリジェクトハンドラ内でエラー条件のハンドリングを行いたい場合は、<bpt i="1" x="1">&lt;c1&gt;</bpt>extract<ept i="1">&lt;/c1&gt;</ept>の中から、promiseのリジェクトに向けて<bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept>を投げることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to keep a DOM element intact across a route change, you can set the <bpt i="1" x="1">&lt;c1&gt;</bpt>retain<ept i="1">&lt;/c1&gt;</ept> flag in the config's context object.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130751Z" creationid="shibukawa.yoshiki" creationdate="20150413T130751Z">
        <seg>もし、ラウトの変更前後で、DOMエレメントを破棄せずに残しておきたい場合には、configのコンテキストオブジェクト内の<bpt i="1" x="1">&lt;c1&gt;</bpt>retain<ept i="1">&lt;/c1&gt;</ept>フラグを設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to repeatedly redraw the view without necessarily waiting for user input, you should manually call <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.redraw<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> within the repeatable context.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193557Z" creationid="shibukawa.yoshiki" creationdate="20150411T193557Z">
        <seg>もし、ユーザの入力を待つことなく、繰り返し再描画を行いたい場合は、繰り返し可能なコンテキストの中で、手動で<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.redraw<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to use the bleeding edge version, you can <bpt i="0" x="0">&lt;a0&gt;</bpt>fork the development repository<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000353Z" creationid="shibukawa.yoshiki" creationdate="20150408T000353Z">
        <seg>もし、最先端のバージョンを使いたいのであれば、<bpt i="0" x="0">&lt;a0&gt;</bpt>開発版のリポジトリをフォーク<ept i="0">&lt;/a0&gt;</ept>することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you wish to support IE6, you'll need <bpt i="0" x="0">&lt;a0&gt;</bpt>a shim for it<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015011Z" creationid="shibukawa.yoshiki" creationdate="20150417T015011Z">
        <seg>もしIE6をサポートするには、そのクラスの<bpt i="0" x="0">&lt;a0&gt;</bpt>シミュレートコード<ept i="0">&lt;/a0&gt;</ept>が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you wish to use third party asynchronous libraries (for example, <bpt i="0" x="0">&lt;c0&gt;</bpt>jQuery.ajax<ept i="0">&lt;/c0&gt;</ept>), you should also consider using <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept> / <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept><ept i="1">&lt;/a1&gt;</ept> if you want views to redraw after requests complete.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135033Z" creationid="shibukawa.yoshiki" creationdate="20150415T135033Z">
        <seg>もし、<bpt i="0" x="0">&lt;c0&gt;</bpt>jQuery.ajax<ept i="0">&lt;/c0&gt;</ept>)などのサードパーティの非同期ライブラリと一緒に使って、リクエストの完了時に再描画をさせたい時は<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept> / <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept><ept i="1">&lt;/a1&gt;</ept>を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're integrating other non-recurring services (e.g. calling setTimeout), you should use <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> / <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020049Z" creationid="shibukawa.yoshiki" creationdate="20150421T020049Z">
        <seg>setTimeoutなどの、繰り返し行われないサービスと統合する場合は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> / <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept>の方が推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're interested in helping improve Mithril, you're welcome to use the bleeding edge version and report any bugs that you find.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000614Z" creationid="shibukawa.yoshiki" creationdate="20150408T000614Z">
        <seg>もし、Mithrilを改善することに興味があるのであれば、最先端バージョンを使用して、見つけたバグを報告してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're not familiar with GruntJS, you can find a tutorial on their website.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150430Z" creationid="shibukawa.yoshiki" creationdate="20150412T150430Z">
        <seg>もしGruntJSについて馴染みがなければ、GruntJSのウェブサイト上にチュートリアルがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're using NodeJS already or planning on using <bpt i="1" x="1">&lt;a1&gt;</bpt>Grunt<ept i="1">&lt;/a1&gt;</ept> to create a build system, you can use NPM to conveniently keep up-to-date with Mithril versions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165958Z" creationid="shibukawa.yoshiki" creationdate="20150407T165842Z">
        <seg>もしすでにNodeJSを使っていていたり、<bpt i="1" x="1">&lt;a1&gt;</bpt>Grunt<ept i="1">&lt;/a1&gt;</ept>を使ったビルドシステムを作ろうとしているのであれば、NPMを使うとMithrilを最新に保つのが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're using NodeJS already or planning on using <bpt i="2" x="2">&lt;a2&gt;</bpt>Grunt<ept i="2">&lt;/a2&gt;</ept> to create a build system, you can use Bower to conveniently keep up-to-date with Mithril versions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235636Z" creationid="shibukawa.yoshiki" creationdate="20150407T235056Z">
        <seg>もしすでにNodeJSを使っていていたり、<bpt i="2" x="2">&lt;a2&gt;</bpt>Grunt<ept i="2">&lt;/a2&gt;</ept>を使ったビルドシステムを作ろうとしているのであれば、Bowerを使うとMithrilを最新に保つのが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're using NodeJS already or planning on using <bpt i="2" x="2">&lt;a2&gt;</bpt>Grunt<ept i="2">&lt;/a2&gt;</ept> to create a build system, you can use Component to conveniently keep up-to-date with Mithril versions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T235953Z" creationid="shibukawa.yoshiki" creationdate="20150407T235932Z">
        <seg>もしすでにNodeJSを使っていていたり、<bpt i="2" x="2">&lt;a2&gt;</bpt>Grunt<ept i="2">&lt;/a2&gt;</ept>を使ったビルドシステムを作ろうとしているのであれば、Componentを使うとMithrilを最新に保つのが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you're writing a template for a view, use <bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013520Z" creationid="shibukawa.yoshiki" creationdate="20150416T013520Z">
        <seg>もしビューのためにテンプレートを作成しているのであれば、<bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept>を代わりに使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you've been interested in learning or using Functional Programming in the real world, Mithril provides very pragmatic opportunities to get into it.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015625Z" creationid="shibukawa.yoshiki" creationdate="20150409T015613Z">
        <seg>もし関数型プログラミングを学習したり、実世界で使ってみたいと考えているのであれば、Mithrilがとても実践的な場を提供してくれるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Apache, this URL rewriting can be achieved using <bpt i="0" x="0">&lt;a0&gt;</bpt>mod_rewrite<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012855Z" creationid="shibukawa.yoshiki" creationdate="20150410T012855Z">
        <seg>Apacheを使っている場合は、<bpt i="0" x="0">&lt;a0&gt;</bpt>mod_rewrite<ept i="0">&lt;/a0&gt;</ept>を使用してURLの書き換えを行うことでできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Apache, this URL rewriting can be achieved using ModRewrite.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170200Z" creationid="shibukawa.yoshiki" creationdate="20150414T170200Z">
        <seg>Apacheを使っている場合は、mod_rewriteを使用してURLの書き換えを行うことでできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Mithril, UI state is understood to be model data, even though it doesn't necessarily map to a database ORM entity.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152904Z" creationid="shibukawa.yoshiki" creationdate="20150407T152904Z">
        <seg>Mithrilでは、UIの状態というのはデータベースのORMエンティティにマップされる必要はないが、モデルデータとなるべきもの、と考えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Mithril, a <bpt i="0" x="0">&lt;e0&gt;</bpt>component<ept i="0">&lt;/e0&gt;</ept> is an object that contains two functions: <bpt i="1" x="1">&lt;c1&gt;</bpt>controller<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>view<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040244Z" creationid="shibukawa.yoshiki" creationdate="20150502T040244Z">
        <seg>Mithrilでは、<bpt i="0" x="0">&lt;e0&gt;</bpt>コンポーネント<ept i="0">&lt;/e0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>controller<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>view<ept i="2">&lt;/c2&gt;</ept>の2つの関数を含むオブジェクトです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Mithril, a component is nothing more than an object that has a <bpt i="0" x="0">&lt;c0&gt;</bpt>view<ept i="0">&lt;/c0&gt;</ept> function and, optionally, a <bpt i="1" x="1">&lt;c1&gt;</bpt>controller<ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061341Z" creationid="shibukawa.yoshiki" creationdate="20150502T061341Z">
        <seg>Mithrilのコンポーネントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>view<ept i="0">&lt;/c0&gt;</ept>関数と、オプションの<bpt i="1" x="1">&lt;c1&gt;</bpt>controller<ept i="1">&lt;/c1&gt;</ept>関数を持つ以外のルールはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Mithril, an application typically lives in a namespace and contains components.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040153Z" creationid="shibukawa.yoshiki" creationdate="20150502T040153Z">
        <seg>Mithrilでは基本的に、アプリケーションは名前空間の中に作り、コンポーネントをその中に格納していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Mithril, views are plain Javascript.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040855Z" creationid="shibukawa.yoshiki" creationdate="20150502T040855Z">
        <seg>MithrilではビューはプレーンなJavaScriptコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a command line, type:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150201Z" creationid="shibukawa.yoshiki" creationdate="20150412T150201Z">
        <seg>コマンドラインで次のようにタイプします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to being aware of data availability when deciding to redraw, Mithril is also aware of browser availability: if several redraws are triggered in a short amount of time, Mithril batches them so that at most only one redraw happens within a single animation frame (around 16ms).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T191406Z" creationid="shibukawa.yoshiki" creationdate="20150411T191406Z">
        <seg>このように、再描画の決定にデータの可用性を判断基準にしていますが、これ以外にも、ブラウザの可用性についても考慮しています。もし、短時間で何度も再描画が行われようとしている場合には、Mithrilはこれらの再描画をまとめて、単一のアニメーションフレーム(16ミリ秒)に最大1回のみ再描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to bi-directional data binding, we can also bind parameterized functions to events:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151223Z" creationid="shibukawa.yoshiki" creationdate="20150408T151223Z">
        <seg>双方向バインディング以外の機能では、パラメータ付き関数をイベントにバインドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to holding a controller and a view, a component can also be used to store data that pertains to it.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040327Z" creationid="shibukawa.yoshiki" creationdate="20150502T040327Z">
        <seg>コンポーネントはコントローラとビューを保持するだけではなく、関連するデータを格納するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to route parameters, it's possible to pass arbitrary data to <bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.param<ept i="0">&lt;/c0&gt;</ept> using the querystring</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T154349Z" creationid="shibukawa.yoshiki" creationdate="20150414T154349Z">
        <seg>ラウトパラメータ以外にも、クエリー文字列を使って任意のデータを<bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.param<ept i="0">&lt;/c0&gt;</ept>に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to the <bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>view<ept i="1">&lt;/c1&gt;</ept> properties that make the <bpt i="2" x="2">&lt;c2&gt;</bpt>Uploader<ept i="2">&lt;/c2&gt;</ept> object usable as a component, it also has an <bpt i="3" x="3">&lt;c3&gt;</bpt>upload<ept i="3">&lt;/c3&gt;</ept> convenience function that provides a basic upload model method, and a <bpt i="4" x="4">&lt;c4&gt;</bpt>serialize<ept i="4">&lt;/c4&gt;</ept> function that allows files to be serialized as JSON in regular requests encoded as <bpt i="5" x="5">&lt;c5&gt;</bpt>application/x-www-form-urlencoded<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034456Z" creationid="shibukawa.yoshiki" creationdate="20150502T032543Z">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Uploader<ept i="2">&lt;/c2&gt;</ept>オブジェクトをそのままコンポーネントとして使えるように<bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>view<ept i="1">&lt;/c1&gt;</ept>プロパティを提供しています。また、それに追加して基本的なアップロードの機能を提供する<bpt i="3" x="3">&lt;c3&gt;</bpt>upload<ept i="3">&lt;/c3&gt;</ept>関数もモデルのメソッドとして提供しています。また、通常はJSONでシリアライズされるサーバリクエストで、<bpt i="5" x="5">&lt;c5&gt;</bpt>application/x-www-form-urlencoded<ept i="5">&lt;/c5&gt;</ept>エンコードでファイル送信ができるようにする<bpt i="4" x="4">&lt;c4&gt;</bpt>serialize<ept i="4">&lt;/c4&gt;</ept>関数も提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, Mithril attempts to intelligently redraw only when it is appropriate in an application lifecycle.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184427Z" creationid="shibukawa.yoshiki" creationdate="20150411T184427Z">
        <seg>これに加えて、Mithrilはアプリケーションのライフサイクルを考え、適切なタイミングでのみ再描画を実行するようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, an application can be organizationally divided into three major layers: Model, Controller and View.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T145325Z" creationid="shibukawa.yoshiki" creationdate="20150407T144808Z">
        <seg>アプリケーションはModel、Controller、Viewの大きく3つのレイヤーにきれいに分割することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, components can be reused in different contexts.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T005453Z" creationid="shibukawa.yoshiki" creationdate="20150502T005453Z">
        <seg>それに加えて、さまざまなコンテキストでコンポーネントを再利用しやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, having a deeply nested tree of components can result in a lot of intermediate "pass-through" arguments and event handlers.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013517Z" creationid="shibukawa.yoshiki" creationdate="20150502T013517Z">
        <seg>それに加えて、ツリーのネストが深くなると、コンポーネント間の引数のパススルーや、イベントハンドラが増えることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, it stores the unsaved contact entity internally within the component (<bpt i="3" x="3">&lt;c3&gt;</bpt>this.contact = m.prop(args.contact || new Contact())<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002318Z" creationid="shibukawa.yoshiki" creationdate="20150502T002318Z">
        <seg>それに加えて、未保存の連絡先情報をコンポーネント内に保管しています(<bpt i="3" x="3">&lt;c3&gt;</bpt>this.contact = m.prop(args.contact || new Contact())<ept i="3">&lt;/c3&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, it's possible for non-Mithril asynchronous callbacks to trigger auto-redrawing by calling <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> in appropriate places (see below).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T185216Z" creationid="shibukawa.yoshiki" creationdate="20150411T185216Z">
        <seg>これに加えて、Mithril外の非同期のコールバックからも、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept>関数と<bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>関数を適切な場所に配置することで(あとで説明します)、再描画のシステムを起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, note that most <bpt i="0" x="0">&lt;c0&gt;</bpt>m.route<ept i="0">&lt;/c0&gt;</ept> modes rely on <bpt i="1" x="1">&lt;c1&gt;</bpt>history.pushState<ept i="1">&lt;/c1&gt;</ept> in order to allow moving from one page to another without a browser refresh.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015141Z" creationid="shibukawa.yoshiki" creationdate="20150417T015141Z">
        <seg>また、多くの<bpt i="0" x="0">&lt;c0&gt;</bpt>m.route<ept i="0">&lt;/c0&gt;</ept>モードは、ブラウザをリフレッシュしないで他のページにジャンプするために<bpt i="1" x="1">&lt;c1&gt;</bpt>history.pushState<ept i="1">&lt;/c1&gt;</ept>を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, note that template performance, both in Mithril templates as well as in general, is dependent on markup complexity.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020742Z" creationid="shibukawa.yoshiki" creationdate="20150421T020742Z">
        <seg>また、Mithrilだけではなく他のテンプレートにも共通することとして、マークアップの複雑性がテンプレートのパフォーマンスに影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, setting <bpt i="0" x="0">&lt;c0&gt;</bpt>context.retain = false<ept i="0">&lt;/c0&gt;</ept> will also cause the element to be recreated, even if it is not considered different enough.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135454Z" creationid="shibukawa.yoshiki" creationdate="20150413T135435Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>context.retain = false<ept i="0">&lt;/c0&gt;</ept>が設定された場合は、変更が小さくてもエレメントは破棄されて再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, this guide section covers topics related to how to fit all the pieces together.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114636Z" creationid="shibukawa.yoshiki" creationdate="20150417T114636Z">
        <seg>また、ガイドのセクションでは、すべての部品をどのように組み合わせていくかという内容もカバーしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, you cannot call <bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept> from templates.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094829Z" creationid="shibukawa.yoshiki" creationdate="20150502T094829Z">
        <seg>それに加えて、テンプレート内で<bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept>は使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In classic MVC, the role of the controller is to dispatch actions from the view to the model layer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163947Z" creationid="shibukawa.yoshiki" creationdate="20150407T163947Z">
        <seg>クラシカルなMVCでは、ビューからやってきたアクションを、モデルのレイヤーにディスパッチするのがコントローラの役割です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In client-side MVC, however, this dissonance doesn't exist, and controllers can be extremely simple.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T002248Z" creationid="shibukawa.yoshiki" creationdate="20150408T002248Z">
        <seg>クライアントサイドMVCではこのような定義との不一致は存在しないため、コントローラは極めてシンプルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast to layered integration, it minimizes the number of <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> calls to avoid clutter.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010544Z" creationid="shibukawa.yoshiki" creationdate="20150412T010544Z">
        <seg>階層に分けた統合と比べると、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>呼び出しが最小限になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast to layered integration, it minimizes the number of <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> to avoid clutter.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160320Z" creationid="shibukawa.yoshiki" creationdate="20150416T160320Z">
        <seg>階層に分けた統合と比べると、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>呼び出しが最小限になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, <bpt i="2" x="2">&lt;c2&gt;</bpt>m.redraw<ept i="2">&lt;/c2&gt;</ept> is "aggressive": it redraws as many times as it is called (with the caveat that redraws are batched if they occur less than one animation frame apart in time).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114429Z" creationid="shibukawa.yoshiki" creationdate="20150502T114429Z">
        <seg>これとは対照的に<bpt i="2" x="2">&lt;c2&gt;</bpt>m.redraw<ept i="2">&lt;/c2&gt;</ept>は「アグレッシブ」です。このメソッドは、呼ばれた回数だけ再描画を行おうとします(実際には、同一フレーム内の呼び出しはまとめます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, <bpt i="3" x="3">&lt;c3&gt;</bpt>m.redraw<ept i="3">&lt;/c3&gt;</ept> is "aggressive": it redraws as many times as it is called (with the caveat that redraws are batched if they occur less than one animation frame apart in time).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130609Z" creationid="shibukawa.yoshiki" creationdate="20150502T130609Z">
        <seg>これとは対照的に<bpt i="3" x="3">&lt;c3&gt;</bpt>m.redraw<ept i="3">&lt;/c3&gt;</ept>は「アグレッシブ」です。このメソッドは、呼ばれた回数だけ再描画を行おうとします(実際には、同一フレーム内の呼び出しはまとめます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, Mithril avoids "magic" types.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110513Z" creationid="shibukawa.yoshiki" creationdate="20150420T110513Z">
        <seg>Mithrilではこのように「魔法」の型を避ける実装になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, Mithril encourages you to develop applications using the patterns found throughout this guide, and discourages the use of "bastardized" MVC pattern variations.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020610Z" creationid="shibukawa.yoshiki" creationdate="20150420T020610Z">
        <seg>Mithrilはこれとは対照的に、このガイドで示しているようなアプリケーション開発のパターンを共通言語として広めようとしています。それにより、「質の悪いMVCもどきのパターン」が広まるのを防ごうとしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, Mithril separates the two layers more distinctly.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105625Z" creationid="shibukawa.yoshiki" creationdate="20150420T105625Z">
        <seg>それに対して、Mithrilははっきりと2つのレイヤーを分離しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, Mithril is able to render a fully functional application - with working event handlers - before the "DOM ready" event fires!</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013547Z" creationid="shibukawa.yoshiki" creationdate="20150409T013547Z">
        <seg>実際に、Mithrilは完全に機能を持ちイベントハンドラができる状態になってから描画を行います。DOMの準備ができるというイベントが発生する前にです！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, unavoidable abstraction leaks (such as network-bound asynchrony) are laid out in such a way as to make idiomatic code organization elegant, and conversely, to make it so that the abstraction leak problems themselves discourage attempts to misplace entity logic in the controller.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032301Z" creationid="shibukawa.yoshiki" creationdate="20150421T014824Z">
        <seg>抽象化が漏れて、レイヤーを超えてコードが密結合してしまうコードというのはあります。例えばネットワークの非同期性を取り扱う場合にこのようなことがあります。この場合も、エンティティのロジックがコントローラの中に取り残されがちです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, when not using the <bpt i="0" x="0">&lt;a0&gt;</bpt>MSX<ept i="0">&lt;/a0&gt;</ept> HTML syntax preprocessor, it's recommended that you embrace using CSS selectors (e.g. <bpt i="1" x="1">&lt;c1&gt;</bpt>m(".modal-body")<ept i="1">&lt;/c1&gt;</ept>) to really benefit from their inherent semantic expressiveness.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041537Z" creationid="shibukawa.yoshiki" creationdate="20150502T041537Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>MSX<ept i="0">&lt;/a0&gt;</ept>HTML文法プリプロセッサを使っていなくても、本来のセマンティック表現の恩恵を受けられるため、<bpt i="1" x="1">&lt;c1&gt;</bpt>m(".modal-body")<ept i="1">&lt;/c1&gt;</ept>のようなCSSセレクタ形式を使うことを推奨しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In functional programming, this is called <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;e2&gt;</bpt>partial application<ept i="2">&lt;/e2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151412Z" creationid="shibukawa.yoshiki" creationdate="20150408T151412Z">
        <seg>関数型プログラミングの世界では、これは<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;e2&gt;</bpt>部分適用(partial application)<ept i="2">&lt;/e2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In it, the count is stored in the context object and re-accessed on each redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125936Z" creationid="shibukawa.yoshiki" creationdate="20150413T125936Z">
        <seg>このコードの中で、再描画のカウントはコンテキストオブジェクト内に格納されます。このオブジェクトは再描画のたびにアクセスができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In its place, <bpt i="2" x="2">&lt;c2&gt;</bpt>ContactForm<ept i="2">&lt;/c2&gt;</ept> merely emits an action, which is then handled by this model layer observer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031544Z" creationid="shibukawa.yoshiki" creationdate="20150502T031544Z">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>ContactForm<ept i="2">&lt;/c2&gt;</ept>では単に、アクションを送信しています。これはモデルレイヤーのオブザーバが受け取って処理をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In jQuery it's common to use the DOM as a data storage mechanism, whereas Mithril encourages data to exist in an isolated model layer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015734Z" creationid="shibukawa.yoshiki" creationdate="20150420T015734Z">
        <seg>jQueryはDOMをデータ構造のための箱として使いますが、Mithrilはデータをそれと分離したモデルレイヤーに分けようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In many frameworks UI state is typically stored in a controller, but doing so makes the code harder to scale since controllers aren't designed to be data providers.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152609Z" creationid="shibukawa.yoshiki" creationdate="20150407T152609Z">
        <seg>多くのフレームワークでは、UIの状態はコントローラの内部に保持されます。しかし、コントローラはデータプロバイダとしてデザインされていないため、このような構造にしてしまうと、コードをスケールさせるのが難しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In model-level methods if client-side processing is needed to make the data useful for a controller or view</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125646Z" creationid="shibukawa.yoshiki" creationdate="20150410T125646Z">
        <seg>モデルレベルのメソッド内で、コントローラやビューに対して処理しやすい形式のデータへの変換をクライアント側で行わなければならない場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to allow a user to navigate between different pages by loading and unloading components, consider using <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.route<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125327Z" creationid="shibukawa.yoshiki" creationdate="20150502T125327Z">
        <seg>もし、複数のページ間でユーザをナビゲーションをして、その時にコンポーネントのロード/リロードを行いたい場合は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.route<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を代わりに使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to deal with that type of refactoring, one can explicitly decide to support only a subset of the Array API, and implement another class with the same interface as this subset API.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003539Z" creationid="shibukawa.yoshiki" creationdate="20150409T003539Z">
        <seg>TodoListのようなクラスをリファクタリングする時は、ArrayクラスのAPIの一部だけをサポートするか、似た機能を持つまったく他のクラスを実装するか決定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to enable auto-redrawing, the <bpt i="1" x="1">&lt;c1&gt;</bpt>todo<ept i="1">&lt;/c1&gt;</ept> component must be initialized by either calling <bpt i="2" x="2">&lt;c2&gt;</bpt>m.mount<ept i="2">&lt;/c2&gt;</ept> or by creating a route definition with <bpt i="3" x="3">&lt;c3&gt;</bpt>m.route<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041601Z" creationid="shibukawa.yoshiki" creationdate="20150502T041601Z">
        <seg>自動再描画システムを利用する場合は、 <bpt i="2" x="2">&lt;c2&gt;</bpt>m.mount<ept i="2">&lt;/c2&gt;</ept>を使って<bpt i="1" x="1">&lt;c1&gt;</bpt>todo<ept i="1">&lt;/c1&gt;</ept>コンポーネントを初期化するか、<bpt i="3" x="3">&lt;c3&gt;</bpt>m.route<ept i="3">&lt;/c3&gt;</ept>を使ってラウト(route)を定義する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to force a redraw after a background request, use <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept> / <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012022Z" creationid="shibukawa.yoshiki" creationdate="20150415T012022Z">
        <seg>バックグラウンドのリクエスト後に再描画を行わせたい場合は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>もしくは<bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept> / <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept>を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to implement this principle, the rendering engine must run a redraw algorithm globally to ensure no parts of the UI are out of sync with the data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183754Z" creationid="shibukawa.yoshiki" creationdate="20150411T183754Z">
        <seg>この原則をきちんと実装するためには、データとの同期が漏れているUI部品がなくならないようにするために、再描画のアルゴリズムをビュー全体に対して漏れ無く実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to integrate an asynchronous code to Mithril's autoredrawing system, you should call <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> BEFORE making an asynchronous call, and <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> after the asynchronous callback completes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153136Z" creationid="shibukawa.yoshiki" creationdate="20150416T153136Z">
        <seg>非同期のコードとMithrilの自動再描画システムを統合する時は、非同期処理を呼び出す「前に」<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept>を呼び出し、非同期のコールバックの最後で<bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to integrate asynchronous code to Mithril's autoredrawing system, you should call <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> BEFORE making an asynchronous call, and <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> at the end of the asynchronous callback.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192747Z" creationid="shibukawa.yoshiki" creationdate="20150411T192747Z">
        <seg>非同期のコードとMithrilの自動再描画システムを統合する時は、非同期処理を呼び出す「前に」<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept>を呼び出し、非同期のコールバックの最後で<bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to integrate non-trivial asynchronous code to Mithril's auto-redrawing system, you need to ensure all execution threads call <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155920Z" creationid="shibukawa.yoshiki" creationdate="20150416T155920Z">
        <seg>自明でない非同期処理のコードとMithrilの自動再描画システムを統合するときには、確実にすべてのスレッドで<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to integrate non-trivial asynchronous code with Mithril's auto-redrawing system, you need to ensure all execution threads call <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004625Z" creationid="shibukawa.yoshiki" creationdate="20150412T004625Z">
        <seg>自明でない非同期処理のコードとMithrilの自動再描画システムを統合するときには、確実にすべてのスレッドで<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を呼び出す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to prevent redraws in <bpt i="0" x="0">&lt;e0&gt;</bpt>some parts<ept i="0">&lt;/e0&gt;</ept> of an application, but not others, see <bpt i="1" x="1">&lt;a1&gt;</bpt>subtree directives<ept i="1">&lt;/a1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T145222Z" creationid="shibukawa.yoshiki" creationdate="20150416T145222Z">
        <seg>アプリケーション内の<bpt i="0" x="0">&lt;e0&gt;</bpt>一部分<ept i="0">&lt;/e0&gt;</ept>の再描画だけを止めたい場合は、<bpt i="1" x="1">&lt;a1&gt;</bpt>サブツリーディレクティブ<ept i="1">&lt;/a1&gt;</ept>を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to retrieve the currently active route in a controller, you can use <bpt i="0" x="0">&lt;c0&gt;</bpt>m.route()<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171909Z" creationid="shibukawa.yoshiki" creationdate="20150414T171909Z">
        <seg>コントローラ内で、現在アクティブなラウトを取得するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.route()<ept i="0">&lt;/c0&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to specify the name of the querystring parameter that indicates the callback function, use the <bpt i="2" x="2">&lt;c2&gt;</bpt>callbackKey<ept i="2">&lt;/c2&gt;</ept> option:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235625Z" creationid="shibukawa.yoshiki" creationdate="20150414T235625Z">
        <seg>コールバック関数を表すクエリー文字列を指定するには、<bpt i="2" x="2">&lt;c2&gt;</bpt>callbackKey<ept i="2">&lt;/c2&gt;</ept>を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to stay flexible, Mithril doesn't provide helpers for bi-directional bindings out of the box.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014108Z" creationid="shibukawa.yoshiki" creationdate="20150413T014108Z">
        <seg>柔軟性を維持するために、Mithrilでは双方向バインディングを生成するヘルパーは提供していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to turn the virtual element into a real DOM element, you must call <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.render()<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000156Z" creationid="shibukawa.yoshiki" creationdate="20150413T000156Z">
        <seg>仮想DOMを本物のDOMに変換するには<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.render()<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>を呼ぶ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to update a forked version of Mithril, <bpt i="0" x="0">&lt;a0&gt;</bpt>follow the instructions on this page<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000743Z" creationid="shibukawa.yoshiki" creationdate="20150408T000743Z">
        <seg>フォークしたMithrilを更新したい場合は、<bpt i="0" x="0">&lt;a0&gt;</bpt>このページの説明(英語)<ept i="0">&lt;/a0&gt;</ept>.に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to use Mithril, extract it from the zip file and point a script tag to the <bpt i="0" x="0">&lt;c0&gt;</bpt>.js<ept i="0">&lt;/c0&gt;</ept> file:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164806Z" creationid="shibukawa.yoshiki" creationdate="20150407T164806Z">
        <seg>Mithrilを使用する場合は、zipファイルを展開し、その中の<bpt i="0" x="0">&lt;c0&gt;</bpt>.js<ept i="0">&lt;/c0&gt;</ept>ファイルをscriptタグを使って指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other words, all our controller needs to do is this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004121Z" creationid="shibukawa.yoshiki" creationdate="20150408T004109Z">
        <seg>Mithrilのコントローラが行うべきことは、次のコードがすべてです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other words, don't do this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100006Z" creationid="shibukawa.yoshiki" creationdate="20150502T100006Z">
        <seg>別の説明をすると、以下のようなことをしてはならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In our example, since the whole application lives in one component, we're going to use the component as a namespace for our model entities.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040727Z" creationid="shibukawa.yoshiki" creationdate="20150502T040727Z">
        <seg>今回のサンプルではすべてのアプリケーションが1つのコンポーネントに収まっているため、コンポーネントを名前空間として使い、モデルの実体もその中にいれてしまいましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In practice, this means performing operations like shifting an item from the beginning of a list would cause every element in the list to be diffed and potentially recreated.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141226Z" creationid="shibukawa.yoshiki" creationdate="20150413T141226Z">
        <seg>例えば、リストの先頭に挿入するような操作は、すべての要素が変更されたとみなして、すべてが再生成されてしまう可能性もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In practice, this means that calling <bpt i="0" x="0">&lt;c0&gt;</bpt>m.component(MyComponent, {foo: "bar"})<ept i="0">&lt;/c0&gt;</ept> will return a component that behaves exactly the same as <bpt i="1" x="1">&lt;c1&gt;</bpt>MyComponent<ept i="1">&lt;/c1&gt;</ept>, but <bpt i="2" x="2">&lt;c2&gt;</bpt>{foo: "bar"}<ept i="2">&lt;/c2&gt;</ept> will be bound as an argument to both the <bpt i="3" x="3">&lt;c3&gt;</bpt>controller<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>view<ept i="4">&lt;/c4&gt;</ept> functions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075727Z" creationid="shibukawa.yoshiki" creationdate="20150502T075727Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.component(MyComponent, {foo: "bar"})<ept i="0">&lt;/c0&gt;</ept>という呼び出しをすると、<bpt i="1" x="1">&lt;c1&gt;</bpt>MyComponent<ept i="1">&lt;/c1&gt;</ept>と同じコンポーネントを返しますが、<bpt i="2" x="2">&lt;c2&gt;</bpt>{foo: "bar"}<ept i="2">&lt;/c2&gt;</ept>という引数が<bpt i="3" x="3">&lt;c3&gt;</bpt>controller<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>view<ept i="4">&lt;/c4&gt;</ept>関数に束縛されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In practice, this means that calling <bpt i="3" x="3">&lt;c3&gt;</bpt>m.redraw<ept i="3">&lt;/c3&gt;</ept> may cause a redraw to happen before some AJAX calls have finished, which in turn, may cause null reference exceptions in templates that try to use the data from these requests without first checking that the data exists.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T115057Z" creationid="shibukawa.yoshiki" creationdate="20150502T115057Z">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>m.redraw<ept i="3">&lt;/c3&gt;</ept>を使うと、AJAX呼び出しの完了前に再描画を実行させることができます。データの存在のチェックを行わないと、null参照例外が発生する恐れがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In practice, this means that calling <bpt i="4" x="4">&lt;c4&gt;</bpt>m.redraw<ept i="4">&lt;/c4&gt;</ept> may cause a redraw to happen before some AJAX calls have finished, which in turn, may cause null reference exceptions in templates that try to use the data from these requests without first checking that the data exists.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130619Z" creationid="shibukawa.yoshiki" creationdate="20150502T130619Z">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>m.redraw<ept i="4">&lt;/c4&gt;</ept>を使うと、AJAX呼び出しの完了前に再描画を実行させることができます。データの存在のチェックを行わないと、null参照例外が発生する恐れがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In practice, this means that if the two components were in a <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactsWidget<ept i="0">&lt;/c0&gt;</ept> component as before, saving a contact would not update the list without some extra code.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015527Z" creationid="shibukawa.yoshiki" creationdate="20150502T015527Z">
        <seg>実際、<bpt i="0" x="0">&lt;c0&gt;</bpt>ContactsWidget<ept i="0">&lt;/c0&gt;</ept>内にコンポーネントが2つあるとすると、何もコードを追加しなければリストが更新されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In real life, given a choice, you should always pick the simplest idiom for your use case.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152802Z" creationid="shibukawa.yoshiki" creationdate="20150408T152802Z">
        <seg>実際のコーディングでは、いくつか選択肢があった場合には、ユースケースを実現するもっともシンプルな方法を選択すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In such a case, it's the view-model's responsibility to track the current state of the input vs the original state and to apply a cancellation, if required.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T160811Z" creationid="shibukawa.yoshiki" creationdate="20150407T160650Z">
        <seg>このケースでは、ビュー・モデルは、オリジナルの状態とテキスト入力の現在の状態の差のトラッキングと、キャンセル処理の提要に関する責任を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In such cases, simply omit the m.startComputation/m.endComputation calls.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135804Z" creationid="shibukawa.yoshiki" creationdate="20150415T135804Z">
        <seg>その場合は、単にm.startComputation/m.endComputation呼び出しを省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In terms of architecture, one of Mithril's main differences is that it does not provide base classes to extend from.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114958Z" creationid="shibukawa.yoshiki" creationdate="20150417T114958Z">
        <seg>アーキテクチャ面でみると、Mithrilが他のフレームワークと大きく異るのは、拡張する元となるベースクラスを提供していない点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In that case, it's possible to skip redrawing altogether by calling <bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw.strategy("none")<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150228Z" creationid="shibukawa.yoshiki" creationdate="20150416T150228Z">
        <seg>この場合、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw.strategy("none")<ept i="0">&lt;/c0&gt;</ept>を呼ぶことで、再描画をスキップできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the application above, notice how the Todo class can easily be moved to a different component if code re-organization is required.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041831Z" creationid="shibukawa.yoshiki" creationdate="20150502T041831Z">
        <seg>上記のコードのTodoクラスは、もしコードを再構成する必要が出てきたとしても、とても簡単に他のコンポーネントに移動できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the case above, Mithril only touches the <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> attribute of the input.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015644Z" creationid="shibukawa.yoshiki" creationdate="20150408T015644Z">
        <seg>上記の場合、Mithrilはテキスト入力の<bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>属性しか変更しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the case of our todo application, the view-model needs a few things: it needs to track a running list of todos and a field for adding new todos, and it needs to handle the logic of adding to the todo and the implications of this action of the UI.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T161612Z" creationid="shibukawa.yoshiki" creationdate="20150407T161441Z">
        <seg>われわれのToDoアプリケーションでは、ビュー・モデルに必要とされるものはそれほど多くありません。アクティブなToDoのリストと、新しいToDoを追加するためのフィールドの管理、ToDoを追加するロジックや、UIのアクションとの連携です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the code above, <bpt i="0" x="0">&lt;c0&gt;</bpt>todo.vm.list<ept i="0">&lt;/c0&gt;</ept> is an Array, and <bpt i="1" x="1">&lt;c1&gt;</bpt>map<ept i="1">&lt;/c1&gt;</ept> is one of its native functional methods.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153022Z" creationid="shibukawa.yoshiki" creationdate="20150408T153022Z">
        <seg>上記のコードの<bpt i="0" x="0">&lt;c0&gt;</bpt>todo.vm.list<ept i="0">&lt;/c0&gt;</ept>はJavaScriptの配列です。<bpt i="1" x="1">&lt;c1&gt;</bpt>map<ept i="1">&lt;/c1&gt;</ept>は関数型プログラミング的な機能を提供する、標準の関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the code above, the <bpt i="0" x="0">&lt;c0&gt;</bpt>oninput<ept i="0">&lt;/c0&gt;</ept> event handler updates the <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> getter-setter, and the Mithril auto-redrawing system redraws the template in order to update the displayed value.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014815Z" creationid="shibukawa.yoshiki" creationdate="20150413T014815Z">
        <seg>この上記のサンプルを実行すると、<bpt i="0" x="0">&lt;c0&gt;</bpt>oninput<ept i="0">&lt;/c0&gt;</ept>イベントハンドラが<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> getter-setterを更新します。Mithrilの自動再描画システムが表示される値の更新にともなって再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the code above, we are simply using the native Javascript <bpt i="0" x="0">&lt;c0&gt;</bpt>Function::bind<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151318Z" creationid="shibukawa.yoshiki" creationdate="20150408T151318Z">
        <seg>上記のコードは、標準的なJavaScriptの<bpt i="0" x="0">&lt;c0&gt;</bpt>Function::bind<ept i="0">&lt;/c0&gt;</ept>メソッドを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the controller layer: to bind error messages</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123840Z" creationid="shibukawa.yoshiki" creationdate="20150410T123840Z">
        <seg>コントローラレイヤ内: エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the controller layer: to bind redirection code upon a condition</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123813Z" creationid="shibukawa.yoshiki" creationdate="20150410T123726Z">
        <seg>コントローラレイヤ内: 条件によって、リダイレクトするコードをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the controller, to bind error messages</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125741Z" creationid="shibukawa.yoshiki" creationdate="20150410T125741Z">
        <seg>コントローラ内で、エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the controller, to redirect after a model service resolves</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125727Z" creationid="shibukawa.yoshiki" creationdate="20150410T125727Z">
        <seg>コントローラ内で、モデルサービスが改良した後にリダイレクトさせたい場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the event the form was saved, then view-model would delegate saving to a more appropriate ORM model entity.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T160932Z" creationid="shibukawa.yoshiki" creationdate="20150407T160923Z">
        <seg>フォームが保存されるというイベントが発生したら、ビュー・モデルはより適切なORMモデルエンティティに保存処理を移譲します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, A+ promises are required to log <bpt i="0" x="0">&lt;c0&gt;</bpt>2<ept i="0">&lt;/c0&gt;</ept> before logging <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>, whereas Mithril logs <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> before <bpt i="3" x="3">&lt;c3&gt;</bpt>2<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140509Z" creationid="shibukawa.yoshiki" creationdate="20150415T140509Z">
        <seg>このサンプルを実行すると、A+ promisesの場合は、 <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>の前に<bpt i="0" x="0">&lt;c0&gt;</bpt>2<ept i="0">&lt;/c0&gt;</ept>をログ出力しますが、Mithrilは<bpt i="3" x="3">&lt;c3&gt;</bpt>2<ept i="3">&lt;/c3&gt;</ept>の前に<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, input focus would be maintained correctly after a redraw even if <bpt i="0" x="0">&lt;c0&gt;</bpt>items<ept i="0">&lt;/c0&gt;</ept> got sorted or reversed.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142321Z" creationid="shibukawa.yoshiki" creationdate="20150413T142321Z">
        <seg>上記のサンプルでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>items<ept i="0">&lt;/c0&gt;</ept>がソートされたり、順序が逆転したあとに再描画されても、正しくフォーカスが維持されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, since the key is different, the ProjectList component is recreated from scratch.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085849Z" creationid="shibukawa.yoshiki" creationdate="20150502T085849Z">
        <seg>上記の例では、キーが異なるため、ProjectListのコンポーネントは一度破棄されて再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the text input is bi-directionally bound to a <bpt i="0" x="0">&lt;c0&gt;</bpt>temp<ept i="0">&lt;/c0&gt;</ept> getter-setter.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081318Z" creationid="shibukawa.yoshiki" creationdate="20150502T081318Z">
        <seg>上記のサンプルは、テキスト入力と、<bpt i="0" x="0">&lt;c0&gt;</bpt>temp<ept i="0">&lt;/c0&gt;</ept> getter-setterが双方向のバインディングで接続されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the usage of <bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept> allows the developer to change the implementation of the user name getter/setter without the need for code changes in the controller and view.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134725Z" creationid="shibukawa.yoshiki" creationdate="20150414T134725Z">
        <seg>上記のサンプルでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept>を使うことで、コントローラとビュー内のコードを変更することなく、ユーザ名のgetter/setterの実装を変更できるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, there are 3 components.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T001408Z" creationid="shibukawa.yoshiki" creationdate="20150502T001408Z">
        <seg>上記のサンプルには3つのコンポーネントが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, <bpt i="0" x="0">&lt;c0&gt;</bpt>User.list<ept i="0">&lt;/c0&gt;</ept> returns a list of <bpt i="1" x="1">&lt;c1&gt;</bpt>User<ept i="1">&lt;/c1&gt;</ept> instances.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170638Z" creationid="shibukawa.yoshiki" creationdate="20150410T170552Z">
        <seg>次のサンプルでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>User.list<ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="1" x="1">&lt;c1&gt;</bpt>User<ept i="1">&lt;/c1&gt;</ept>インスタンスのリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, clicking the button triggers the component's <bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept> event and logs "unloaded!".</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092735Z" creationid="shibukawa.yoshiki" creationdate="20150502T092735Z">
        <seg>次のサンプルはボタンを押すとコンポーネントの<bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept>イベントが呼ばれ、"アンロード!"とログに出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, the <bpt i="0" x="0">&lt;c0&gt;</bpt>listEven<ept i="0">&lt;/c0&gt;</ept> method returns a getter-setter that resolves to a list of users containing only users whose id is even.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124205Z" creationid="shibukawa.yoshiki" creationdate="20150410T124205Z">
        <seg>下記のサンプルの<bpt i="0" x="0">&lt;c0&gt;</bpt>listEven<ept i="0">&lt;/c0&gt;</ept>メソッドは、IDが偶数のユーザを含むリストのみを返すgetter-setterを返しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, there are two routes, each of which loads a component when a user navigates to their respective URLs.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124551Z" creationid="shibukawa.yoshiki" creationdate="20150502T124551Z">
        <seg>下記のサンプルには、2つのラウトがあります。ユーザがどちらかのURLにアクセスすると、それぞれのコンポーネントをロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, we bind an error getter-setter to our previous controller so that the <bpt i="0" x="0">&lt;c0&gt;</bpt>error<ept i="0">&lt;/c0&gt;</ept> variable gets populated if the server throws an error.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125140Z" creationid="shibukawa.yoshiki" creationdate="20150410T125140Z">
        <seg>下記のサンプルでは、error getter-setterと、前のサンプルで紹介したコントローラをバインドしています。<bpt i="0" x="0">&lt;c0&gt;</bpt>error<ept i="0">&lt;/c0&gt;</ept>変数は、サーバアクセスがうまく行かなかった時に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, we take advantage of queuing to debug the AJAX response data prior to doing further processing on the user list</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175107Z" creationid="shibukawa.yoshiki" creationdate="20150414T175107Z">
        <seg>下記のサンプルはAJAXレスポンスが実際に処理される前に、デバッグ処理を差し込んでいます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, we take advantage of queuing to debug the AJAX response data prior to doing further processing on the user list:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130243Z" creationid="shibukawa.yoshiki" creationdate="20150410T125757Z">
        <seg>下記のサンプルはAJAXレスポンスが実際に処理される前に、デバッグ処理を差し込んでいます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, we use the previously defined <bpt i="0" x="0">&lt;c0&gt;</bpt>listEven<ept i="0">&lt;/c0&gt;</ept> model method and queue a controller-level function that redirects to another page if the user list is empty.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124651Z" creationid="shibukawa.yoshiki" creationdate="20150410T124651Z">
        <seg>下記の例では、前の例で定義したモデルの<bpt i="0" x="0">&lt;c0&gt;</bpt>listEven<ept i="0">&lt;/c0&gt;</ept>メソッドを使用します。ユーザのリストが空の場合に他のページにリダイレクトするというコントローラレベルの機能をモデル完了後の操作としてキューイングしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the model layer: to process web service data in transformative ways (e.g. filtering a list based on a parameter that the web service doesn't support)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123731Z" creationid="shibukawa.yoshiki" creationdate="20150410T123712Z">
        <seg>モデルレイヤ内: ウェブサービスから受信したデータを変換処理をする場合。例えばウェブサービス側でサポートしていないフィルタリングをクライアント側で行う場合など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the view-model, we aliased the native Array class for <bpt i="0" x="0">&lt;c0&gt;</bpt>TodoList<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002657Z" creationid="shibukawa.yoshiki" creationdate="20150409T002628Z">
        <seg>サンプルのビュー・モデルの中で、<bpt i="0" x="0">&lt;c0&gt;</bpt>TodoList<ept i="0">&lt;/c0&gt;</ept>クラスを単なる配列のエイリアスとして定義しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, since there's only one route, the app redirects to the default route <bpt i="0" x="0">&lt;c0&gt;</bpt>"/dashboard/johndoe"<ept i="0">&lt;/c0&gt;</ept> and, under the hood, it calls <bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount(document.body, dashboard)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140257Z" creationid="shibukawa.yoshiki" creationdate="20150502T140257Z">
        <seg>この場合、ひとつのラウトしかないため、アプリケーションはデフォルトのラウトの<bpt i="0" x="0">&lt;c0&gt;</bpt>"/dashboard/johndoe"<ept i="0">&lt;/c0&gt;</ept>にリダイレクトして、フレームワーク内で<bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount(document.body, dashboard)<ept i="1">&lt;/c1&gt;</ept>が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, since there's only one route, the app redirects to the default route <bpt i="0" x="0">&lt;c0&gt;</bpt>"/dashboard/johndoe"<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153557Z" creationid="shibukawa.yoshiki" creationdate="20150414T153557Z">
        <seg>この場合、ひとつのラウトしかないため、アプリケーションはデフォルトのラウトの<bpt i="0" x="0">&lt;c0&gt;</bpt>"/dashboard/johndoe"<ept i="0">&lt;/c0&gt;</ept>にリダイレクトされます。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, we're using them in a way that resembles C pointers.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152219Z" creationid="shibukawa.yoshiki" creationdate="20150408T152219Z">
        <seg>上記の例の場合は、Cのポインタのような機能を実現しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this iteration, both the <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactForm<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>ContactList<ept i="1">&lt;/c1&gt;</ept> components are now children of the <bpt i="2" x="2">&lt;c2&gt;</bpt>ContactsWidget<ept i="2">&lt;/c2&gt;</ept> component and they appear simultaneously on the same page.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T020806Z" creationid="shibukawa.yoshiki" creationdate="20150502T020806Z">
        <seg>ここでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>ContactForm<ept i="0">&lt;/c0&gt;</ept>コンポーネントと<bpt i="1" x="1">&lt;c1&gt;</bpt>ContactList<ept i="1">&lt;/c1&gt;</ept>コンポーネントは<bpt i="2" x="2">&lt;c2&gt;</bpt>ContactsWidget<ept i="2">&lt;/c2&gt;</ept>コンポーネントの子供になっていて、どちらも同じページ内で表示されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this sense, one could argue that Mithril isn't really a framework.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T142604Z" creationid="shibukawa.yoshiki" creationdate="20150417T142604Z">
        <seg>この意味では、Mithrilは本当はフレームワークではないと言われる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In those cases, you can call <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> instead of using m.startComputation/m.endComputation.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135913Z" creationid="shibukawa.yoshiki" creationdate="20150415T135913Z">
        <seg>この場合は、m.startComputation/m.endComputationを呼ぶ代わりに、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In traditional server-side frameworks, the controller layer is of large significance because the nature of HTTP requests, responses and the framework abstractions that are exposed to developers require that the controller act as an adapter layer to transform the serialized data from HTTP requests to something that can be passed to ORM model methods.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T002057Z" creationid="shibukawa.yoshiki" creationdate="20150408T002057Z">
        <seg>伝統的なサーバーサイドフレームワークでは、HTTPのリクエスト、レスポンスおよび、開発者に公開されているフレームワークの抽象化という性質を考えると、コントローラレイヤはとても大きな役割を持つレイヤです。コントローラはHTTPのリクエストからシリアライズされたデータを取り出して変換して、ORMのモデルのメソッドに渡したりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Installation</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140627Z" creationid="shibukawa.yoshiki" creationdate="20150407T140627Z">
        <seg>インストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Installation - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164330Z" creationid="shibukawa.yoshiki" creationdate="20150407T164330Z">
        <seg>インストール - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Installing NodeJS and SweetJS for one-off compilations</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150018Z" creationid="shibukawa.yoshiki" creationdate="20150412T150018Z">
        <seg>事前コンパイルのためのNodeJSとSweetJSのインストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead of copying arguments to the controller object and then passing the controller object to the view (thereby creating internal state in the component), it is often desirable that views update based on the current value of arguments initially passed to a component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081032Z" creationid="shibukawa.yoshiki" creationdate="20150502T081032Z">
        <seg>コントローラオブジェクトに引数を渡して、コントローラオブジェクトからビューに渡すという実装の場合はコンポーネントの内部状態ができてしまいます。初期化時に渡される引数にもとづいてビューを更新するほうが望ましい場面が多いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead of locking developers down to very specific implementations of design patterns, Mithril's approach is to provide an idiomatic pattern to follow, and tools to aid the developer when required.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T144352Z" creationid="shibukawa.yoshiki" creationdate="20150417T144352Z">
        <seg>決まった設計のパターンでプログラマを拘束して、画一化された実装をさせるのではなく、Mithrilは従うべきイディオムのパターンを提供し、必要であればツールを提供するというアプローチをとっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, Mithril relies on <bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept> calls to figure out when to redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154046Z" creationid="shibukawa.yoshiki" creationdate="20150416T154046Z">
        <seg>Mithrilは再描画のタイミングを、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept>の呼び出しで決めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, Mithril's redrawing system relies on <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept><ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134021Z" creationid="shibukawa.yoshiki" creationdate="20150414T134021Z">
        <seg>Mithrilの再描画システムは、<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept><ept i="1">&lt;/a1&gt;</ept>の呼び出しをトリガーとして実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, it's composed of <bpt i="0" x="0">&lt;a0&gt;</bpt>pure functions<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080644Z" creationid="shibukawa.yoshiki" creationdate="20150502T080644Z">
        <seg>実際には、<bpt i="0" x="0">&lt;a0&gt;</bpt>純粋関数<ept i="0">&lt;/a0&gt;</ept>の集合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integrating multiple execution threads</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T003701Z" creationid="shibukawa.yoshiki" creationdate="20150412T003701Z">
        <seg>複数実行スレッドの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integrating multiple execution threads can be done in a two different ways: in a layered fashion or in comprehensive fashion</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155947Z" creationid="shibukawa.yoshiki" creationdate="20150416T155947Z">
        <seg>複数の実行スレッドのコードと統合を行うには2つの方法があります。階層に分けて行う方法と、統括的に行う方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integrating multiple execution threads can be done in two different ways: in a layered fashion or in comprehensive fashion.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004835Z" creationid="shibukawa.yoshiki" creationdate="20150412T004835Z">
        <seg>複数の実行スレッドのコードと統合を行うには2つの方法があります。階層に分けて行う方法と、統括的に行う方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integrating to legacy code</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T140345Z" creationid="shibukawa.yoshiki" creationdate="20150412T140345Z">
        <seg>レガシーコードとの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integrating to the Mithril redrawing system</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014919Z" creationid="shibukawa.yoshiki" creationdate="20150415T014919Z">
        <seg>Mithrilの再描画システムへの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integrating with Other Libraries</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140911Z" creationid="shibukawa.yoshiki" creationdate="20150407T140911Z">
        <seg>他のライブラリとの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integrating with Other Libraries - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T013529Z" creationid="shibukawa.yoshiki" creationdate="20150412T013529Z">
        <seg>他のライブラリとの統合 - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integrating with The Auto-Redrawing System</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192317Z" creationid="shibukawa.yoshiki" creationdate="20150411T192317Z">
        <seg>自動再描画システムの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integrating with the Auto-Redrawing System</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015846Z" creationid="shibukawa.yoshiki" creationdate="20150409T015846Z">
        <seg>自動再描画システムの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integration with third party libraries or vanilla javascript code can be achieved via the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept> attribute of virtual elements<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T013900Z" creationid="shibukawa.yoshiki" creationdate="20150412T013900Z">
        <seg>サードパーティライブラリや、pure JavaScriptのコードと統合するには<bpt i="0" x="0">&lt;a0&gt;</bpt>、仮想エレメントの<bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept>属性<ept i="0">&lt;/a0&gt;</ept>を使って行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Intelligent auto-redrawing system</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134217Z" creationid="shibukawa.yoshiki" creationdate="20150407T134217Z">
        <seg>インテリジェントな自動再描画システム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Internally, Mithril keeps a virtual representation of the DOM in cache, scans for changes, and then only modifies the absolute minimum required to apply the change to the DOM. In practice, this results in surprisingly fast re-rendering.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015608Z" creationid="shibukawa.yoshiki" creationdate="20150408T015608Z">
        <seg>Mitril内部では、仮想的に表現されたDOMをキャッシュとして持っていて、変更を検知して変更に必要な最小限の更新だけどDOMに対して行います。そのため、極めて高速に再レンダリングを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Internally, Mithril uses this data representation of the DOM to probe for data changes and update the DOM only where necessary.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072523Z" creationid="shibukawa.yoshiki" creationdate="20150502T072523Z">
        <seg>内部的にMithrilはこのDOMのデータ構造を使用して、データの変更を検知し、必要なところだけDOMを更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Internet Explorer 8 lacks native support for some of these features.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014525Z" creationid="shibukawa.yoshiki" creationdate="20150417T014525Z">
        <seg>Internet Explorer 8では、これらの機能のうちのいくつかが使えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Internet Explorer Compatibility</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014414Z" creationid="shibukawa.yoshiki" creationdate="20150417T014414Z">
        <seg>Internet Explorerの互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It allows us to iterate over the list and merge transformed versions of the list items into an output array.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153155Z" creationid="shibukawa.yoshiki" creationdate="20150408T153155Z">
        <seg>このメソッドを使うと、配列の全要素に対して変換処理を行い、その結果の要素で構成される配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also causes page refreshes in IE8.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005455Z" creationid="shibukawa.yoshiki" creationdate="20150410T005455Z">
        <seg>このモードも、IE8でページリフレッシュが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It always causes page refreshes in IE8.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170121Z" creationid="shibukawa.yoshiki" creationdate="20150414T170121Z">
        <seg>IE8上では、常にページリフレッシュが発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can be one of three values:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152254Z" creationid="shibukawa.yoshiki" creationdate="20150416T152254Z">
        <seg>これには次の3つの値のうちの1つを設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can be used in conjunction with <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.withAttr<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> to implement data binding in the view-to-model direction and to provide uniform data access for model entity properties.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T134502Z" creationid="shibukawa.yoshiki" creationdate="20150414T134502Z">
        <seg>この関数を<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.withAttr<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>と一緒に使うことで、ビューとモデル間のデータバインディングを作成し、モデルエンティティのプロパティのデータアクセス方法を平準化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can be used to store instances of 3rd party classes that need to be accessed more than one time throughout the lifecycle of a page.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155420Z" creationid="shibukawa.yoshiki" creationdate="20150413T155420Z">
        <seg>このオブジェクトはページのライフサイクルを通じて何度もアクセスする必要がある、サードパーティのクラスのインスタンスを保持するのにも使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can call model methods directly or from methods inside the resulting object.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061620Z" creationid="shibukawa.yoshiki" creationdate="20150502T061620Z">
        <seg>オブジェクトから、モデルのメソッドを直接呼び出したり、あるいはオブジェクトのメソッド内部から呼び出すことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can contain methods meant to be called by a <bpt i="0" x="0">&lt;c0&gt;</bpt>view<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061539Z" creationid="shibukawa.yoshiki" creationdate="20150502T061539Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>view<ept i="0">&lt;/c0&gt;</ept>と呼ばれるメソッドを持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can hold a reference to a view model.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061819Z" creationid="shibukawa.yoshiki" creationdate="20150502T061819Z">
        <seg>ビューモデルへの参照を持つことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can store contextual data returned from model methods (i.e. a <bpt i="0" x="0">&lt;a0&gt;</bpt>promise<ept i="0">&lt;/a0&gt;</ept> from a <bpt i="1" x="1">&lt;a1&gt;</bpt>request<ept i="1">&lt;/a1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061807Z" creationid="shibukawa.yoshiki" creationdate="20150502T061807Z">
        <seg><bpt i="1" x="1">&lt;a1&gt;</bpt>request<ept i="1">&lt;/a1&gt;</ept>が返す<bpt i="0" x="0">&lt;a0&gt;</bpt>promise<ept i="0">&lt;/a0&gt;</ept>などのモデルメソッドが返すデータを保持することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It contains <bpt i="1" x="1">&lt;c1&gt;</bpt>controller<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>view<ept i="2">&lt;/c2&gt;</ept> properties.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003534Z" creationid="shibukawa.yoshiki" creationdate="20150410T003534Z">
        <seg>モジュールは<bpt i="1" x="1">&lt;c1&gt;</bpt>controller<ept i="1">&lt;/c1&gt;</ept>プロパティと<bpt i="2" x="2">&lt;c2&gt;</bpt>view<ept i="2">&lt;/c2&gt;</ept>プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It contains a <bpt i="1" x="1">&lt;c1&gt;</bpt>controller<ept i="1">&lt;/c1&gt;</ept> and a <bpt i="2" x="2">&lt;c2&gt;</bpt>view<ept i="2">&lt;/c2&gt;</ept> properties.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153622Z" creationid="shibukawa.yoshiki" creationdate="20150414T153622Z">
        <seg>モジュールは<bpt i="1" x="1">&lt;c1&gt;</bpt>controller<ept i="1">&lt;/c1&gt;</ept>プロパティと<bpt i="2" x="2">&lt;c2&gt;</bpt>view<ept i="2">&lt;/c2&gt;</ept>プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It does not, however, de-dupe classes if the same class is declared twice.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153331Z" creationid="shibukawa.yoshiki" creationdate="20150413T153331Z">
        <seg>ただし、同じクラスが2度宣言されていたら、重複は取り除かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It does this because people expect unexpected errors like null reference exceptions to be thrown to the console for debugging purposes, and these errors are always subclasses of Error.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174459Z" creationid="shibukawa.yoshiki" creationdate="20150415T174459Z">
        <seg>Mithrilがこのような動作をするのは、多くのプログラマにとって、null参照例外などの未知の例外はデバッグのためにコンソールに出力される方がうれしいからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It enables seamless navigability while preserving the ability to bookmark each page individually, and the ability to navigate the application via the browser's history mechanism.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T020245Z" creationid="shibukawa.yoshiki" creationdate="20150409T020245Z">
        <seg>この機能を使うと、各ページをブックマークしたり、ブラウザの履歴の機能はそのままに、シームレスなナビゲーションが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It exposes a <bpt i="0" x="0">&lt;c0&gt;</bpt>promise<ept i="0">&lt;/c0&gt;</ept> property which can <bpt i="1" x="1">&lt;e1&gt;</bpt>bind<ept i="1">&lt;/e1&gt;</ept> callbacks to build a computation tree.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T133727Z" creationid="shibukawa.yoshiki" creationdate="20150415T133512Z">
        <seg>deferredは、コールバックを<bpt i="1" x="1">&lt;e1&gt;</bpt>バインド<ept i="1">&lt;/e1&gt;</ept>して、グラフ構造の計算木を構築するのに使える<bpt i="0" x="0">&lt;c0&gt;</bpt>promise<ept i="0">&lt;/c0&gt;</ept>プロパティを公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It exposes an event called <bpt i="2" x="2">&lt;c2&gt;</bpt>onsave<ept i="2">&lt;/c2&gt;</ept> which is fired when the Save button is pressed on the form.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002029Z" creationid="shibukawa.yoshiki" creationdate="20150502T002029Z">
        <seg>このモジュールは、フォーム上の保存ボタンが押された時に起動される<bpt i="2" x="2">&lt;c2&gt;</bpt>onsave<ept i="2">&lt;/c2&gt;</ept>イベントを公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It has a method <bpt i="5" x="5">&lt;c5&gt;</bpt>then<ept i="5">&lt;/c5&gt;</ept> which takes a <bpt i="6" x="6">&lt;c6&gt;</bpt>successCallback<ept i="6">&lt;/c6&gt;</ept> and a <bpt i="7" x="7">&lt;c7&gt;</bpt>errorCallback<ept i="7">&lt;/c7&gt;</ept> callbacks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134220Z" creationid="shibukawa.yoshiki" creationdate="20150415T134220Z">
        <seg>このプロパティは、<bpt i="6" x="6">&lt;c6&gt;</bpt>successCallback<ept i="6">&lt;/c6&gt;</ept>コールバックと、<bpt i="7" x="7">&lt;c7&gt;</bpt>errorCallback<ept i="7">&lt;/c7&gt;</ept>コールバックを受け取る、<bpt i="5" x="5">&lt;c5&gt;</bpt>then<ept i="5">&lt;/c5&gt;</ept>メソッドを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It includes support for the <bpt i="0" x="0">&lt;a0&gt;</bpt>MSX<ept i="0">&lt;/a0&gt;</ept> HTML templating syntax from Jonathan Buchanan.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000150Z" creationid="shibukawa.yoshiki" creationdate="20150408T000150Z">
        <seg>これは、Jonathan Buchananが作成した、HTMLテンプレートの文法の<bpt i="0" x="0">&lt;a0&gt;</bpt>MSX<ept i="0">&lt;/a0&gt;</ept>も含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is expected that such an error would bubble up to the console and display a developer-friendly error message and line number there.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172954Z" creationid="shibukawa.yoshiki" creationdate="20150415T172954Z">
        <seg>このようなエラーに対しては、例外が発生したときにエラーメッセージと行番号をコンソールに表示する方が開発者にやさしいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is modified internally by Mithril to the value <bpt i="0" x="0">&lt;c0&gt;</bpt>"all"<ept i="0">&lt;/c0&gt;</ept> before running controller constructors, and to the value <bpt i="1" x="1">&lt;c1&gt;</bpt>"diff"<ept i="1">&lt;/c1&gt;</ept> after all redraws.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152628Z" creationid="shibukawa.yoshiki" creationdate="20150416T152628Z">
        <seg>コントローラの構築が行われると、Mithrilは内部的にこのフラグを<bpt i="0" x="0">&lt;c0&gt;</bpt>"all"<ept i="0">&lt;/c0&gt;</ept>に設定し、再描画が行われると<bpt i="1" x="1">&lt;c1&gt;</bpt>"diff"<ept i="1">&lt;/c1&gt;</ept>に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is not a full MVC framework, but it is similar to Angular templates, and uses the same terminology for its features (e.g. directives and filters).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110014Z" creationid="shibukawa.yoshiki" creationdate="20150420T110014Z">
        <seg>これは完全なMVCフレームワークではありませんが、Angularのテンプレートと似ています。ディレクティブやフィルタなど、機能に対して同じ用語を使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is not an MVC framework in the traditional sense, but idiomatic Knockout code uses the similar concept of view models.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105504Z" creationid="shibukawa.yoshiki" creationdate="20150420T105504Z">
        <seg>これは伝統的な意味でのMVCフレームワークではありませんが、Knockoutが推奨しているスタイルに従ったコードは、ビュー・モデルと似たコンセプトを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is simply a javascript object that has a <bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T162128Z" creationid="shibukawa.yoshiki" creationdate="20150407T162128Z">
        <seg>ビュー・モデルオブジェクトは、<bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept>関数を持つ、シンプルなJavaScriptのオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is strongly recommended that you always set this option to avoid future surprises.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012549Z" creationid="shibukawa.yoshiki" creationdate="20150415T012549Z">
        <seg>このオプションは将来落とし穴に落ちないように設定することを強く勧めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is the developer's responsibility to ensure the input to <bpt i="0" x="0">&lt;c0&gt;</bpt>m.trust<ept i="0">&lt;/c0&gt;</ept> cannot be maliciously modified by user-entered data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015328Z" creationid="shibukawa.yoshiki" creationdate="20150416T015328Z">
        <seg>悪意をもってユーザが入力したデータを<bpt i="0" x="0">&lt;c0&gt;</bpt>m.trust<ept i="0">&lt;/c0&gt;</ept>に通す責任は開発者にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is useful for injecting a mock <bpt i="1" x="1">&lt;c1&gt;</bpt>window<ept i="1">&lt;/c1&gt;</ept> dependency for the purposes of testing and for running Mithril in non-browser environments.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160736Z" creationid="shibukawa.yoshiki" creationdate="20150416T160736Z">
        <seg>このカンスを使うと、モックの<bpt i="1" x="1">&lt;c1&gt;</bpt>window<ept i="1">&lt;/c1&gt;</ept>の依存性を注入できます。非ブラウザ環境でテストしたり、Mithrilを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is useful for teams where styling and functionality are done by different people, and for those who prefer to maintain templates in HTML syntax.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013844Z" creationid="shibukawa.yoshiki" creationdate="20150417T013844Z">
        <seg>このツールは、スタイリングと機能の実装が異なるチームで行われていて、テンプレートのメンテナンスにHTML文法が使いたい場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It leverages developer experience with server-side MVC frameworks, and in many ways, is very similar in scope to Mithril.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025052Z" creationid="shibukawa.yoshiki" creationdate="20150420T025052Z">
        <seg>サーバサイドのMVCフレームワークのある人がすぐに使いこなせるように作られている点など、多くの面でMithrilと非常に似通っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It may sound expensive to recompute an entire view any time there's a change to be displayed, but this operation actually turns out to be quite fast, compared to rendering strategies used by older frameworks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T074725Z" creationid="shibukawa.yoshiki" creationdate="20150502T074725Z">
        <seg>一見、変更を表示するたびに、このビュー全体に対する再計算を行うのは高コストな処理に見えるかもしれませんが、以前からあったフレームワークが使うレンダリングの方法論に比べると極めて高速です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It pre-processes the <bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept> call and replaces it with its output:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T145827Z" creationid="shibukawa.yoshiki" creationdate="20150412T145827Z">
        <seg>このマクロは<bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept>関数の呼び出しを事前に処理してし次のような関数を生成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It provides a number of useful features out of the box:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014234Z" creationid="shibukawa.yoshiki" creationdate="20150410T014234Z">
        <seg>提供される便利な機能には次のようなものがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It provides a templating engine with a virtual DOM diff implementation for performant rendering, utilities for high-level modelling via functional composition, as well as support for routing and componentization.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141605Z" creationid="shibukawa.yoshiki" creationdate="20150407T141605Z">
        <seg>Mithrilは、ハイパフォーマンスなレンダリング速度を持つ、仮想DOMの差分更新機能を持ったテンプレートエンジンや、関数型によるハイレベルなモデリングのサポート、ルーティング機能、コンポーネント化をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It provides full Turing completeness: full control over evaluation eagerness/laziness and caching in templates.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021616Z" creationid="shibukawa.yoshiki" creationdate="20150409T021616Z">
        <seg>Mithrilのテンプレートはチューリング完全です。先行評価と遅延評価を完全に制御できますし、テンプレートのキャッシュも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It returns a function that stores information.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133846Z" creationid="shibukawa.yoshiki" creationdate="20150414T133846Z">
        <seg>この関数は、情報を保持する関数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It returns a method that can be bound to a DOM element's event listener.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140211Z" creationid="shibukawa.yoshiki" creationdate="20150414T140211Z">
        <seg>この関数は、DOMエレメントのイベントリスナとして使えるメソッドを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's a good idea to wrap exception-prone code in a <bpt i="2" x="2">&lt;c2&gt;</bpt>try<ept i="2">&lt;/c2&gt;</ept> block and call <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept> from within the respective <bpt i="4" x="4">&lt;c4&gt;</bpt>finally<ept i="4">&lt;/c4&gt;</ept> block, in order to prevent rendering from halting.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153521Z" creationid="shibukawa.yoshiki" creationdate="20150416T153521Z">
        <seg>例外が発生する可能性のあるコードを<bpt i="2" x="2">&lt;c2&gt;</bpt>try<ept i="2">&lt;/c2&gt;</ept>ブロックで囲み、対応する<bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept>を<bpt i="4" x="4">&lt;c4&gt;</bpt>finally<ept i="4">&lt;/c4&gt;</ept>ブロック内で呼ぶようにすると、再描画システムが停止することを防げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's a good practice to always use the idiom above, instead of hardcoding <bpt i="1" x="1">&lt;c1&gt;</bpt>?<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>#<ept i="2">&lt;/c2&gt;</ept> in the href attribute.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013514Z" creationid="shibukawa.yoshiki" creationdate="20150410T013514Z">
        <seg>href属性の中に<bpt i="1" x="1">&lt;c1&gt;</bpt>?<ept i="1">&lt;/c1&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>#<ept i="2">&lt;/c2&gt;</ept>をハードコードするのではなく、常に上記のようなイディオムを使うのが良いプラクティスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's a good practice to make components stateless because they are more predictable, and easier to reason about, test and troubleshoot.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080824Z" creationid="shibukawa.yoshiki" creationdate="20150502T080824Z">
        <seg>コンポーネントをステートレスにすると、挙動が予測しやすくなり、テストやトラブルシューティングがやりやすくなるため、良いプラクティスと言えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's a modified version of the Thenable API.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015847Z" creationid="shibukawa.yoshiki" creationdate="20150415T015847Z">
        <seg>これはthenable APIのカスタム版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's also possible to modify the strategy that Mithril uses for any given redraw, by using <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw.strategy<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155613Z" creationid="shibukawa.yoshiki" creationdate="20150416T155613Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw.strategy<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を使うと、任意で行う再描画の戦略を変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's also possible to set values to Javascript-only properties, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>hash<ept i="0">&lt;/c0&gt;</ept> in a <bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;a&gt;<ept i="1">&lt;/c1&gt;</ept> element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T154808Z" creationid="shibukawa.yoshiki" creationdate="20150413T154808Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;a&gt;<ept i="1">&lt;/c1&gt;</ept>エレメントの<bpt i="0" x="0">&lt;c0&gt;</bpt>hash<ept i="0">&lt;/c0&gt;</ept>属性のように、JavaScriptだけで使用できるプロパティの値も設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's automatically placed in the appropriate section of the request with the appropriate serialization based on <bpt i="0" x="0">&lt;c0&gt;</bpt>method<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002503Z" creationid="shibukawa.yoshiki" creationdate="20150415T002503Z">
        <seg>設定されている<bpt i="0" x="0">&lt;c0&gt;</bpt>method<ept i="0">&lt;/c0&gt;</ept>によって、適切な方法でシリアライズされて、適切なペイロードに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's of course possible to use both aggregation of responsibility and the observer pattern at the same time.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T113528Z" creationid="shibukawa.yoshiki" creationdate="20150502T030529Z">
        <seg>もちろん、責務の統合と、オブザーバパターンを同時に使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's often said that <bpt i="0" x="0">&lt;e0&gt;</bpt>frameworks<ept i="0">&lt;/e0&gt;</ept>, in contrast to <bpt i="1" x="1">&lt;e1&gt;</bpt>libraries<ept i="1">&lt;/e1&gt;</ept>, dictate how code should be written.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T112534Z" creationid="shibukawa.yoshiki" creationdate="20150417T142540Z">
        <seg>よく言われることは、<bpt i="1" x="1">&lt;e1&gt;</bpt>ライブラリ<ept i="1">&lt;/e1&gt;</ept>と異なり、<bpt i="0" x="0">&lt;e0&gt;</bpt>フレームワーク<ept i="0">&lt;/e0&gt;</ept>はどのようにコーディングをするかを指示してくるものであると言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's perfectly valid to define controllers and views separately, and only bring them together when mounting them:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071547Z" creationid="shibukawa.yoshiki" creationdate="20150502T071547Z">
        <seg>コントローラとビューを分割して定義しても問題ありません。マウントするときに統合することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's possible to auto-cast a JSON response to a class.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130512Z" creationid="shibukawa.yoshiki" creationdate="20150410T130512Z">
        <seg>JSON表現をクラスに自動変換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's possible to defer a redraw by calling <bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept> or by manually nesting <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept><ept i="1">&lt;/a1&gt;</ept> contexts.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T185615Z" creationid="shibukawa.yoshiki" creationdate="20150411T185615Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept>を呼び出したり、<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept><ept i="1">&lt;/a1&gt;</ept>のコンテキストをネストすることで、 再描画を遅らせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's possible to opt out of the redrawing schedule by using the <bpt i="0" x="0">&lt;c0&gt;</bpt>background<ept i="0">&lt;/c0&gt;</ept> option for <bpt i="1" x="1">&lt;c1&gt;</bpt>m.request<ept i="1">&lt;/c1&gt;</ept>, or by simply not calling <bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept> / <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept> when calling non-Mithril asynchronous functions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155241Z" creationid="shibukawa.yoshiki" creationdate="20150416T155143Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>m.request<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>background<ept i="0">&lt;/c0&gt;</ept>オプションを使用したり、Mithril外の非同期関数を呼ぶ時は単に<bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept> / <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept>の呼び出しをしなければ再描画のスケジューリングをやめ、再描画が積極的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's recommended that you encapsulate integration code in a component or a helper function.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T013947Z" creationid="shibukawa.yoshiki" creationdate="20150412T013947Z">
        <seg>統合コードやヘルパー関数をコンポーネント内にカプセル化できるため、この方法が推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's recommended that you use the <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>ctx.retain<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> flag instead of changing the redraw strategy in controller constructors.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095840Z" creationid="shibukawa.yoshiki" creationdate="20150502T095840Z">
        <seg>再描画の戦略を変更する代わりに、<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>ctx.retain<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>フラグを使うのを推奨します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's relevant for comparison because it uses the same architecture as Mithril's templating engine: i.e. it acknowledges that DOM operations are the bottleneck of templating systems, and implements a virtual DOM tree which keeps track of changes and only applies diffs to the real DOM where needed.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095952Z" creationid="shibukawa.yoshiki" creationdate="20150420T095952Z">
        <seg>ReactはMithrilと似たようなアーキテクチャを持っています。DOM操作がテンプレートシステムのボトルネックであるという考えを共有し、仮想DOMツリーを持って差分だけを実際のDOMに反映するという実装を持っています。この比較はしやすいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's strongly recommended that you set an <bpt i="0" x="0">&lt;c0&gt;</bpt>initialValue<ept i="0">&lt;/c0&gt;</ept> option in ALL requests if you set the <bpt i="1" x="1">&lt;c1&gt;</bpt>background<ept i="1">&lt;/c1&gt;</ept> option to true.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134351Z" creationid="shibukawa.yoshiki" creationdate="20150502T134351Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>background<ept i="1">&lt;/c1&gt;</ept>をtrueに設定するリクエストの「全ての」リクエストに対して<bpt i="0" x="0">&lt;c0&gt;</bpt>initialValue<ept i="0">&lt;/c0&gt;</ept>オプションを設定するのを強く推奨します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's the only mode in which routing changes do not cause page refreshes in any browser.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005153Z" creationid="shibukawa.yoshiki" creationdate="20150410T005153Z">
        <seg>このモードは唯一、どのブラウザでもページリフレッシュが発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's worth mentioning that Mithril has built-in mechanisms elsewhere that take care of real bottlenecks like browser repaint management and DOM updating.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144619Z" creationid="shibukawa.yoshiki" creationdate="20150412T144619Z">
        <seg>Mithrilでは、ブラウザの再描画の管理やDOMの更新などの、本物のボトルネック以外をあまり気にする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's worth noting that the execution points listed above are commonly used for security attacks in combination with malformed markup, e.g. strings with mismatched attribute quotes like <bpt i="0" x="0">&lt;c0&gt;</bpt>" onload="alert(1)<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015120Z" creationid="shibukawa.yoshiki" creationdate="20150416T015120Z">
        <seg>このような実行ポイントを羅列することは、malformed(奇形)なタグと<bpt i="0" x="0">&lt;c0&gt;</bpt>" onload="alert(1)<ept i="0">&lt;/c0&gt;</ept>のようなクオートが揃ってない属性文字列の組み合わせによる攻撃に対しては意味がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It's your responsibility to make sure single iterations of animation rendering code don't take longer than 16ms (for a frequency of 60 frames-per-second).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020637Z" creationid="shibukawa.yoshiki" creationdate="20150421T020637Z">
        <seg>秒間60フレームを維持するために、この関数の単体の呼び出しのコストを16ミリ秒以下に抑えるのは開発者の責任です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Its return value is used to diff against the previous virtual DOM tree.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T074544Z" creationid="shibukawa.yoshiki" creationdate="20150502T074544Z">
        <seg>この返り値は以前の仮想DOMのツリーに対する差分を検知するのに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Its value can be set to either "search", "hash" or "pathname".</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004833Z" creationid="shibukawa.yoshiki" creationdate="20150410T004833Z">
        <seg>このプロパティには、"search"、"hash"、"pathname"のいづれかの文字列を設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Jordan Humphreys created a gem to allow integration with Rails:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000054Z" creationid="shibukawa.yoshiki" creationdate="20150408T000054Z">
        <seg>Jordan Humphreysが、Railsと統合できるようにするgemを作成しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keys are expected to be absolute pathnames, but can include dynamic parameters.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T155928Z" creationid="shibukawa.yoshiki" creationdate="20150414T155928Z">
        <seg>キーは絶対パスを指定しますが、動的パラメータを含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keys must be unique within a list of sibling DOM elements, and they must be either a string or a number:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080337Z" creationid="shibukawa.yoshiki" creationdate="20150502T080337Z">
        <seg>キーは兄弟のDOM要素の中でユニークである必要があります。キーの値は文字列でも数値でも大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Knockout is a library focused on data binding.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105414Z" creationid="shibukawa.yoshiki" creationdate="20150420T105414Z">
        <seg>Knockoutはデータバインディングにフォーカスしたライブラリです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lastly, be aware that if a user action triggers more than one event handler (for example, oninput and onkeypress, or an event bubbling up to event handlers in multiple ancestor elements), every event triggers a redraw by default.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151039Z" creationid="shibukawa.yoshiki" creationdate="20150416T151039Z">
        <seg>最後に、ユーザアクションがoninputとonkeypressなどの複数のイベントハンドラを起動したり、複数の祖先エレメントのイベントハンドラに対してバブリングした場合は、デフォルトではすべてのイベントが再描画を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Later in this guide, we'll pass the <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> property as the parameter to this function.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163419Z" creationid="shibukawa.yoshiki" creationdate="20150407T163419Z">
        <seg>このガイドの後半では、<bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept>プロパティをこの関数の引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Layered integration</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004902Z" creationid="shibukawa.yoshiki" creationdate="20150412T004844Z">
        <seg>階層に分けて統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Layered integration is recommended for modular code where many different APIs may be put together at the application level.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T005008Z" creationid="shibukawa.yoshiki" creationdate="20150412T005008Z">
        <seg>たくさんのさまざまなAPIがアプリケーションレベルで使われている時は、階層に分けて統合する方法がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Learn Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135632Z" creationid="shibukawa.yoshiki" creationdate="20150407T135632Z">
        <seg>Mithrilについて知る</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Learn More</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015637Z" creationid="shibukawa.yoshiki" creationdate="20150409T015637Z">
        <seg>より詳しく学ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Learn the ropes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135552Z" creationid="shibukawa.yoshiki" creationdate="20150407T135552Z">
        <seg>コツを覚えましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's create a component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040339Z" creationid="shibukawa.yoshiki" creationdate="20150502T040339Z">
        <seg>それではコンポーネントを作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's create a simple model entity which we'll use in a simple application, to illustrate different usage patterns for components:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T223633Z" creationid="shibukawa.yoshiki" creationdate="20150501T223633Z">
        <seg>まずはシンプルなモデルのエンティティを作ってみます。これはさまざまなコンポーネントの使用方法を説明するアプリケーションで使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Let's implement a <bpt i="0" x="0">&lt;s0&gt;</bpt>data binding<ept i="0">&lt;/s0&gt;</ept> on the text input.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014731Z" creationid="shibukawa.yoshiki" creationdate="20150408T014731Z">
        <seg>次に、テキスト入力に<bpt i="0" x="0">&lt;s0&gt;</bpt>データバインディング<ept i="0">&lt;/s0&gt;</ept>を実装していきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Light-weight</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133256Z" creationid="shibukawa.yoshiki" creationdate="20150407T133256Z">
        <seg>軽量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, it intelligently waits for asynchronous services inside event handlers to complete before redrawing.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161700Z" creationid="shibukawa.yoshiki" creationdate="20150408T161700Z">
        <seg>同様に、このシステムはイベントハンドラ内部の非同期サービスについても、再描画前にきちんと完了することを賢く待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Limitations and caveats</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050715Z" creationid="shibukawa.yoshiki" creationdate="20150502T050715Z">
        <seg>制限と制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Links to older versions can be found in the <bpt i="0" x="0">&lt;a0&gt;</bpt>change log<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164634Z" creationid="shibukawa.yoshiki" creationdate="20150407T164634Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>変更履歴<ept i="0">&lt;/a0&gt;</ept>のページ内に、古いバージョンへのリンクがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Loading</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135014Z" creationid="shibukawa.yoshiki" creationdate="20150407T135014Z">
        <seg>ロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mailing List</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135718Z" creationid="shibukawa.yoshiki" creationdate="20150407T135718Z">
        <seg>メーリングリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Make sure to add null checks if your request value can be null</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134806Z" creationid="shibukawa.yoshiki" creationdate="20150502T134806Z">
        <seg>リクエスト値がnullになる可能性がある場合は、nullチェックを行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Make sure to replace the <bpt i="0" x="0">&lt;c0&gt;</bpt>project-name-goes-here<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>destination-folder-goes-here<ept i="1">&lt;/c1&gt;</ept> placeholders with appropriate values.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150801Z" creationid="shibukawa.yoshiki" creationdate="20150412T150713Z">
        <seg>サンプル中の<bpt i="0" x="0">&lt;c0&gt;</bpt>プロジェクト名はこちら<ept i="0">&lt;/c0&gt;</ept>と、<bpt i="1" x="1">&lt;c1&gt;</bpt>インストールフィルダはこちら<ept i="1">&lt;/c1&gt;</ept>は実際の設定と置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Manually throwing an instance of the Error class itself (or any other objects or primitives) does trigger the rejection callback path as per the Promises/A+ spec.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172438Z" creationid="shibukawa.yoshiki" creationdate="20150415T141210Z">
        <seg>Promises/A+の仕様通りであれば、例外クラスそのもののインスタンス、もしくは何らかのプリミティブなオブジェクトを手動で投げるとrejectionコールバックが呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Method to use to deserialize the response data</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013153Z" creationid="shibukawa.yoshiki" creationdate="20150415T013153Z">
        <seg>レスポンスデータをデシリアライズするメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Method to use to extract the data from the raw XMLHttpRequest.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013314Z" creationid="shibukawa.yoshiki" creationdate="20150415T013314Z">
        <seg>XMLHttpRequest.からデータを取り出す時に使うメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Method to use to serialize the request data</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013102Z" creationid="shibukawa.yoshiki" creationdate="20150415T013102Z">
        <seg>リクエストデータをシリアライズするときに使用するメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Misc</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140947Z" creationid="shibukawa.yoshiki" creationdate="20150407T140947Z">
        <seg>その他</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril Template Compiler</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014148Z" creationid="shibukawa.yoshiki" creationdate="20150417T014148Z">
        <seg>Mithrilテンプレートコンパイラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril allows you to unwrap the relevant data, by providing two callback hooks: <bpt i="0" x="0">&lt;c0&gt;</bpt>unwrapSuccess<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>unwrapError<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174329Z" creationid="shibukawa.yoshiki" creationdate="20150410T174329Z">
        <seg>Mithrilは<bpt i="0" x="0">&lt;c0&gt;</bpt>unwrapSuccess<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>unwrapError<ept i="1">&lt;/c1&gt;</ept>という2つのコールバックを提供しており、これらを使って、それぞれのデータをアンラアップすることが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril also does not auto-camel-case CSS properties on inline style attributes, so you should use the Javascript syntax when setting them via Javascript objects:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013653Z" creationid="shibukawa.yoshiki" creationdate="20150413T013653Z">
        <seg>Mithrilはまた、インラインのスタイル属性のCSSのプロパティ名を自動でcamel-caseに変換することはありません。そのため、JavaScriptのオブジェクトを経由してJavaScript文法を使って設定すべきです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril also has a dependency on XMLHttpRequest.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014921Z" creationid="shibukawa.yoshiki" creationdate="20150417T014921Z">
        <seg>MithrilはXMLHttpRequestにも依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril also provides several hooks to control its redrawing behavior with a deep level of granularity: <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept> create redrawable contexts.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T191929Z" creationid="shibukawa.yoshiki" creationdate="20150411T191929Z">
        <seg>Mithrilはより深いレベルでエンジンの再描画の動作を制御できるように、いくつかのフックを提供しています。<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept>は再描画のコンテキストを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril also uses certain methods on the DOM node object</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T162043Z" creationid="shibukawa.yoshiki" creationdate="20150416T162043Z">
        <seg>DOMノードオブジェクトの特定のメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril automatically figures out the correct XML namespaces when it sees an SVG island in the virtual DOM tree.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T140855Z" creationid="shibukawa.yoshiki" creationdate="20150413T140843Z">
        <seg>仮想のDOMツリーの中にSVGの要素が現れると、Mithrilは自動で正しいXML名前空間を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril controllers can be stripped down to a bare minimum, so that they only perform a single essential role: to expose a scoped set of model-level functionality.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T002426Z" creationid="shibukawa.yoshiki" creationdate="20150408T002426Z">
        <seg>Mithrilのコントローラは、モデルレベルの機能の中からいくつか限定したものだけを公開するという、最小限の機能にまで落とし込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril does not hook into the browser's <bpt i="0" x="0">&lt;c0&gt;</bpt>onbeforeunload<ept i="0">&lt;/c0&gt;</ept> event.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092249Z" creationid="shibukawa.yoshiki" creationdate="20150502T092249Z">
        <seg>Mithrilはブラウザの<bpt i="0" x="0">&lt;c0&gt;</bpt>onbeforeunload<ept i="0">&lt;/c0&gt;</ept>イベントはフックしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril does not rely on unpolyfillable features, so developers can support browsers all the way back to IE6 and Blackberry by using shims if support for those older browsers is required.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110248Z" creationid="shibukawa.yoshiki" creationdate="20150420T110248Z">
        <seg>MithrilはPolyfillで補完できない機能は使ってないので、もしIE6以降ののブラウザやBlackberryに対応させる必要があれば、足りない機能を補間して対応させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril employs a variety of mechanisms to decide the best time and the best strategy to redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184821Z" creationid="shibukawa.yoshiki" creationdate="20150411T184821Z">
        <seg>Mithrilは、再描画をいつどんな戦略で行うかを決定するメカニズムをいくつか提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril has an internal counter, which is incremented every time <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> is called, and decremented every time <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154152Z" creationid="shibukawa.yoshiki" creationdate="20150416T154152Z">
        <seg>Mithrilは内部カウンタを持っています。このカウンタは<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept>が呼ばれるたびに増加し、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>が呼ばれると減少します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril has more documentation in its Github repo than source code, and none of the documentation is auto-generated.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114341Z" creationid="shibukawa.yoshiki" creationdate="20150417T114341Z">
        <seg>Mithrilは、github上で見ても、ソースコードそのものよりもドキュメントの方が大量にあります。また、自動生成のドキュメントはひとつもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril is a client-side Javascript MVC framework, i.e. it's a tool to make application code divided into a data layer (called <bpt i="0" x="0">&lt;s0&gt;</bpt>M<ept i="0">&lt;/s0&gt;</ept>odel), a UI layer (called <bpt i="1" x="1">&lt;s1&gt;</bpt>V<ept i="1">&lt;/s1&gt;</ept>iew), and a glue layer (called <bpt i="2" x="2">&lt;s2&gt;</bpt>C<ept i="2">&lt;/s2&gt;</ept>ontroller)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T110641Z" creationid="shibukawa.yoshiki" creationdate="20150407T141220Z">
        <seg>MithrilはクライアントサイドのJavaScript MVCフレームワークです。このツールを使うと、アプリケーションのコードはデータレイヤ(<bpt i="0" x="0">&lt;s0&gt;</bpt>M<ept i="0">&lt;/s0&gt;</ept>odel)、UIレイヤー(<bpt i="1" x="1">&lt;s1&gt;</bpt>V<ept i="1">&lt;/s1&gt;</ept>iew)、接続レイヤー(<bpt i="2" x="2">&lt;s2&gt;</bpt>C<ept i="2">&lt;/s2&gt;</ept>ontroller)に分割されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril is a client-side MVC framework - a tool to organize code in a way that is easy to think about and to maintain.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133223Z" creationid="shibukawa.yoshiki" creationdate="20150407T133223Z">
        <seg>MithrilはクライアントサイドMVCフレームワークです。コードをきれいに構成して、構造について考えるのを簡単にしたり、メンテナンスしやすくします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril is around 12kb gzipped thanks to its <bpt i="0" x="0">&lt;a0&gt;</bpt>small, focused, API<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T110536Z" creationid="shibukawa.yoshiki" creationdate="20150506T110536Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>小さく、ムダのないAPI<ept i="0">&lt;/a0&gt;</ept>のおかげで、Mithrilはgzipされた状態でたったの12kbしかありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril is available from a variety of sources:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164441Z" creationid="shibukawa.yoshiki" creationdate="20150407T164441Z">
        <seg>Mithrilはさまざまなインストール手段を提供しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril is designed around the principle that data always flows from the model to the view.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183448Z" creationid="shibukawa.yoshiki" creationdate="20150411T183448Z">
        <seg>Mithrilは、データは常にモデルからビューに流れる、という原則のもとに設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril promises are also getter-setter functions, which are populated with the resolved value if the promise is fulfilled successfully.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135338Z" creationid="shibukawa.yoshiki" creationdate="20150414T135338Z">
        <seg>Mithrilのpromiseもまたgetter-setter関数で、promiseが果たされると、解決された値が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril promises attempt to execute synchronously if possible.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140220Z" creationid="shibukawa.yoshiki" creationdate="20150415T140220Z">
        <seg>可能であればMithrilのpromiseは同期実行しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril provides a few more facilities that are not demonstrated in this page.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015709Z" creationid="shibukawa.yoshiki" creationdate="20150409T015709Z">
        <seg>Mithrilには、このページ内で紹介しきれなかった機能がまだいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril provides a high-level utility for working with web services, which allows writing asynchronous code relatively procedurally.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014041Z" creationid="shibukawa.yoshiki" creationdate="20150410T014041Z">
        <seg>Mithrilは、ウェブサービスと協調するための高度なユーティリティを提供しています。この機能を使うと、非同期で動作するコードを、比較的手続き的に記述することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril provides utilities to handle three different aspect of routing:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162147Z" creationid="shibukawa.yoshiki" creationdate="20150409T162147Z">
        <seg>Mithrilは、ラウティングに関して、3種類の異なるサポートを提供します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril relies on some ECMAScript 5 features, namely: <bpt i="0" x="0">&lt;c0&gt;</bpt>Array::indexOf<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Array::map<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Object::keys<ept i="2">&lt;/c2&gt;</ept>, as well as the <bpt i="3" x="3">&lt;c3&gt;</bpt>JSON<ept i="3">&lt;/c3&gt;</ept> object.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014511Z" creationid="shibukawa.yoshiki" creationdate="20150417T014511Z">
        <seg>Mithrilは<bpt i="0" x="0">&lt;c0&gt;</bpt>Array::indexOf<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Array::map<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>Object::keys<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>JSON<ept i="3">&lt;/c3&gt;</ept>オブジェクトなどのECMAScript 5の機能を使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril takes some learnings from that and implements a templating redrawing system that renders less aggressively, is less complex and is easier to profile.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094919Z" creationid="shibukawa.yoshiki" creationdate="20150420T094919Z">
        <seg>MithrilはAngularからの学びにより、控えめな実装で複雑さを下げ、プロファイリングしやすい実装にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril templates are also more collision-proof than other component systems since there's no way to pollute the HTML tag namespace by defining ad-hoc tag names.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015301Z" creationid="shibukawa.yoshiki" creationdate="20150409T015301Z">
        <seg>Mithrilのテンプレートは他のコンポーネントシステムよりも衝突に対して安全です。アドホックにタグ名を決定してHTMLタグの名前空間を汚すことができないようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril templates are defended against these attacks by default, except when markup is injected via <bpt i="0" x="0">&lt;c0&gt;</bpt>m.trust<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015237Z" creationid="shibukawa.yoshiki" creationdate="20150416T015237Z">
        <seg>Mithrilのテンプレートは、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.trust<ept i="0">&lt;/c0&gt;</ept>でマークアップを挿入するのを除けば、デフォルトではこのような攻撃を防ぐことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril templates are safe by default, i.e. you can't unintentionally create security holes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T161828Z" creationid="shibukawa.yoshiki" creationdate="20150407T135140Z">
        <seg>Mithrilのテンプレートはデフォルトで安全な動作をするようになっています。無理やり作ろうとしなければセキュリティホールを作ることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril thennables take two functions as optional parameters: the first parameter is called if the web service request completes successfully.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124829Z" creationid="shibukawa.yoshiki" creationdate="20150410T124829Z">
        <seg>Mithrilのthennableは、2つのオプションのパラメータを持っています。最初のパラメータはウェブサービスへのリクエストが問題なく完了した時に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril updates the native <bpt i="0" x="0">&lt;c0&gt;</bpt>location<ept i="0">&lt;/c0&gt;</ept> object after rendering in order to allow the browser's <bpt i="1" x="1">&lt;c1&gt;</bpt>history.pushState<ept i="1">&lt;/c1&gt;</ept> API to correctly show descriptive history entries (e.g. for Chrome's Ctrl+H page).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171822Z" creationid="shibukawa.yoshiki" creationdate="20150414T171822Z">
        <seg>Mithrilはレンダリングの後に、ネイティブの<bpt i="0" x="0">&lt;c0&gt;</bpt>location<ept i="0">&lt;/c0&gt;</ept>を更新して、<bpt i="1" x="1">&lt;c1&gt;</bpt>history.pushState<ept i="1">&lt;/c1&gt;</ept> APIが正しい履歴のエントリーが表示されるようにします(Chromeの場合はCtrl+H page)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril uses certain <bpt i="0" x="0">&lt;c0&gt;</bpt>window<ept i="0">&lt;/c0&gt;</ept> methods that will need to be made available for complete test coverage, depending on your application:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161926Z" creationid="shibukawa.yoshiki" creationdate="20150416T161926Z">
        <seg>Mithrilは完全なテストのカバレッジを得たり、アプリケーションの機能の実現のために、特定の<bpt i="0" x="0">&lt;c0&gt;</bpt>window<ept i="0">&lt;/c0&gt;</ept>のメソッドを呼んでいます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril uses them in other interesting ways elsewhere.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152259Z" creationid="shibukawa.yoshiki" creationdate="20150408T152248Z">
        <seg>Mithrilは、これ以外のさまざまなところでも、これらのテクニックを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril views can provide accurate and informative error reporting, with line numbers and meaningful stack traces.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013929Z" creationid="shibukawa.yoshiki" creationdate="20150409T013929Z">
        <seg>また、Mithrilのビューは、行番号と分かりやすいスタックトレース付きの正確で意味のあるエラーを出力できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril's auto-redrawing system keeps track of controller stability, and only redraws the view once it detects that the controller has finished running all of its code, including asynchronous AJAX payloads.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114401Z" creationid="shibukawa.yoshiki" creationdate="20150408T161344Z">
        <seg>Mithrilの自動再描画システムはコントローラの安定性を崩しません。ビューの再描画はコントローラの処理がすべて終わった時にのみ行われます。このコントローラの処理には、AJAXによるデータのロードも含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril's design strongly encourages all entity logic to be handled in atomic model layer methods (in the sense of entity state stability).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032116Z" creationid="shibukawa.yoshiki" creationdate="20150421T014353Z">
        <seg>Mithrilの設計としては、エンティティの状態の安定性を鑑みて、エンティティのロジックはモデルレイヤーのアトミックなメソッドで行うことを推奨しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril's diffing algorithm makes sure expensive DOM operations are performed only if absolutely necessary, and as an extra benefit, the global nature of the redraw makes it easy to reason about and troubleshoot the state of the application.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T074956Z" creationid="shibukawa.yoshiki" creationdate="20150502T074956Z">
        <seg>Mithrilは差分検知アルゴリズムを利用することで、高コストなDOM操作を本当に必要な箇所だけ実行することができます。また、全体を再描画するという仕組み上、アプリケーションの状態がビューとモデルの2つに存在するのではなく、モデルの状態によってのみ管理されるため、トラブルシューティングが簡単になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril's on-demand tooling approach means there are no hidden performance costs when implementing core MVC patterns, and there's also no extra learning curve for framework-specific syntax for those patterns.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T145613Z" creationid="shibukawa.yoshiki" creationdate="20150417T145404Z">
        <seg>Mithrilの必要な時に必要なツールだけを提供するアプローチでは、コアのMVCパターンを実装するときに、隠れたパフォーマンスのコストを負わされることはありません。また、フレームワークに対して、特定のパターンに対する特殊なシンタックスを覚えさせるような無用なラーニングカーブはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril's view layer paradigm is designed be <bpt i="0" x="0">&lt;s0&gt;</bpt>declarative<ept i="0">&lt;/s0&gt;</ept>, much like HTML, such that the same code implicitly does everything it needs to.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014616Z" creationid="shibukawa.yoshiki" creationdate="20150420T014616Z">
        <seg>Mithrilのビューレイヤーは<bpt i="0" x="0">&lt;s0&gt;</bpt>宣言的<ept i="0">&lt;/s0&gt;</ept>なコードになるように設計されていて、よりHTMLに近くなっています。表示するコードを書くだけですべて完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril, on the other hand, purposely avoids the observer pattern in an attempt to abolish "come-from hell", a class of debugging problems where you don't know what triggers some code because of a long chain of events triggering other events.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T021100Z" creationid="shibukawa.yoshiki" creationdate="20150420T020944Z">
        <seg>Mithrilはこれとは対照的に、「どこから来たのか分からない」といった種類の問題を避けるために、オブザーバパターンをなるべく避ける実装になっています。イベントからイベントへ、長いチェーンになっていると、何がコードを起動しているトリガーになっているのか理解が難しくなることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mithril, on the other hand, tries to provide only features that support a more classic MVC paradigm.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095131Z" creationid="shibukawa.yoshiki" creationdate="20150420T095131Z">
        <seg>Mithrilはそれとは対照的に、よりクラシックなMVCをサポートするのに必要な機能だけを備えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mode abstraction</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013122Z" creationid="shibukawa.yoshiki" creationdate="20150410T013122Z">
        <seg>モードの抽象化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Model</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T144138Z" creationid="shibukawa.yoshiki" creationdate="20150407T144138Z">
        <seg>モデル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Models are also responsible for centralizing tasks such as filtering of entity lists and validation routines, so that access to these methods is available across the application.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033522Z" creationid="shibukawa.yoshiki" creationdate="20150421T033411Z">
        <seg>エンティティのリストのフィルタリングや、バリデーションもモデルの責務になります。モデルに定義することで、アプリケーション全体でこれらのメソッドが利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>More documentation on the grunt-sweet.js task and its options <bpt i="0" x="0">&lt;a0&gt;</bpt>can be found here<ept i="0">&lt;/a0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150911Z" creationid="shibukawa.yoshiki" creationdate="20150412T150911Z">
        <seg>grunt-sweet.jsタスクと、オプションについては、<bpt i="0" x="0">&lt;a0&gt;</bpt>こちら見ることがｄけいます<ept i="0">&lt;/a0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most frameworks redraw aggressively and err on the side of redrawing too many times because, as it turns out, determining the best time to do a redraw is quite complicated if we want to be as efficient as possible.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184717Z" creationid="shibukawa.yoshiki" creationdate="20150411T184717Z">
        <seg>ほとんどのフレームワークでは、再描画を積極的に行いますが、やりすぎてしまうという間違いをおかしています。というのも、なるべく効率よくやろうとすると、再描画を行うベストなタイミングを決定するのはとても難しい問題だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most of the popular frameworks have at least a bare minimum amount of documentation nowadays, but many leave a bit to be desired: some lack usage examples, and some frameworks' communities need to rely heavily on third party sites for explanations of more advanced topics, and sometimes even for learning the basics.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114143Z" creationid="shibukawa.yoshiki" creationdate="20150417T114143Z">
        <seg>人気のフレームワークのほとんどは、最低限のドキュメントしか提供していませんが、多くの人は便利なサンプルが欠けていると感じていたり、上級のトピックは外部の情報まかせになっていたり、場合によっては基本的な情報すら外部の方が詳しかったりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mounting is the process of rendering a <bpt i="0" x="0">&lt;a0&gt;</bpt>component<ept i="0">&lt;/a0&gt;</ept> into a DOM element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125046Z" creationid="shibukawa.yoshiki" creationdate="20150502T125046Z">
        <seg>マウントは、<bpt i="0" x="0">&lt;a0&gt;</bpt>コンポーネント<ept i="0">&lt;/a0&gt;</ept>をDOMエレメントにレンダリングするプロセスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Must be either <bpt i="0" x="0">&lt;c0&gt;</bpt>"GET"<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>"POST"<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>"PUT"<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>"DELETE"<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>"HEAD"<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>"OPTIONS"<ept i="5">&lt;/c5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002151Z" creationid="shibukawa.yoshiki" creationdate="20150415T002151Z">
        <seg>このオプションは、<bpt i="0" x="0">&lt;c0&gt;</bpt>"GET"<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>"POST"<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>"PUT"<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>"DELETE"<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>"HEAD"<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>"OPTIONS"<ept i="5">&lt;/c5&gt;</ept>のどれかを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Must be the string "jsonp"</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014512Z" creationid="shibukawa.yoshiki" creationdate="20150415T014512Z">
        <seg>"jsonp"でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>NPM is the default package manager for <bpt i="0" x="0">&lt;a0&gt;</bpt>NodeJS<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165756Z" creationid="shibukawa.yoshiki" creationdate="20150407T165756Z">
        <seg>NPMは<bpt i="0" x="0">&lt;a0&gt;</bpt>NodeJS<ept i="0">&lt;/a0&gt;</ept>標準のパッケージマネージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Neither of these trade-offs are acceptable, given Mithril's focus on nimbleness and performance.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140945Z" creationid="shibukawa.yoshiki" creationdate="20150415T140945Z">
        <seg>Mithrilは敏捷性とパフォーマンスにフォーカスしているため、これらのトレードオフを受け入れることはできませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested asynchronous components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050651Z" creationid="shibukawa.yoshiki" creationdate="20150502T050651Z">
        <seg>非同期のネストされたコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested component views must return either a virtual element or another component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095635Z" creationid="shibukawa.yoshiki" creationdate="20150502T095635Z">
        <seg>ネストされたコンポーネントのビューは、仮想エレメントか他のコンポーネントを返さなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested components cannot change <bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw.strategy<ept i="0">&lt;/c0&gt;</ept> from the controller constructor (but they can from event handlers).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095755Z" creationid="shibukawa.yoshiki" creationdate="20150502T095755Z">
        <seg>ネストされたコンポーネントはコントローラのコンストラクタから<bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw.strategy<ept i="0">&lt;/c0&gt;</ept>を変更することはできません。ただしイベントハンドラからなら行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nesting components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050545Z" creationid="shibukawa.yoshiki" creationdate="20150502T050545Z">
        <seg>コンポーネントのネスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No flash-of-unbehaviored-content (FOUC).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114250Z" creationid="shibukawa.yoshiki" creationdate="20150409T013414Z">
        <seg>コンテンツが設定されていない内容が一瞬表示されてしまう(flash-of-unbehaviored-content :FOUC)のを防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Normally, calling <bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept> will return the controller instance for that component, but there's one corner case: if <bpt i="1" x="1">&lt;c1&gt;</bpt>e.preventDefault()<ept i="1">&lt;/c1&gt;</ept> is called from a controller's <bpt i="2" x="2">&lt;c2&gt;</bpt>onunload<ept i="2">&lt;/c2&gt;</ept> method, then the <bpt i="3" x="3">&lt;c3&gt;</bpt>m.mount<ept i="3">&lt;/c3&gt;</ept> call will not instantiate the new controller, and will return <bpt i="4" x="4">&lt;c4&gt;</bpt>undefined<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092155Z" creationid="shibukawa.yoshiki" creationdate="20150502T092155Z">
        <seg>通常、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept>呼び出しはコントローラのインスタンスを返します。しかし、コントローラの<bpt i="2" x="2">&lt;c2&gt;</bpt>onunload<ept i="2">&lt;/c2&gt;</ept>内で、<bpt i="1" x="1">&lt;c1&gt;</bpt>e.preventDefault()<ept i="1">&lt;/c1&gt;</ept>が呼ばれると、<bpt i="3" x="3">&lt;c3&gt;</bpt>m.mount<ept i="3">&lt;/c3&gt;</ept>は新しいコントローラのインスタンスの生成をやめ、<bpt i="4" x="4">&lt;c4&gt;</bpt>undefined<ept i="4">&lt;/c4&gt;</ept>が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Normally, you should only do this if you need to synchronously read a value from the DOM that requires a browser repaint (e.g. <bpt i="0" x="0">&lt;c0&gt;</bpt>offsetTop<ept i="0">&lt;/c0&gt;</ept> or a CSS rule).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151551Z" creationid="shibukawa.yoshiki" creationdate="20150416T151551Z">
        <seg>通常は、<bpt i="0" x="0">&lt;c0&gt;</bpt>offsetTop<ept i="0">&lt;/c0&gt;</ept>やCSSルールなど、ブラウザの再描画を必要とする、DOMの同期的な値読み込みが必要になった時だけにすべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Not using keys still works in some cases, but might trigger more expensive code paths within the redrawing algorithm.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T021156Z" creationid="shibukawa.yoshiki" creationdate="20150421T021156Z">
        <seg>キーを使用しなくても期待通りの動作をすることがありますが、再描画のアルゴリズムの効率が下がってコストが高くなる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note also that, despite having a bigger scope, Mithril has a smaller file size than React.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105402Z" creationid="shibukawa.yoshiki" creationdate="20150420T105402Z">
        <seg>また、そのように広い範囲をスコープに入れているにもかかわらず、MithrilのファイルサイズはReactよりも小さくなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i="0" x="0">&lt;c0&gt;</bpt>m.render<ept i="0">&lt;/c0&gt;</ept> is a very low level method in Mithril that draws only once and doesn't attempt to run the auto-redrawing system.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014121Z" creationid="shibukawa.yoshiki" creationdate="20150408T014121Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.render<ept i="0">&lt;/c0&gt;</ept>はMithrilの提供する中で、とても低レベルなメソッドで、1回だけ描画するために使います。自動再描画システムを利用する場合は使用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that Mithril always considers the model layer data to be canonical.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015108Z" creationid="shibukawa.yoshiki" creationdate="20150413T015108Z">
        <seg>Mithrilは、常にモデルレイヤのデータが正当なものであると判断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that Mithril checks for route matches in the order the routes are defined, so you should put variadic routes at the bottom of the list to prevent them from matching other more specific routes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T154059Z" creationid="shibukawa.yoshiki" creationdate="20150414T154059Z">
        <seg>Mithrilはラウトのマッチを定義された順番に行っていきます。そのため、可変個の引数を持つラウトは末尾に書かないと、より範囲の狭いラウトのマッチが行われなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that Mithril does not prescribe how the binding updates: you can bind it to <bpt i="0" x="0">&lt;c0&gt;</bpt>onchange<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>onkeypress<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>oninput<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>onblur<ept i="3">&lt;/c3&gt;</ept> or any other event that you prefer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021740Z" creationid="shibukawa.yoshiki" creationdate="20150408T021740Z">
        <seg>Mithrilはどのイベントを監視して更新を受け取るかはユーザに任せています。<bpt i="0" x="0">&lt;c0&gt;</bpt>onchange<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>onkeypress<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>oninput<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>onblur<ept i="3">&lt;/c3&gt;</ept>など、好きなイベントを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that Mithril only uses the mock object for browser APIs such as the DOM API and <bpt i="1" x="1">&lt;c1&gt;</bpt>requestAnimationFrame<ept i="1">&lt;/c1&gt;</ept>, but relies on the environment for ECMAScript features like <bpt i="2" x="2">&lt;c2&gt;</bpt>Object.keys<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161305Z" creationid="shibukawa.yoshiki" creationdate="20150416T161305Z">
        <seg>MithrilはDOM APIや<bpt i="1" x="1">&lt;c1&gt;</bpt>requestAnimationFrame<ept i="1">&lt;/c1&gt;</ept>などのブラウザAPIのためにのみモックオブジェクトを使いますが、<bpt i="2" x="2">&lt;c2&gt;</bpt>Object.keys<ept i="2">&lt;/c2&gt;</ept>などのECMAScript環境にも依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that Mithril promises are not automatically integrated to its automatic redrawing system.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134929Z" creationid="shibukawa.yoshiki" creationdate="20150415T134929Z">
        <seg>Mithrilのプロミスは自動的に自動再描画システムと統合されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that browsers ignore <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;script&gt;<ept i="0">&lt;/c0&gt;</ept> tags that have been inserted into the DOM via innerHTML.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014130Z" creationid="shibukawa.yoshiki" creationdate="20150416T014130Z">
        <seg>ブラウザは、innerHTML経由でDOMに挿入された<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;script&gt;<ept i="0">&lt;/c0&gt;</ept>タグは無視します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that changing the redraw strategy only affects the next scheduled redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T155643Z" creationid="shibukawa.yoshiki" creationdate="20150416T155643Z">
        <seg>再描画戦略の変更は次に計画されている再描画にのみ影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that compiled templates are meant to be generated by an automated build process and are not meant to be human editable.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T145920Z" creationid="shibukawa.yoshiki" creationdate="20150412T145845Z">
        <seg>このコンパイル済みのテンプレートは自動ビルドプロセスの結果作られたものであって、人間がこのように書くべきという意味ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that even if you set <bpt i="0" x="0">&lt;c0&gt;</bpt>context.retain = true<ept i="0">&lt;/c0&gt;</ept>, the element will still be destroyed and recreated if it is different enough from the existing element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135305Z" creationid="shibukawa.yoshiki" creationdate="20150413T135305Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>context.retain = true<ept i="0">&lt;/c0&gt;</ept>を設定しても、既存のエレメントと大きく異る場合はエレメントは破壊されて再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that failing to call <bpt i="0" x="0">&lt;c0&gt;</bpt>endComputation<ept i="0">&lt;/c0&gt;</ept> after a respective <bpt i="1" x="1">&lt;c1&gt;</bpt>startComputation<ept i="1">&lt;/c1&gt;</ept> call will halt the redrawing system.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153317Z" creationid="shibukawa.yoshiki" creationdate="20150416T153317Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>startComputation<ept i="1">&lt;/c1&gt;</ept>を呼んだ後に、対になる<bpt i="0" x="0">&lt;c0&gt;</bpt>endComputation<ept i="0">&lt;/c0&gt;</ept>呼び出しをすると、再描画システム全体が動作しなくなるので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that if the same attribute is defined in the both <bpt i="0" x="0">&lt;c0&gt;</bpt>selector<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>attributes<ept i="1">&lt;/c1&gt;</ept> parameters, the value in <bpt i="2" x="2">&lt;c2&gt;</bpt>attributes<ept i="2">&lt;/c2&gt;</ept> is used.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150803Z" creationid="shibukawa.yoshiki" creationdate="20150413T150803Z">
        <seg>もし<bpt i="0" x="0">&lt;c0&gt;</bpt>selector<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>attributes<ept i="1">&lt;/c1&gt;</ept>パラメータで同じ属性が定義されると、<bpt i="2" x="2">&lt;c2&gt;</bpt>attributes<ept i="2">&lt;/c2&gt;</ept>が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that if you're changing this configuration value, you should change it <bpt i="1" x="1">&lt;s1&gt;</bpt>before<ept i="1">&lt;/s1&gt;</ept> calling <bpt i="2" x="2">&lt;c2&gt;</bpt>m.route<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165746Z" creationid="shibukawa.yoshiki" creationdate="20150414T165746Z">
        <seg>この設定を変更する場合には、<bpt i="2" x="2">&lt;c2&gt;</bpt>m.route<ept i="2">&lt;/c2&gt;</ept>を呼び出す<bpt i="1" x="1">&lt;s1&gt;</bpt>前に<ept i="1">&lt;/s1&gt;</ept>行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that in addition to the presence of the <bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept> attribute, diffing rules also apply in determining whether an element is recreated.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144045Z" creationid="shibukawa.yoshiki" creationdate="20150413T144045Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept>属性があるかどうかに加えて、差分検知のルールもエレメントの再生成を行うかどうかの判定に使用される点は注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that in order to keep the framework lean, Mithril does not auto-append units like <bpt i="0" x="0">&lt;c0&gt;</bpt>px<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>%<ept i="1">&lt;/c1&gt;</ept> to any values.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013231Z" creationid="shibukawa.yoshiki" creationdate="20150413T013231Z">
        <seg>フレームワークは必要最低限の動作をするように設計されているため、どの属性名にも、<bpt i="0" x="0">&lt;c0&gt;</bpt>px<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>%<ept i="1">&lt;/c1&gt;</ept>といった単位を付けることはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that in order to support older versions of IE, you need to include <bpt i="0" x="0">&lt;a0&gt;</bpt>some shims<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165104Z" creationid="shibukawa.yoshiki" creationdate="20150407T165019Z">
        <seg>古いバージョンのIEをサポートする場合は、<bpt i="0" x="0">&lt;a0&gt;</bpt>互換性を向上させるライブラリ<ept i="0">&lt;/a0&gt;</ept>をいくつか読み込む必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that in order to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>pathname<ept i="0">&lt;/c0&gt;</ept> mode, the application must be run from the root URL.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170245Z" creationid="shibukawa.yoshiki" creationdate="20150414T170245Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>pathname<ept i="0">&lt;/c0&gt;</ept>モードを使う場合は、アプリケーションがルートのURLで実行するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that modifying the values of <bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept> getter-setters does not trigger redrawing.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133945Z" creationid="shibukawa.yoshiki" creationdate="20150414T133945Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept>getter-setterの値を変更しても、再描画が起動されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the <bpt i="0" x="0">&lt;c0&gt;</bpt>Todo<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>TodoList<ept i="1">&lt;/c1&gt;</ept> classes we defined above are plain vanilla Javascript constructors.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150749Z" creationid="shibukawa.yoshiki" creationdate="20150407T150749Z">
        <seg>上記のサンプルで定義した<bpt i="0" x="0">&lt;c0&gt;</bpt>Todo<ept i="0">&lt;/c0&gt;</ept>クラスと<bpt i="1" x="1">&lt;c1&gt;</bpt>TodoList<ept i="1">&lt;/c1&gt;</ept>クラスは、混じりけのない、プレーンなJavaScriptのコンストラクタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the URL component used to resolve routes is dependent on <bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.mode<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165413Z" creationid="shibukawa.yoshiki" creationdate="20150414T165413Z">
        <seg>ラウトの解決に使うURLの部位は、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.mode<ept i="0">&lt;/c0&gt;</ept>によって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the default promise exception handling semantics can be modified.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173452Z" creationid="shibukawa.yoshiki" creationdate="20150415T173452Z">
        <seg>このように、デフォルトの例外処理のセマンティクスが変更されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the example above only <bpt i="0" x="0">&lt;e0&gt;</bpt>sets<ept i="0">&lt;/e0&gt;</ept> the value of the input element in the DOM, but it never <bpt i="1" x="1">&lt;e1&gt;</bpt>reads<ept i="1">&lt;/e1&gt;</ept> it.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015822Z" creationid="shibukawa.yoshiki" creationdate="20150408T015822Z">
        <seg>このコードでは、DOMのテキスト入力エレメントの値に<bpt i="0" x="0">&lt;e0&gt;</bpt>設定するだけ<ept i="0">&lt;/e0&gt;</ept>で、<bpt i="1" x="1">&lt;e1&gt;</bpt>読み込み<ept i="1">&lt;/e1&gt;</ept>は行わないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the output value from <bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept> is not an actual DOM element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000134Z" creationid="shibukawa.yoshiki" creationdate="20150413T000134Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept>関数が返す値は、実際のDOM要素ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the redraw strategy is a global setting that affects the entire template trees of all components on the page.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130853Z" creationid="shibukawa.yoshiki" creationdate="20150502T130853Z">
        <seg>再描画の戦略は、ページ内の全コンポーネントのテンプレートツリーに影響を与えるグローバルな設定であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the sample component above is illustrative.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T082005Z" creationid="shibukawa.yoshiki" creationdate="20150502T081714Z">
        <seg>上記のサンプルは実際には役に立ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that there is no requirement to tightly couple a controller and view while organizing code.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071455Z" creationid="shibukawa.yoshiki" creationdate="20150502T071455Z">
        <seg>このコードを組み立てるときに、コントローラとビューを密結合させる必要がない点がポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that this getter-setter holds an <bpt i="0" x="0">&lt;e0&gt;</bpt>undefined<ept i="0">&lt;/e0&gt;</ept> value until the AJAX request completes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015221Z" creationid="shibukawa.yoshiki" creationdate="20150410T015221Z">
        <seg>getter-setterは、AJAXリクエストが完了するまでは<bpt i="0" x="0">&lt;e0&gt;</bpt>undefined<ept i="0">&lt;/e0&gt;</ept>値を返すことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that to redirect to a different page outside of the scope of Mithril's routing, you should use <bpt i="0" x="0">&lt;c0&gt;</bpt>window.location<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171505Z" creationid="shibukawa.yoshiki" creationdate="20150414T171505Z">
        <seg>もし、Mithrilのラウティングで取り扱っている範囲外のページにリダイレクトする場合は、<bpt i="0" x="0">&lt;c0&gt;</bpt>window.location<ept i="0">&lt;/c0&gt;</ept>を使うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that using this feature is discouraged if you don't have visible performance problems.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123949Z" creationid="shibukawa.yoshiki" creationdate="20150416T123949Z">
        <seg>もし、ビューに関するパフォーマンス上の問題が何もなければ、この機能は使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that when we construct the parameterized binding, we are passing the <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> getter-setter <bpt i="1" x="1">&lt;e1&gt;</bpt>by reference<ept i="1">&lt;/e1&gt;</ept>, and not its value.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151707Z" creationid="shibukawa.yoshiki" creationdate="20150408T151707Z">
        <seg>パラメータを束縛するときに、上記の例では<bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> getter-setterを<bpt i="1" x="1">&lt;e1&gt;</bpt>参照で渡して<ept i="1">&lt;/e1&gt;</ept>いて、直接値を渡しているわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that while a small gzipped size can look appealing, that number is often used to "hide the weight" of the uncompressed code: remember that the decompressed Javascript still needs to be parsed and evaluated on every page load, and this cost (which can be in the dozens of milliseconds range for some frameworks in some browsers) cannot be cached.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113412Z" creationid="shibukawa.yoshiki" creationdate="20150417T021951Z">
        <seg>gzipされたコードが小さいのがアピールポイントというのは、非圧縮時にとても大きくなることを隠しているように見えるかもしれません。非圧縮のJavaScriptはページロードのたびにパースと評価が行われます。いくつかのフレームワークでは環境によっては数10msにもなりますが、このコストはキャッシュできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that you can use JSON syntax if the attribute name you are setting has non-alphanumeric characters:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013102Z" creationid="shibukawa.yoshiki" creationdate="20150413T013102Z">
        <seg>アルファベットと数値以外の文字列を持つ属性名を設定したいときは、JSON文法を使うことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that you can use both Javascript property names and HTML attribute names to set values in the <bpt i="0" x="0">&lt;c0&gt;</bpt>attributes<ept i="0">&lt;/c0&gt;</ept> argument, but you should pass a value of appropriate type.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T003008Z" creationid="shibukawa.yoshiki" creationdate="20150413T003008Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>attributes<ept i="0">&lt;/c0&gt;</ept>引数の中では、JavaScriptのプロパティ名とHTML属性名の両方を使って設定できますが、適切な型を使って渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that, unlike many templating engines, this "smart diff" feature does not affect things like cursor placement in inputs and focus, and is therefore safe to call during user interactions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T020220Z" creationid="shibukawa.yoshiki" creationdate="20150416T020220Z">
        <seg>他のテンプレートエンジンとは異なり、この「賢い差分」機能は、入力フォームのカーソルやフォーカスに対して影響を与えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note, however, that since the code above is not valid Javascript, this syntax can only be used with a preprocessor build tool such as the provided <bpt i="0" x="0">&lt;a0&gt;</bpt>Gulp.js<ept i="0">&lt;/a0&gt;</ept> script.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014025Z" creationid="shibukawa.yoshiki" creationdate="20150417T014025Z">
        <seg>上記のコードはJavaScriptとして正しい文法ではありませんが、このコードは<bpt i="0" x="0">&lt;a0&gt;</bpt>Gulp.js<ept i="0">&lt;/a0&gt;</ept>などで提供されているプリプロセッサのビルドツールから読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notes on Architecture</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163521Z" creationid="shibukawa.yoshiki" creationdate="20150408T163521Z">
        <seg>アーキテクチャに関するメモ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notes on the view function</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045959Z" creationid="shibukawa.yoshiki" creationdate="20150502T045959Z">
        <seg>view関数に関するメモ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice how <bpt i="0" x="0">&lt;c0&gt;</bpt>doBoth<ept i="0">&lt;/c0&gt;</ept> repeatedly calls <bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> since that method calls both <bpt i="2" x="2">&lt;c2&gt;</bpt>doSomething<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>doAnother<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T005325Z" creationid="shibukawa.yoshiki" creationdate="20150412T005325Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>doBoth<ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>doSomething<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>doAnother<ept i="3">&lt;/c3&gt;</ept>から呼び出されるため、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept>を何度も呼んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice that now each component is self-contained: each has a separate route, and each component does exactly one thing.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T014332Z" creationid="shibukawa.yoshiki" creationdate="20150502T014332Z">
        <seg>これらのコンポーネントは機能別にまとまっています。それぞれ異なったラウターを持ち、それぞれのコンポーネントは1つのタスクだけを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice that the <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactList<ept i="0">&lt;/c0&gt;</ept> does not care about whether <bpt i="1" x="1">&lt;c1&gt;</bpt>args.contacts<ept i="1">&lt;/c1&gt;</ept> refers to all the contacts in the database, or just contacts that match some criteria.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T005556Z" creationid="shibukawa.yoshiki" creationdate="20150502T005556Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ContactList<ept i="0">&lt;/c0&gt;</ept>リストは<bpt i="1" x="1">&lt;c1&gt;</bpt>args.contacts<ept i="1">&lt;/c1&gt;</ept>がデータベース内のすべての連絡先を参照しているか、フィルタリング条件でヒットしたものだけが渡されているのかどうかは知りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice that we pass a root DOM element to attach our template to, as well as the template itself.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013700Z" creationid="shibukawa.yoshiki" creationdate="20150408T013700Z">
        <seg>renderメソッドを呼び出す時は、テンプレートそのものに加えて、ルートのDOM要素を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Often, web services return the relevant data wrapped in objects that contain metadata.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174025Z" creationid="shibukawa.yoshiki" creationdate="20150410T174025Z">
        <seg>少なくない数のウェブサービスが、それぞれのデータをメタデータ入りのオブジェクトでラップして返してきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Often, you will want to do some work before the component is unloaded (i.e. clear timers or unsubscribe event handlers):</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091614Z" creationid="shibukawa.yoshiki" creationdate="20150502T091614Z">
        <seg>コンポーネントをアンロードする前にタイマーをクリアしたり、イベントハンドラを削除したり、何か仕事をしたくなることがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On the one hand, it's extremely easy to reason about the behavior of the components since they only serve a single purpose, but on the other hand they don't have the flexibility that the previous example did (e.g. in this iteration, <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactList<ept i="0">&lt;/c0&gt;</ept> can only list all of the contacts in the database, not an arbitrary subset.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T015307Z" creationid="shibukawa.yoshiki" creationdate="20150502T015307Z">
        <seg>それぞれのコンポーネントは個別の目的のために提供されているため、動作を理解するのは簡単ですが、前述のサンプルのような柔軟性はありません。<bpt i="0" x="0">&lt;c0&gt;</bpt>ContactList<ept i="0">&lt;/c0&gt;</ept>は全連絡先のリストを表示するのにしか使えず、サブセットの表示はできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On the other hand, if you were to call a web service using jQuery, then you would be responsible for adding a <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> call before the jQuery ajax call, and for adding a <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> call at the end of the completion callback, in addition to the calls within the <bpt i="2" x="2">&lt;c2&gt;</bpt>change<ept i="2">&lt;/c2&gt;</ept> event handler.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134953Z" creationid="shibukawa.yoshiki" creationdate="20150412T134826Z">
        <seg>そうではなくjQueryを使ってウェブサービス呼び出しをしているのであれば、<bpt i="2" x="2">&lt;c2&gt;</bpt>change<ept i="2">&lt;/c2&gt;</ept>イベントハンドラ内にこの関数のペアを置く以外に、jQueryのajax呼び出しの前に<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept>を追加し、コールバックが完了した後に<bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>呼び出しを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On the other hand, javascript developers rarely ever throw errors that are subclasses of Error, and for the purposes of application error handling, the underlying prototypal chain of the error class is typically not relevant.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174723Z" creationid="shibukawa.yoshiki" creationdate="20150415T174723Z">
        <seg>言い換えると、JavaScript開発者は例外に関して、アプリケーションのエラーハンドリングを目的としてErrorのサブクラスを作って投げることはほとんどありません。Errorのプロトタイプチェーンを気にすることはほとんどありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once each request completes, the counter is decremented.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154500Z" creationid="shibukawa.yoshiki" creationdate="20150416T154500Z">
        <seg>リクエストが完了するたびにカウンタが減少します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once installed, create two files in the root of your project, <bpt i="0" x="0">&lt;c0&gt;</bpt>package.json<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Gruntfile.js<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150546Z" creationid="shibukawa.yoshiki" creationdate="20150412T150546Z">
        <seg>インストールしたら、プロジェクトのルートに<bpt i="0" x="0">&lt;c0&gt;</bpt>package.json<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Gruntfile.js<ept i="1">&lt;/c1&gt;</ept>の2つのファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once resolved, the placeholder is replaced with component B's view.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094557Z" creationid="shibukawa.yoshiki" creationdate="20150502T094557Z">
        <seg>非同期処理が完了すると、プレースホルダは実際のコンポーネントBのビューに置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once that counter reaches zero, Mithril redraws.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190035Z" creationid="shibukawa.yoshiki" creationdate="20150411T190035Z">
        <seg>カウンタがゼロになるとMithrilは再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once the controller code finishes executing (and this may include waiting for AJAX requests to complete), the view class is instantiated, and the instance of the controller is passed as an argument to the view's constructor.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T021045Z" creationid="shibukawa.yoshiki" creationdate="20150414T021045Z">
        <seg>コントローラコードの実行が完了すると(AJAXのリクエストの完了待ちも含む)ビュークラスのインスタンスが作られ、ビューのコンストラクタにコントローラのインスタンスが渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once the counter reaches zero, Mithril redraws.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154159Z" creationid="shibukawa.yoshiki" creationdate="20150416T154159Z">
        <seg>カウンタがゼロになるとMithrilは再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once you have a <bpt i="0" x="0">&lt;a0&gt;</bpt>copy of Mithril<ept i="0">&lt;/a0&gt;</ept>, getting started is surprisingly boilerplate-free:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142648Z" creationid="shibukawa.yoshiki" creationdate="20150407T142648Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>Mithrilのインストール<ept i="0">&lt;/a0&gt;</ept>をしたらコーディングを開始しましょう。Mithrilは、決まり文句がとても少ない、小さなHTMLから開始することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One caveat of using the CSS syntax is that it clobbers the <bpt i="0" x="0">&lt;c0&gt;</bpt>style<ept i="0">&lt;/c0&gt;</ept> attribute in the DOM element on redraws, so this syntax is not appropriate if you need to use it in conjunction with 3rd party tools that modify the element's style outside of Mithril's templates (e.g. via <bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept>, which is explained below)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014630Z" creationid="shibukawa.yoshiki" creationdate="20150413T014630Z">
        <seg>注意点としては、CSS文法を使うとDOM要素の再描画の時に<bpt i="0" x="0">&lt;c0&gt;</bpt>style<ept i="0">&lt;/c0&gt;</ept>属性が強制的にテンプレートで設定されたスタイルに上書きされます。そのため、Mithrilのテンプレートの外からスタイルを変更するようなサードパーティ製ツールを使用する必要があるときは、CSS文法を避けてください。この後の<bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept>の項目で詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One common way of using <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> is in conjunction with <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.route<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>, which is an unobtrusive extension to links that allow Mithril's routing system to work transparently regardless of which routing mode is used.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124149Z" creationid="shibukawa.yoshiki" creationdate="20150413T123936Z">
        <seg>設定<bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>の一般的な使用法の１つに、<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.route<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>と一緒に使用して、設定されているラウティングモードにかかわらず、透過的に動作するようにリンクを拡張するというものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One extremely important aspect of this architecture is that since components encapsulate their internal state, then by definition it's harder to reason about AJAX request redundancy (i.e. how to prevent two identical AJAX requests originating from two different components).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021953Z" creationid="shibukawa.yoshiki" creationdate="20150502T021953Z">
        <seg>このアーキテクチャの注意点としては、コンポーネントが内部状態をカプセル化しているため、AJAXアクセスが冗長になってしまうのを防ぐのが難しいということがあります。異なるコンポーネントがまったく同じAJAXアクセスを行うのを防ぐ方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One important limitation to be aware of when using components is that you cannot call Mithril's redrawing methods (<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> / <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept> and <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>m.redraw<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>) from templates.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094813Z" creationid="shibukawa.yoshiki" creationdate="20150502T094813Z">
        <seg>一番重要な制限は、テンプレートの中からMithrilの再描画メソッド(<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> / <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept><ept i="0">&lt;/a0&gt;</ept> / <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>m.redraw<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>)を呼び出すことができないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One important note about the <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> method is that you should avoid calling <bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept> in the <bpt i="4" x="4">&lt;c4&gt;</bpt>config<ept i="4">&lt;/c4&gt;</ept> function's execution thread.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135443Z" creationid="shibukawa.yoshiki" creationdate="20150412T135443Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>メソッドについて注意すべきことは、<bpt i="4" x="4">&lt;c4&gt;</bpt>config<ept i="4">&lt;/c4&gt;</ept>関数の実行スレッド内では、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.redraw<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>m.startComputation<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>m.endComputation<ept i="3">&lt;/c3&gt;</ept>を呼び出さないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One of its selling points is that it allows developers to leverage their existing jQuery knowledge, while providing some "walls" to organize the code in a more structured manner.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020006Z" creationid="shibukawa.yoshiki" creationdate="20150420T020006Z">
        <seg>開発者に対するBackboneのセールスポイントの1つは、既存のjQueryの知識を活かした上で、コードをきちんと構造化するための「ついたて」を提供するというものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One other difference that is extremely clear is the treatment of data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015651Z" creationid="shibukawa.yoshiki" creationdate="20150420T015651Z">
        <seg>他に大きく異る点は、データの取り扱いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One related difference is that other frameworks often have hard-coded base classes where every conceivable convenience method gets inherited by the developer's classes (remember, in Javascript, this can mean copying all of the utility methods over to the child class, regardless of whether they're going to be used or not).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T145321Z" creationid="shibukawa.yoshiki" creationdate="20150417T145321Z">
        <seg>これに関連する他のフレームワークとの違いとして、これらのフレームワークはよく、考えつく限りの便利なメソッドが満載になったフレームワーク固有のベースクラスを提供していて、開発者のクラスにこれを継承させます。実際に使うかどうかにかかわらず、JavaScriptではこれらのユーティリティメソッドもすべて子クラスにコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One technical aspect that is also different is that Backbone is heavily event-oriented.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020723Z" creationid="shibukawa.yoshiki" creationdate="20150420T020719Z">
        <seg>技術的な側面での大きな違いは、Backboneがイベント駆動に重きをおいている点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One thing you may have noticed on the <bpt i="0" x="0">&lt;a0&gt;</bpt>Mithril homepage<ept i="0">&lt;/a0&gt;</ept> is that, out of the box, Angular is not as performant as other frameworks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094331Z" creationid="shibukawa.yoshiki" creationdate="20150420T094331Z">
        <seg>もう1点、<bpt i="0" x="0">&lt;a0&gt;</bpt>Mithrilホームページ<ept i="0">&lt;/a0&gt;</ept>を見て分かるように、Angularは他のフレームワークよりもパフォーマンスで引けを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One typical way to override this is to receive as-is responses.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T175213Z" creationid="shibukawa.yoshiki" creationdate="20150410T175213Z">
        <seg>よくある変更方法としては、変換せずに帰ってきた入力をそのままアプリケーションに渡す方式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One way of organizing components is to use component parameter lists to send data downstream, and to define events to bubble data back upstream to a centralized module who is responsible for interfacing with the model layer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T000307Z" creationid="shibukawa.yoshiki" creationdate="20150502T000307Z">
        <seg>コンポーネントの組み立て方の１つの例としては、コンポーネントのパラメータリストを使ってデータを下流に流すと共に、モデルレイヤとのインタフェースとなっている中心のモジュールまでバブリングしてデータを上流に戻すイベントを定義するというものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only 12kb gzipped, no dependencies</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150730T225644Z" creationid="shibukawa.yoshiki" creationdate="20150730T225636Z">
        <seg>gzip圧縮時にたったの12KBで、他への依存がない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only tag, id, class and attribute selectors are supported.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150610Z" creationid="shibukawa.yoshiki" creationdate="20150413T150610Z">
        <seg>タグ、ID、クラス、属性セレクタのみがサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optimizing Performance</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141712Z" creationid="shibukawa.yoshiki" creationdate="20150412T141712Z">
        <seg>パフォーマンスの最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optimizing Performance - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141653Z" creationid="shibukawa.yoshiki" creationdate="20150412T141653Z">
        <seg>パフォーマンスの最適化 - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optimizing performance</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015824Z" creationid="shibukawa.yoshiki" creationdate="20150409T015824Z">
        <seg>パフォーマンスの最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Opting out of the auto redrawing system</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050758Z" creationid="shibukawa.yoshiki" creationdate="20150502T050758Z">
        <seg>自動再描画システムの対象から外す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional controller</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045932Z" creationid="shibukawa.yoshiki" creationdate="20150502T045932Z">
        <seg>オプショナルなコントローラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other arguments to be bound as arguments to both the <bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>view<ept i="1">&lt;/c1&gt;</ept> functions</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100647Z" creationid="shibukawa.yoshiki" creationdate="20150502T100647Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>view<ept i="1">&lt;/c1&gt;</ept>関数に束縛されるそれ以外の引数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise it follows the Promises/A+ specifications.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174356Z" creationid="shibukawa.yoshiki" creationdate="20150415T174356Z">
        <seg>そうでない場合は、Promises/A+の仕様に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our next step is to write a view-model that will use our model classes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152255Z" creationid="shibukawa.yoshiki" creationdate="20150407T152255Z">
        <seg>次のステップとして、モデルクラスを使用する、ビュー・モデルを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Output</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134431Z" creationid="shibukawa.yoshiki" creationdate="20150407T134431Z">
        <seg>出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameterized components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050010Z" creationid="shibukawa.yoshiki" creationdate="20150502T050010Z">
        <seg>パラメータ化されたコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameterized initial state</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050614Z" creationid="shibukawa.yoshiki" creationdate="20150502T050614Z">
        <seg>パラメータの初期状態</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameterizes a component</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045801Z" creationid="shibukawa.yoshiki" creationdate="20150502T045801Z">
        <seg>コンポーネントのパラメータ化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameters to pass as a querystring</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171527Z" creationid="shibukawa.yoshiki" creationdate="20150414T171527Z">
        <seg>クエリー文字列として渡されるパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performance</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134435Z" creationid="shibukawa.yoshiki" creationdate="20150407T134435Z">
        <seg>パフォーマンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Persisting DOM elements across route changes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121529Z" creationid="shibukawa.yoshiki" creationdate="20150502T121529Z">
        <seg>ラウト変更前後でのDOMエレメントの永続化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Persisting config data</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T234205Z" creationid="shibukawa.yoshiki" creationdate="20150412T234205Z">
        <seg>設定データの永続化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Post questions and discuss Mithril related topics.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135754Z" creationid="shibukawa.yoshiki" creationdate="20150407T135754Z">
        <seg>質問を投稿したり、Mithril関連の話題について議論をするメーリングリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Preventing redraws on events</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T125106Z" creationid="shibukawa.yoshiki" creationdate="20150416T125106Z">
        <seg>イベントによる再描画の阻止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Processing web service data</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123850Z" creationid="shibukawa.yoshiki" creationdate="20150410T123850Z">
        <seg>ウェブサービスのデータの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Processing-web-service-data</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174506Z" creationid="shibukawa.yoshiki" creationdate="20150414T174506Z">
        <seg>ウェブサービスのデータの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Querystring parameters in a route are also available in this collection automatically.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170737Z" creationid="shibukawa.yoshiki" creationdate="20150414T170737Z">
        <seg>ラウト中のクエリー文字列のパラメータもこのコレクションに自動的に格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Queuing Operations</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125333Z" creationid="shibukawa.yoshiki" creationdate="20150410T125333Z">
        <seg>操作のキューイング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Queuing operations</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174524Z" creationid="shibukawa.yoshiki" creationdate="20150414T174524Z">
        <seg>操作のキューイング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>React is a component engine developed by Facebook.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095613Z" creationid="shibukawa.yoshiki" creationdate="20150420T095613Z">
        <seg>ReactはFacebookによって開発されたコンポーネントエンジンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Read Guide</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135559Z" creationid="shibukawa.yoshiki" creationdate="20150407T135559Z">
        <seg>ガイドを読む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Read an argument from a parameterized route</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153708Z" creationid="shibukawa.yoshiki" creationdate="20150412T153708Z">
        <seg>パラメータ化されたラウトから引数の読み込み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Read articles</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135714Z" creationid="shibukawa.yoshiki" creationdate="20150407T135714Z">
        <seg>記事を読む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Read docs</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135625Z" creationid="shibukawa.yoshiki" creationdate="20150407T135625Z">
        <seg>ドキュメントを読む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Read the current route</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153306Z" creationid="shibukawa.yoshiki" creationdate="20150412T153306Z">
        <seg>現在のラウトを取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reading the currently active route</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152451Z" creationid="shibukawa.yoshiki" creationdate="20150414T152451Z">
        <seg>現在アクティブなラウトの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Redirecting</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012905Z" creationid="shibukawa.yoshiki" creationdate="20150410T012905Z">
        <seg>リダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Redirects to a route</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153249Z" creationid="shibukawa.yoshiki" creationdate="20150412T153249Z">
        <seg>ラウトへリダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Redraws the view for the currently active component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125933Z" creationid="shibukawa.yoshiki" creationdate="20150502T125933Z">
        <seg>現在のアクティブなコンポーネントのビューの再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Refer to the <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>auto-redrawing<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept> guide for an example.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135018Z" creationid="shibukawa.yoshiki" creationdate="20150412T135018Z">
        <seg>サンプルについては<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>自動描画システム<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>のガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Regardless, you could also force multiple redraws to happen by using the <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>background<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>initialValue<ept i="3">&lt;/c3&gt;</ept> options in <bpt i="4" x="4">&lt;c4&gt;</bpt>m.request<ept i="4">&lt;/c4&gt;</ept>, or by manually calling <bpt i="5" x="5">&lt;a5&gt;</bpt><bpt i="6" x="6">&lt;c6&gt;</bpt>m.redraw()<ept i="6">&lt;/c6&gt;</ept><ept i="5">&lt;/a5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094358Z" creationid="shibukawa.yoshiki" creationdate="20150502T094149Z">
        <seg>特に気にしなければ、<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>background<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>オプションと<bpt i="3" x="3">&lt;c3&gt;</bpt>initialValue<ept i="3">&lt;/c3&gt;</ept>オプションを付けて<bpt i="4" x="4">&lt;c4&gt;</bpt>m.request<ept i="4">&lt;/c4&gt;</ept>を呼び出すか、手動で<bpt i="5" x="5">&lt;a5&gt;</bpt><bpt i="6" x="6">&lt;c6&gt;</bpt>m.redraw()<ept i="6">&lt;/c6&gt;</ept><ept i="5">&lt;/a5&gt;</ept>を呼び出せば、何度か強制的に再描画させることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Released under the <bpt i="0" x="0">&lt;a0&gt;</bpt>MIT license<ept i="0">&lt;/a0&gt;</ept> <ph x="1">&lt;br1/&gt;</ph></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000937Z" creationid="shibukawa.yoshiki" creationdate="20150408T000937Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>MITライセンス<ept i="0">&lt;/a0&gt;</ept>でリリースされています<ph x="1">&lt;br1/&gt;</ph></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Released under the <bpt i="0" x="0">&lt;a0&gt;</bpt>MIT license<ept i="0">&lt;/a0&gt;</ept><ph x="1">&lt;br1/&gt;</ph></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135930Z" creationid="shibukawa.yoshiki" creationdate="20150407T135930Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>MITライセンス<ept i="0">&lt;/a0&gt;</ept>でリリースされています<ph x="1">&lt;br1/&gt;</ph></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remember that the rules for keys apply to components the same way they do to regular elements: it is not allowed to have duplicate keys on children of the same parent, and they must be either strings or numbers (or something with a <bpt i="0" x="0">&lt;c0&gt;</bpt>.toString()<ept i="0">&lt;/c0&gt;</ept> implementation that makes the entity uniquely identifiable in the local scope when serialized).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090821Z" creationid="shibukawa.yoshiki" creationdate="20150502T090821Z">
        <seg>キーの適用のルールは通常のエレメントと同じです。同じ親の子供が同じキーを持つことはできません。またキーは文字列か数字、もしくは<bpt i="0" x="0">&lt;c0&gt;</bpt>.toString()<ept i="0">&lt;/c0&gt;</ept>メソッドを持っていてローカルスコープ内でユニークなキーを生成できる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rendering</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135029Z" creationid="shibukawa.yoshiki" creationdate="20150407T135029Z">
        <seg>レンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rendering Components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125012Z" creationid="shibukawa.yoshiki" creationdate="20150502T125012Z">
        <seg>コンポーネントのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rendering before web service requests finish</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174714Z" creationid="shibukawa.yoshiki" creationdate="20150414T174714Z">
        <seg>ウェブサービスのリクエスト完了前のレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rendering components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045857Z" creationid="shibukawa.yoshiki" creationdate="20150502T045857Z">
        <seg>コンポーネントのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Renders a component</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045812Z" creationid="shibukawa.yoshiki" creationdate="20150502T045812Z">
        <seg>コンポーネントのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Retrieving a value via the getter-setter API</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014904Z" creationid="shibukawa.yoshiki" creationdate="20150415T014904Z">
        <seg>getter-setter APIを使ったデータの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returning an array, a string, a number, boolean, falsy value, etc will result in an error.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095709Z" creationid="shibukawa.yoshiki" creationdate="20150502T095709Z">
        <seg>配列、文字列、数値、ブーリアン、負になる値などを返すとエラーになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Roadmap</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154253Z" creationid="shibukawa.yoshiki" creationdate="20150412T154253Z">
        <seg>ロードマップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Robust</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133440Z" creationid="shibukawa.yoshiki" creationdate="20150407T133440Z">
        <seg>信頼性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Route parameters are dynamic values that can be extracted from the URL based on the signature of the currently active route.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170523Z" creationid="shibukawa.yoshiki" creationdate="20150414T170523Z">
        <seg>ラウトのパラメータは、現在アクティブなラウトのシグニチャを元にして、現在のURLから取り出された動的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Routes can take arguments, by prefixing words with a colon <bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153420Z" creationid="shibukawa.yoshiki" creationdate="20150414T153420Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>を前に付いた単語を書くことで、ラウトに引数を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Routes can take arguments, by prefixing words with a colon <bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003039Z" creationid="shibukawa.yoshiki" creationdate="20150410T003039Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>を前に付いた単語を書くことで、ラウトに引数を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Routes with querystrings</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152326Z" creationid="shibukawa.yoshiki" creationdate="20150414T152326Z">
        <seg>ラウトとクエリー文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Routing</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015810Z" creationid="shibukawa.yoshiki" creationdate="20150407T140735Z">
        <seg>ラウティング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Routing - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015956Z" creationid="shibukawa.yoshiki" creationdate="20150409T015956Z">
        <seg>ラウティング - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Routing is a system that allows creating Single-Page-Applications (SPA), i.e. applications that can go from a page to another without causing a full browser refresh.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152527Z" creationid="shibukawa.yoshiki" creationdate="20150414T152527Z">
        <seg>ラウティング(Routing = アメリカ英語読みはルーティングよりもラウティングが近い)は、シングルページアプリケーション(SPA)を作るための仕組みです。他のページに行く時に、フルにブラウザをリフレッシュしなくても済むアプリケーションを実現することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Routing is a system that allows creating Single-Page-Applications (SPA), i.e. applications that can go from one page to another without causing a full browser refresh.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T020138Z" creationid="shibukawa.yoshiki" creationdate="20150409T020138Z">
        <seg>ラウティング(Routing = アメリカ英語読みはルーティングよりもラウティングが近い)は、シングルページアプリケーション(SPA)を作るための仕組みです。他のページに行く時に、フルにブラウザをリフレッシュしなくても済むアプリケーションを実現することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Routing is single-page-application (SPA) friendly, and can be implemented using either <bpt i="0" x="0">&lt;c0&gt;</bpt>location.hash<ept i="0">&lt;/c0&gt;</ept>, HTML5 URL rewriting or <bpt i="1" x="1">&lt;c1&gt;</bpt>location.querystring<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153216Z" creationid="shibukawa.yoshiki" creationdate="20150414T153216Z">
        <seg>ラウトはシングルページアプリケーション(SPA)を実現しやすくする仕組みで、 <bpt i="0" x="0">&lt;c0&gt;</bpt>location.hash<ept i="0">&lt;/c0&gt;</ept>、HTML5のURL書き換え、<bpt i="1" x="1">&lt;c1&gt;</bpt>location.querystring<ept i="1">&lt;/c1&gt;</ept>のどれかの方法を使って実装できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Routing mode abstraction</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153317Z" creationid="shibukawa.yoshiki" creationdate="20150412T153317Z">
        <seg>ラウティングモードの抽象化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Running clean up code on route change</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152414Z" creationid="shibukawa.yoshiki" creationdate="20150414T152414Z">
        <seg>ラウト変更時に後処理コードを実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Safe-by-default templates</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T133820Z" creationid="shibukawa.yoshiki" creationdate="20150407T133820Z">
        <seg>デフォルト設定が安全側に振られたテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Safety</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135046Z" creationid="shibukawa.yoshiki" creationdate="20150407T135046Z">
        <seg>安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sample code</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134223Z" creationid="shibukawa.yoshiki" creationdate="20150407T134223Z">
        <seg>サンプルコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See "Signature" section for details.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235315Z" creationid="shibukawa.yoshiki" creationdate="20150412T235315Z">
        <seg>詳細についてはシグニチャのセクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m()<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> for more information on virtual elements.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013558Z" creationid="shibukawa.yoshiki" creationdate="20150410T013558Z">
        <seg>仮想エレメントについての詳細は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m()<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>のドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.component<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> for information on components.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135834Z" creationid="shibukawa.yoshiki" creationdate="20150502T135834Z">
        <seg>コンポーネントに関しては<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.component<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.deferred<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> for more information on promises.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180629Z" creationid="shibukawa.yoshiki" creationdate="20150415T180629Z">
        <seg>promiseについては<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.deferred<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="0" x="0">&lt;a0&gt;</bpt>subtree directives.html<ept i="0">&lt;/a0&gt;</ept> for more information.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160449Z" creationid="shibukawa.yoshiki" creationdate="20150413T160449Z">
        <seg>要塞については、<bpt i="0" x="0">&lt;a0&gt;</bpt>subtree directives.html<ept i="0">&lt;/a0&gt;</ept>を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>m.route.mode<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept> for the caveats of each implementation.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153242Z" creationid="shibukawa.yoshiki" creationdate="20150414T153242Z">
        <seg>それぞれの実装方法の詳細については、<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>m.route.mode<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See the <bpt i="0" x="0">&lt;a0&gt;</bpt>integration guide<ept i="0">&lt;/a0&gt;</ept> for more information.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125508Z" creationid="shibukawa.yoshiki" creationdate="20150413T125500Z">
        <seg>これについては<bpt i="0" x="0">&lt;a0&gt;</bpt>他のライブラリとの統合<ept i="0">&lt;/a0&gt;</ept>を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See the next section.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174214Z" creationid="shibukawa.yoshiki" creationdate="20150415T173510Z">
        <seg>次のセクションもご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Serialize data into querystring format</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153729Z" creationid="shibukawa.yoshiki" creationdate="20150412T153729Z">
        <seg>データをクエリー文字列フォーマットでシリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Serializes an object into its URI encoded querystring representation, following the same serialization conventions as <bpt i="0" x="0">&lt;a0&gt;</bpt>URI.js<ept i="0">&lt;/a0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170947Z" creationid="shibukawa.yoshiki" creationdate="20150414T170947Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>URI.js<ept i="0">&lt;/a0&gt;</ept>と同じシリアライズ規約を使い、オブジェクトをURIでエンコードされたクエリー文字列にシリアライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Serializing getter-setters</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133748Z" creationid="shibukawa.yoshiki" creationdate="20150414T133748Z">
        <seg>getter-setterのシリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Setting <bpt i="1" x="1">&lt;c1&gt;</bpt>context.retain = true<ept i="1">&lt;/c1&gt;</ept> in the element's config function allows the span to stay intact after a route change.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T134935Z" creationid="shibukawa.yoshiki" creationdate="20150413T134828Z">
        <seg>エレメントのconfig関数の中で<bpt i="1" x="1">&lt;c1&gt;</bpt>context.retain = true<ept i="1">&lt;/c1&gt;</ept>と設定すると、ラウトが変更されてもコストが高い(つもりの)spanタグを保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Setting strategy to none in any one of those handlers will not affect the redrawing strategy of other handlers (and remember that <bpt i="0" x="0">&lt;c0&gt;</bpt>strategy("none")<ept i="0">&lt;/c0&gt;</ept> has no effect on asynchronous redraws).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151229Z" creationid="shibukawa.yoshiki" creationdate="20150416T151229Z">
        <seg>この場合、１つのハンドラでnoneに戦略を変更しても、<bpt i="0" x="0">&lt;c0&gt;</bpt>strategy("none")<ept i="0">&lt;/c0&gt;</ept> は非同期の再描画に効果を与えないため、他のハンドラの再描画戦略に影響を与えることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Setting the <bpt i="0" x="0">&lt;c0&gt;</bpt>background<ept i="0">&lt;/c0&gt;</ept> option to <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> prevents a request from affecting redrawing.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T000224Z" creationid="shibukawa.yoshiki" creationdate="20150415T000224Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>background<ept i="0">&lt;/c0&gt;</ept>オプションを<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>に設定すると、リクエストが再描画のプロセスに干渉することはなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Signature</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235059Z" creationid="shibukawa.yoshiki" creationdate="20150412T235059Z">
        <seg>シグニチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similar, setting the value of attribute <bpt i="0" x="0">&lt;c0&gt;</bpt>readonly<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> is equivalent to removing the attribute in HTML.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153955Z" creationid="shibukawa.yoshiki" creationdate="20150413T153955Z">
        <seg>同様に<bpt i="0" x="0">&lt;c0&gt;</bpt>readonly<ept i="0">&lt;/c0&gt;</ept>属性に<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を設定すると、その属性をHTMLから取り除くのと同じ結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, <bpt i="2" x="2">&lt;c2&gt;</bpt>ContactForm<ept i="2">&lt;/c2&gt;</ept> can be used to both create new contacts as well as edit existing ones.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T010148Z" creationid="shibukawa.yoshiki" creationdate="20150502T010148Z">
        <seg>同様に<bpt i="2" x="2">&lt;c2&gt;</bpt>ContactForm<ept i="2">&lt;/c2&gt;</ept>も、新規の連絡先の作成と、既存の連絡先の編集の両方に利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since computer screens are not able to display changes faster than a frame, this optimization saves CPU cycles and helps UIs stay responsive even in the face of spammy data changes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T191712Z" creationid="shibukawa.yoshiki" creationdate="20150411T191712Z">
        <seg>コンピュータのスクリーンはフレーム以上の速度で表示することはできないため、この最適化によってCPUのサイクルを節約することができますし、大量のデータ変更に対してもUIの応答性を保つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since controllers can call model methods, it's possible for nested components to encapsulate asynchronous behavior.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093109Z" creationid="shibukawa.yoshiki" creationdate="20150502T093109Z">
        <seg>コントローラはモデルのメソッドを呼ぶことができますが、非同期の動作をカプセル化するのにネストされたコンポーネントを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Small API, small learning curve</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134049Z" creationid="shibukawa.yoshiki" creationdate="20150407T133432Z">
        <seg>小さくシンプルなAPIと、低い学習コスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>So calling <bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept> multiple times from a controller context increments the internal counter.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154446Z" creationid="shibukawa.yoshiki" creationdate="20150416T154446Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept>をコントローラのコンテキスト内で複数回呼ぶと、内部カウンターが増加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>So far, we've been using <bpt i="0" x="0">&lt;c0&gt;</bpt>m.render<ept i="0">&lt;/c0&gt;</ept> to manually redraw after we made a change to the data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161003Z" creationid="shibukawa.yoshiki" creationdate="20150408T161003Z">
        <seg>最初に紹介したときは、データを変更した後に手動で<bpt i="0" x="0">&lt;c0&gt;</bpt>m.render<ept i="0">&lt;/c0&gt;</ept>を呼び出して再描画を行わせていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Social Media</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135808Z" creationid="shibukawa.yoshiki" creationdate="20150407T135808Z">
        <seg>ソーシャルメディア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some asynchronous operations might need to affect redrawing both before and after their completion.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135833Z" creationid="shibukawa.yoshiki" creationdate="20150415T135833Z">
        <seg>再描画の操作によっては、呼び出し前と後の両方に再描画が必要になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some cases may not require a redraw upon completion of the asynchronous callbacks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135749Z" creationid="shibukawa.yoshiki" creationdate="20150415T135749Z">
        <seg>非同期のコールバックを待たずに再描画を行っても問題ないケースもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some of the older frameworks among the popular ones (out-of-the-box jQuery and Backbone, specifically) take a more procedural paradigm when it comes to the view layer; this means every action requires the developer to write custom view-level code to handle it.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014215Z" creationid="shibukawa.yoshiki" creationdate="20150420T014215Z">
        <seg>有名ないくつかの古いフレームワーク(jQueryやBackboneなどは特に)は、ビューのレイヤーに対しても、より手続き型寄りのパラダイムを採用しました。開発者が毎回、開発対象ごとにビューレベルのコードを手書きしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some services (e.g. Flickr) don't follow the convention of calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>callback<ept i="0">&lt;/c0&gt;</ept> parameter <bpt i="1" x="1">&lt;c1&gt;</bpt>callback<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235033Z" creationid="shibukawa.yoshiki" creationdate="20150414T234945Z">
        <seg>Flickrなどの一部のサービスは、<bpt i="0" x="0">&lt;c0&gt;</bpt>callback<ept i="0">&lt;/c0&gt;</ept>パラメータで指定された<bpt i="1" x="1">&lt;c1&gt;</bpt>callback<ept i="1">&lt;/c1&gt;</ept>を呼び出すというJSONPの規約に従っていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sometimes you only care about a particular condition in an event and want the event to not trigger a redraw if this condition is not met.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150101Z" creationid="shibukawa.yoshiki" creationdate="20150416T150101Z">
        <seg>イベント内の特定の条件について考慮した時に、その条件に合わなければ再描画を行いたくない、と思うこともよくあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Speaking from experience, it's generally difficult to reason about performance in Angular.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094802Z" creationid="shibukawa.yoshiki" creationdate="20150420T094745Z">
        <seg>経験から見ても、Angularのパフォーマンス向上させるのは難しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specific Framework Comparisons</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015024Z" creationid="shibukawa.yoshiki" creationdate="20150420T015024Z">
        <seg>特定のフレームワークとの比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stateful components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050605Z" creationid="shibukawa.yoshiki" creationdate="20150502T050605Z">
        <seg>ステートフルなコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stateless components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050557Z" creationid="shibukawa.yoshiki" creationdate="20150502T050557Z">
        <seg>ステートレスなコンポーネント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Steep performance degradation is a notoriously common issue in non-trivial Angular applications and there are several third party libraries which attempt to get around performance problems.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T094626Z" creationid="shibukawa.yoshiki" creationdate="20150420T094626Z">
        <seg>巨大なAngularのアプリケーションのパフォーマンスは厳しいものがあり、それに対応しようとするサードパーティ製のライブラリもいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subsequent parameters have no restrictions (e.g. <bpt i="1" x="1">&lt;c1&gt;</bpt>"this is a test"<ept i="1">&lt;/c1&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080042Z" creationid="shibukawa.yoshiki" creationdate="20150502T080042Z">
        <seg>それに続く引数(<bpt i="1" x="1">&lt;c1&gt;</bpt>"this is a test"<ept i="1">&lt;/c1&gt;</ept>)には制限がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subsequently, the <bpt i="2" x="2">&lt;c2&gt;</bpt>view<ept i="2">&lt;/c2&gt;</ept> function is called and will be called again anytime a redraw is required.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071921Z" creationid="shibukawa.yoshiki" creationdate="20150502T071921Z">
        <seg>その後、<bpt i="2" x="2">&lt;c2&gt;</bpt>view<ept i="2">&lt;/c2&gt;</ept>関数が再描画が必要になるたびに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtree Directives</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123430Z" creationid="shibukawa.yoshiki" creationdate="20150416T123430Z">
        <seg>サブツリーディレクティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtree directives</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015933Z" creationid="shibukawa.yoshiki" creationdate="20150416T015933Z">
        <seg>サブツリーディレクティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Summary</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161941Z" creationid="shibukawa.yoshiki" creationdate="20150408T161941Z">
        <seg>まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suppose we have a component called <bpt i="0" x="0">&lt;c0&gt;</bpt>ProjectList<ept i="0">&lt;/c0&gt;</ept> and the following data:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085647Z" creationid="shibukawa.yoshiki" creationdate="20150502T085647Z">
        <seg>下記のデータを持つ、<bpt i="0" x="0">&lt;c0&gt;</bpt>ProjectList<ept i="0">&lt;/c0&gt;</ept>と呼ばれるコンポーネントがあったとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>SweetJS requires a <bpt i="0" x="0">&lt;a0&gt;</bpt>NodeJS<ept i="0">&lt;/a0&gt;</ept> environment.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150037Z" creationid="shibukawa.yoshiki" creationdate="20150412T150037Z">
        <seg>SweetJSを実行するには<bpt i="0" x="0">&lt;a0&gt;</bpt>NodeJS<ept i="0">&lt;/a0&gt;</ept>環境が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Synchronous execution</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140153Z" creationid="shibukawa.yoshiki" creationdate="20150415T140153Z">
        <seg>同期実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Take it with a grain of salt.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015147Z" creationid="shibukawa.yoshiki" creationdate="20150420T015147Z">
        <seg>そのまま鵜呑みにせずに、参考程度にお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Template Converter</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013555Z" creationid="shibukawa.yoshiki" creationdate="20150417T013555Z">
        <seg>テンプレートコンバータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Test Summary</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135442Z" creationid="shibukawa.yoshiki" creationdate="20150407T135442Z">
        <seg>テスト結果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Testing</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154222Z" creationid="shibukawa.yoshiki" creationdate="20150412T154222Z">
        <seg>テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Testing the various parts of the component is trivial:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081601Z" creationid="shibukawa.yoshiki" creationdate="20150502T081546Z">
        <seg>コンポーネントのさまざまなパーツをテストするのは簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That organization pattern needlessly ties unrelated aspects of the application together and dilutes the clarity of modules.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015746Z" creationid="shibukawa.yoshiki" creationdate="20150421T015746Z">
        <seg>このようなパターンでアプリケーションを分けてしまうと、レイヤー間で不必要なコードの密結合が起きてしまいます。モジュールによる、MVC縦断の縦のつながりがわかりにくくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> / <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept> pair<ept i="0">&lt;/a0&gt;</ept> is designed to be "stacked", i.e. multiple asynchronous services can each call this pair of functions to indicate that they want the redrawing algorithm to wait for them to finish before a redraw occurs.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130550Z" creationid="shibukawa.yoshiki" creationdate="20150502T130550Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.startComputation<ept i="1">&lt;/c1&gt;</ept> / <bpt i="2" x="2">&lt;c2&gt;</bpt>m.endComputation<ept i="2">&lt;/c2&gt;</ept>のペア<ept i="0">&lt;/a0&gt;</ept>は「スタックされる」ように設計されています。例えば、複数の非同期サービスのそれぞれがこの呼出のペアを持っており、すべてのリクエストが完了するまで再描画を待たせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="5" x="5">&lt;a5&gt;</bpt>config's retain flag<ept i="5">&lt;/a5&gt;</ept> can be used to change how specific elements are redrawn when routes change.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150506T000509Z" creationid="shibukawa.yoshiki" creationdate="20150506T000509Z">
        <seg><bpt i="5" x="5">&lt;a5&gt;</bpt>configのretainフラグ<ept i="5">&lt;/a5&gt;</ept>を使うと、ラウト変更時に特定の要素を再描画するかどうかを指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactForm<ept i="0">&lt;/c0&gt;</ept> component is, as its name suggests, a form that allows us to edit the fields of a <bpt i="1" x="1">&lt;c1&gt;</bpt>Contact<ept i="1">&lt;/c1&gt;</ept> entity.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T001804Z" creationid="shibukawa.yoshiki" creationdate="20150502T001804Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ContactForm<ept i="0">&lt;/c0&gt;</ept>コンポーネントは、名前から推測できる通りで、<bpt i="1" x="1">&lt;c1&gt;</bpt>Contact<ept i="1">&lt;/c1&gt;</ept>エンティティのフィールドを編集するフォームを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactList<ept i="0">&lt;/c0&gt;</ept> component displays a table showing all the contact entities that are passed to it via the <bpt i="1" x="1">&lt;c1&gt;</bpt>contacts<ept i="1">&lt;/c1&gt;</ept> argument.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002420Z" creationid="shibukawa.yoshiki" creationdate="20150502T002420Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ContactList<ept i="0">&lt;/c0&gt;</ept>コンポーネントは、<bpt i="1" x="1">&lt;c1&gt;</bpt>contacts<ept i="1">&lt;/c1&gt;</ept>引数で渡されたすべての連絡先のエンティティを表形式で表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactList<ept i="0">&lt;/c0&gt;</ept> component's controller is marked as Observable, and the <bpt i="1" x="1">&lt;c1&gt;</bpt>save<ept i="1">&lt;/c1&gt;</ept> event handler in <bpt i="2" x="2">&lt;c2&gt;</bpt>ContactForm<ept i="2">&lt;/c2&gt;</ept> calls <bpt i="3" x="3">&lt;c3&gt;</bpt>Observable.trigger<ept i="3">&lt;/c3&gt;</ept> after saving.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021142Z" creationid="shibukawa.yoshiki" creationdate="20150502T021142Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ContactList<ept i="0">&lt;/c0&gt;</ept>コンポーネントのコントローラが監視対象としてマークして、その後<bpt i="2" x="2">&lt;c2&gt;</bpt>ContactForm<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>save<ept i="1">&lt;/c1&gt;</ept>イベントハンドラの中で、保存後に<bpt i="3" x="3">&lt;c3&gt;</bpt>Observable.trigger<ept i="3">&lt;/c3&gt;</ept>呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Observable<ept i="0">&lt;/c0&gt;</ept> object can be further refactored so that <bpt i="1" x="1">&lt;c1&gt;</bpt>trigger<ept i="1">&lt;/c1&gt;</ept> broadcasts to "channels", which controllers can subscribe to.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025105Z" creationid="shibukawa.yoshiki" creationdate="20150502T025105Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Observable<ept i="0">&lt;/c0&gt;</ept>(監視可能)オブジェクトは<bpt i="1" x="1">&lt;c1&gt;</bpt>trigger<ept i="1">&lt;/c1&gt;</ept>を使ってコントローラが購読している"channels"にブロードキャストするという方式にリファクタリングすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Observable<ept i="0">&lt;/c0&gt;</ept> object exposes two methods: <bpt i="1" x="1">&lt;c1&gt;</bpt>register<ept i="1">&lt;/c1&gt;</ept> which marks a controller as a Observable entity, and <bpt i="2" x="2">&lt;c2&gt;</bpt>trigger<ept i="2">&lt;/c2&gt;</ept> which reloads controllers marked by <bpt i="3" x="3">&lt;c3&gt;</bpt>register<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T020914Z" creationid="shibukawa.yoshiki" creationdate="20150502T020914Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Observable<ept i="0">&lt;/c0&gt;</ept>オブジェクトは2つのメソッドを提供しています。<bpt i="1" x="1">&lt;c1&gt;</bpt>register<ept i="1">&lt;/c1&gt;</ept>はコントローラのエンティティを監視対象のエンティティとして登録します。<bpt i="2" x="2">&lt;c2&gt;</bpt>trigger<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>register<ept i="3">&lt;/c3&gt;</ept>で登録されたコントローラをリロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>TodoList<ept i="0">&lt;/c0&gt;</ept> class is simply an alias of the native <bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151056Z" creationid="shibukawa.yoshiki" creationdate="20150407T151044Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>TodoList<ept i="0">&lt;/c0&gt;</ept>クラスは単に、標準の<bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept>クラスの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>attributes<ept i="0">&lt;/c0&gt;</ept> argument (i.e. the second parameter in the <bpt i="1" x="1">&lt;c1&gt;</bpt>m("div", {class: "container"}, "Hello")<ept i="1">&lt;/c1&gt;</ept> example) is meant to be used for attributes whose values we want to dynamically populate.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002101Z" creationid="shibukawa.yoshiki" creationdate="20150413T002101Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>m("div", {class: "container"}, "Hello")<ept i="1">&lt;/c1&gt;</ept>の2番目のパラメータの<bpt i="0" x="0">&lt;c0&gt;</bpt>attributes<ept i="0">&lt;/c0&gt;</ept>引数は、動的に変更する可能性のある属性を設定するのに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> attribute</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121555Z" creationid="shibukawa.yoshiki" creationdate="20150413T154833Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> function created by our factory only runs the initialization code if it hasn't already.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133749Z" creationid="shibukawa.yoshiki" creationdate="20150412T133749Z">
        <seg>このファクトリ関数で作成された<bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>関数は、初期化関数だけを実行します。ただし、すでに初期化済みの場合は何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> mechanism can also be used to put focus on form inputs, and call methods that would not be possible to execute via the regular attribute syntax.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T124432Z" creationid="shibukawa.yoshiki" creationdate="20150413T124432Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>の仕組みを使うと、入力フォームにフォーカスを移動したり、通常の属性文法では呼び出せないメソッドを呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> option can also be used to retrieve the <bpt i="1" x="1">&lt;c1&gt;</bpt>XMLHttpRequest<ept i="1">&lt;/c1&gt;</ept> instance for aborting the request.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182308Z" creationid="shibukawa.yoshiki" creationdate="20150414T182308Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>を通じて、<bpt i="1" x="1">&lt;c1&gt;</bpt>XMLHttpRequest<ept i="1">&lt;/c1&gt;</ept>のインスタンスに対して、リクエストの中断を行わせることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> option can be used to arbitrarily configure the native XMLHttpRequest instance and to access properties that would not be accessible otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182052Z" creationid="shibukawa.yoshiki" creationdate="20150414T182052Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>オプションを使って、ネイティブのXMLHttpRequestインスタンスの設定を任意に設定したり、他の方法ではアクセスできないプロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept> function is called <bpt i="1" x="1">&lt;e1&gt;</bpt>once<ept i="1">&lt;/e1&gt;</ept> when the component is rendered.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071828Z" creationid="shibukawa.yoshiki" creationdate="20150502T071828Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept>関数は、コンポーネントがレンダリングされる時に<bpt i="1" x="1">&lt;e1&gt;</bpt>一度だけ<ept i="1">&lt;/e1&gt;</ept>呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept> function is optional and defaults to an empty function <bpt i="1" x="1">&lt;c1&gt;</bpt>controller: function() {}<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072050Z" creationid="shibukawa.yoshiki" creationdate="20150502T072050Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept>関数はオプショナルです。デフォルト値は空の関数(<bpt i="1" x="1">&lt;c1&gt;</bpt>controller: function() {}<ept i="1">&lt;/c1&gt;</ept>)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>dashboard<ept i="0">&lt;/c0&gt;</ept> component in the example shows how a developer would consume the select2 component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045343Z" creationid="shibukawa.yoshiki" creationdate="20150502T045343Z">
        <seg>サンプルの<bpt i="0" x="0">&lt;c0&gt;</bpt>dashboard<ept i="0">&lt;/c0&gt;</ept>コンポーネントを見ると、どのようにselect2コンポーネントを使用するかが分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>errorCallback<ept i="0">&lt;/c0&gt;</ept> is called if <bpt i="1" x="1">&lt;c1&gt;</bpt>reject<ept i="1">&lt;/c1&gt;</ept> is called in the root <bpt i="2" x="2">&lt;c2&gt;</bpt>deferred<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175931Z" creationid="shibukawa.yoshiki" creationdate="20150415T175931Z">
        <seg>ルートの<bpt i="2" x="2">&lt;c2&gt;</bpt>deferred<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>reject<ept i="1">&lt;/c1&gt;</ept>が呼ばれると<bpt i="0" x="0">&lt;c0&gt;</bpt>errorCallback<ept i="0">&lt;/c0&gt;</ept>が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>extract<ept i="0">&lt;/c0&gt;</ept> method can be used to read metadata from HTTP response headers or the status field of an XMLHttpRequest.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175735Z" creationid="shibukawa.yoshiki" creationdate="20150414T175735Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>extract<ept i="0">&lt;/c0&gt;</ept>メソッドはHTTPレスポンスヘッダのメタデータや、XMLHttpRequestのステータスフィールドを読み込むのに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw.strategy<ept i="0">&lt;/c0&gt;</ept> getter-setter indicates how the next component redraw will occur.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T133408Z" creationid="shibukawa.yoshiki" creationdate="20150502T133408Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw.strategy<ept i="0">&lt;/c0&gt;</ept> getter-setterは次のコンポーネントの再描画をどのように行うかを設定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.mode<ept i="0">&lt;/c0&gt;</ept> defines which part of the URL to use for routing.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153703Z" creationid="shibukawa.yoshiki" creationdate="20150414T153703Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.mode<ept i="0">&lt;/c0&gt;</ept>は、URLのどの部分をラウトとして使うかを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.mode<ept i="0">&lt;/c0&gt;</ept> property defines which URL portion is used to implement the routing mechanism.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004211Z" creationid="shibukawa.yoshiki" creationdate="20150410T004211Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.mode<ept i="0">&lt;/c0&gt;</ept>プロパティを使うと、どのURLに対してラウティングの仕組みを実装するかを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> pair is designed to be "stacked", i.e. multiple asynchronous services can each call this pair of functions to indicate that they want the redrawing algorithm to wait for them to finish before a redraw occurs.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T114333Z" creationid="shibukawa.yoshiki" creationdate="20150502T114333Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>のペアは「スタックされる」ように設計されています。例えば、複数の非同期サービスのそれぞれがこの呼出のペアを持っており、すべてのリクエストが完了するまで再描画を待たせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>m.withAttr("value", todo.vm.description)<ept i="0">&lt;/c0&gt;</ept> call above returns a function that is the rough equivalent of this code:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T022246Z" creationid="shibukawa.yoshiki" creationdate="20150408T022246Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.withAttr("value", todo.vm.description)<ept i="0">&lt;/c0&gt;</ept>という関数呼びしは、次のコードに相当する関数を返り値として返します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>m.withAttr<ept i="0">&lt;/c0&gt;</ept> utility is a functional programming tool provided by Mithril to minimize the need for anonymous functions in the view.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T022141Z" creationid="shibukawa.yoshiki" creationdate="20150408T022141Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.withAttr<ept i="0">&lt;/c0&gt;</ept>はMithrilが提供する関数型プログラミングのためのツールで、ビューの内部で無名関数の使用頻度を下げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>onerror<ept i="0">&lt;/c0&gt;</ept> function can be safely replaced if the default error monitoring semantics are not desired.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T174815Z" creationid="shibukawa.yoshiki" creationdate="20150415T174815Z">
        <seg>もし標準のエラーをモニタリングする仕組みが期待に合わなければ、<bpt i="0" x="0">&lt;c0&gt;</bpt>onerror<ept i="0">&lt;/c0&gt;</ept>を安全に置き換えて使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>options<ept i="0">&lt;/c0&gt;</ept> parameter that was passed into <bpt i="1" x="1">&lt;c1&gt;</bpt>m.request<ept i="1">&lt;/c1&gt;</ept> call</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014232Z" creationid="shibukawa.yoshiki" creationdate="20150415T014232Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>options<ept i="0">&lt;/c0&gt;</ept>パラメータは、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.request<ept i="1">&lt;/c1&gt;</ept>呼び出し時に渡された引数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>promise<ept i="0">&lt;/c0&gt;</ept> object is actually a function - specifically, it's an <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.prop<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> getter-setter, which gets populated with the value returned by <bpt i="3" x="3">&lt;c3&gt;</bpt>successCallback<ept i="3">&lt;/c3&gt;</ept> if the promise is resolved successfully.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134828Z" creationid="shibukawa.yoshiki" creationdate="20150415T134828Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>promise<ept i="0">&lt;/c0&gt;</ept>は普通の関数です。具体的には<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.prop<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> getter-setterで、promiseが成功すると、<bpt i="3" x="3">&lt;c3&gt;</bpt>successCallback<ept i="3">&lt;/c3&gt;</ept>が返す値が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>successCallback<ept i="0">&lt;/c0&gt;</ept> is called if <bpt i="1" x="1">&lt;c1&gt;</bpt>resolve<ept i="1">&lt;/c1&gt;</ept> is called in the root <bpt i="2" x="2">&lt;c2&gt;</bpt>deferred<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175736Z" creationid="shibukawa.yoshiki" creationdate="20150415T175736Z">
        <seg>ルートの<bpt i="2" x="2">&lt;c2&gt;</bpt>deferred<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>resolve<ept i="1">&lt;/c1&gt;</ept>が呼ばれると<bpt i="0" x="0">&lt;c0&gt;</bpt>successCallback<ept i="0">&lt;/c0&gt;</ept>が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>then<ept i="0">&lt;/c0&gt;</ept> method returns another promise whose computations (if any) receive their inputs from the parent promise's computation.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175036Z" creationid="shibukawa.yoshiki" creationdate="20150415T175036Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>then<ept i="0">&lt;/c0&gt;</ept>メソッドは親のpromiseの計算結果を受け取る、別のpromiseを作って返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>view<ept i="0">&lt;/c0&gt;</ept> function does not create a DOM tree when called.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072341Z" creationid="shibukawa.yoshiki" creationdate="20150502T072341Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>view<ept i="0">&lt;/c0&gt;</ept>関数は使用されたタイミングではDOMツリーを作成することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>view<ept i="0">&lt;/c0&gt;</ept> has access to methods and properties that the controller chooses to expose in the returned object.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061901Z" creationid="shibukawa.yoshiki" creationdate="20150502T061901Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>view<ept i="0">&lt;/c0&gt;</ept>は、コントローラが公開すると決めたメソッドやプロパティにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>vm.add.bind(vm, vm.description)<ept i="0">&lt;/c0&gt;</ept> expression above returns a function that is equivalent to this code:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151435Z" creationid="shibukawa.yoshiki" creationdate="20150408T151435Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>vm.add.bind(vm, vm.description)<ept i="0">&lt;/c0&gt;</ept>という式は、次の式と等価です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="13" x="13">&lt;c13&gt;</bpt>then<ept i="13">&lt;/c13&gt;</ept> method returns a child promise, which, itself, can have more child promises, recursively.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134713Z" creationid="shibukawa.yoshiki" creationdate="20150415T134645Z">
        <seg><bpt i="13" x="13">&lt;c13&gt;</bpt>then<ept i="13">&lt;/c13&gt;</ept>メソッドは子供のpromiseを返します。この子のpromiseにもさらに子のpromiseを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>onunload<ept i="2">&lt;/c2&gt;</ept> event is called if an instantiated component is removed from a virtual element tree via a redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092640Z" creationid="shibukawa.yoshiki" creationdate="20150502T092640Z">
        <seg>インスタンス化されたコンポーネントが仮想エレメントツリーから削除されるときに<bpt i="2" x="2">&lt;c2&gt;</bpt>onunload<ept i="2">&lt;/c2&gt;</ept>イベントが呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>promise<ept i="4">&lt;/c4&gt;</ept> property is the root of the promise tree.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134134Z" creationid="shibukawa.yoshiki" creationdate="20150415T134134Z">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>promise<ept i="4">&lt;/c4&gt;</ept>プロパティは、promise木のルートです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Auto-Redrawing System</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140901Z" creationid="shibukawa.yoshiki" creationdate="20150407T140901Z">
        <seg>自動再描画システム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Auto-Redrawing System - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183333Z" creationid="shibukawa.yoshiki" creationdate="20150411T183333Z">
        <seg>自動再描画システム - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The CSS selector syntax (e.g. <bpt i="0" x="0">&lt;c0&gt;</bpt>a#google.external[href='http://google.com']<ept i="0">&lt;/c0&gt;</ept>) is meant to be used for declaring static attributes in the element, i.e. attribute values that don't change dynamically when the user interacts with the app.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T001946Z" creationid="shibukawa.yoshiki" creationdate="20150413T001946Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a#google.external[href='http://google.com']<ept i="0">&lt;/c0&gt;</ept>)のようなCSSセレクタ文法は、エレメントの静的なアトリビュートの定義で使用します。静的というのはアプリケーションの中で動的に変更されることがない要素になるという意味です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The DOM element that corresponds to virtual element defined by the <bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155036Z" creationid="shibukawa.yoshiki" creationdate="20150413T155036Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept>呼び出しで定義された仮想エレメントに対応するDOMエレメントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The HTTP method.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002047Z" creationid="shibukawa.yoshiki" creationdate="20150415T002047Z">
        <seg>HTTPのメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The TemperatureConverter controller never stores the value.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081502Z" creationid="shibukawa.yoshiki" creationdate="20150502T081502Z">
        <seg>TemperatureConverterコントローラは値を保持することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Todo class API is reusable and unit-test friendly, and in addition, it's a plain-vanilla Javascript class, and so has almost no framework-specific learning curve.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T234500Z" creationid="shibukawa.yoshiki" creationdate="20150408T234500Z">
        <seg>TodoクラスのAPIは再利用可能で、ユニットテストが容易です。また、プレーンなJavaScriptのクラスであるため、フレームワーク特有の学習は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The URL to request.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T002200Z" creationid="shibukawa.yoshiki" creationdate="20150415T002200Z">
        <seg>リクエストを送るURL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The XMLHttpRequest instance.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014203Z" creationid="shibukawa.yoshiki" creationdate="20150415T014203Z">
        <seg>XMLHttpRequestのインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The ability to "cast" the response to a class of your choice</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014452Z" creationid="shibukawa.yoshiki" creationdate="20150410T014452Z">
        <seg>レスポンスを好きなクラスにキャストする機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The ability to get an early reference to a container that will hold the asynchronous response</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014404Z" creationid="shibukawa.yoshiki" creationdate="20150410T014347Z">
        <seg>非同期のレスポンスが後で格納されるコンテンナを事前に参照しておく機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The ability to handle arguments in the controller is useful for setting up the initial state for a component whose state depends on input data:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084456Z" creationid="shibukawa.yoshiki" creationdate="20150502T084456Z">
        <seg>コントローラ内で引数を持てる機能は、コンポーネントの初期値のセットアップに便利です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The ability to queue operations to be performed after the asynchronous request completes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014429Z" creationid="shibukawa.yoshiki" creationdate="20150410T014429Z">
        <seg>非同期のリクエストが完了した後に実行される操作をキューに貯めておく機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The ability to unwrap data in a response that includes metadata properties</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014517Z" creationid="shibukawa.yoshiki" creationdate="20150410T014517Z">
        <seg>メタデータのプロパティを含むレスポンスを展開する機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The auto-redrawing system in Mithril is not affected by changes in values of <bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept> getter-setters.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153954Z" creationid="shibukawa.yoshiki" creationdate="20150416T153954Z">
        <seg>Mithrilの自動再描画システムは、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept> getter-setterの値の変更では何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The basic usage pattern for <bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept> returns an <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.prop<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> getter-setter, which is populated when the AJAX request completes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014645Z" creationid="shibukawa.yoshiki" creationdate="20150410T014645Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.request<ept i="0">&lt;/c0&gt;</ept>を通常の使用法で使うと、AJAXのリクエストが完了した後に結果が格納される<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.prop<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> getter-setterを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The biggest difference between Ember and Mithril is summarized in the Architecture section above: Ember's comprehensiveness comes at the cost of a steep learning curve and a high degree of vendor lock-in.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T095436Z" creationid="shibukawa.yoshiki" creationdate="20150420T095436Z">
        <seg>EmberとMithrilの一番大きな違いは、このアーキテクチャの違いに収束します。広範囲に渡るため、急峻なラーニングカーブを持ち、幅広くベンダーにロックインされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The button calls the <bpt i="0" x="0">&lt;c0&gt;</bpt>todo.vm.add<ept i="0">&lt;/c0&gt;</ept> method when clicked.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153858Z" creationid="shibukawa.yoshiki" creationdate="20150408T153858Z">
        <seg>ボタンが押されると、<bpt i="0" x="0">&lt;c0&gt;</bpt>todo.vm.add<ept i="0">&lt;/c0&gt;</ept>メソッドが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The callbacks for this promise receive as a parameter an Array containing the values of all the input promises</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T181118Z" creationid="shibukawa.yoshiki" creationdate="20150415T181118Z">
        <seg>このpromiseのレシーバーは、入力のメソッドのすべての値を持つ配列を引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The checkboxes save their value to the <bpt i="0" x="0">&lt;c0&gt;</bpt>task.done<ept i="0">&lt;/c0&gt;</ept> getter setter.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T160629Z" creationid="shibukawa.yoshiki" creationdate="20150408T160629Z">
        <seg>チェックボックスは値を<bpt i="0" x="0">&lt;c0&gt;</bpt>task.done<ept i="0">&lt;/c0&gt;</ept> getter setterに保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code above defines a view-model object called <bpt i="0" x="0">&lt;c0&gt;</bpt>vm<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T162019Z" creationid="shibukawa.yoshiki" creationdate="20150407T162019Z">
        <seg>上記のコードは、<bpt i="0" x="0">&lt;c0&gt;</bpt>vm<ept i="0">&lt;/c0&gt;</ept>という名前のビュー・モデルオブジェクトを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code bound to the <bpt i="0" x="0">&lt;c0&gt;</bpt>onchange<ept i="0">&lt;/c0&gt;</ept> can be read like this: "with the attribute value, set todo.vm.description".</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021305Z" creationid="shibukawa.yoshiki" creationdate="20150408T021305Z">
        <seg>このコードは<bpt i="0" x="0">&lt;c0&gt;</bpt>onchange<ept i="0">&lt;/c0&gt;</ept>に結び付けれており、「valueの属性の値を, todo.vm.descriptionに設定」するという意味になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The complete view looks like this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153552Z" creationid="shibukawa.yoshiki" creationdate="20150408T153552Z">
        <seg>完成したviewは次のようなコードになっています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The data to unwrap</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013000Z" creationid="shibukawa.yoshiki" creationdate="20150415T013000Z">
        <seg>unwrapするデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default value (if this parameter is falsy) is <bpt i="0" x="0">&lt;c0&gt;</bpt>JSON.parse<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013238Z" creationid="shibukawa.yoshiki" creationdate="20150415T013203Z">
        <seg>この設定がfalsyな値だったときのデフォルト動作は、<bpt i="0" x="0">&lt;c0&gt;</bpt>JSON.parse<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default value (if this parameter is falsy) is <bpt i="0" x="0">&lt;c0&gt;</bpt>JSON.stringify<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013129Z" creationid="shibukawa.yoshiki" creationdate="20150415T013129Z">
        <seg>この設定がfalsyな値だったときのデフォルト動作は、<bpt i="0" x="0">&lt;c0&gt;</bpt>JSON.stringify<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default value (if this parameter is falsy) is the identity function <bpt i="0" x="0">&lt;c0&gt;</bpt>function(value) {return value}<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012744Z" creationid="shibukawa.yoshiki" creationdate="20150415T012744Z">
        <seg>この設定がfalsyな値だったときのデフォルトの動作は、<bpt i="0" x="0">&lt;c0&gt;</bpt>function(value) {return value}<ept i="0">&lt;/c0&gt;</ept>という関数と等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default value is "search".</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004843Z" creationid="shibukawa.yoshiki" creationdate="20150410T004843Z">
        <seg>デフォルトは"search"です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The deferred object can then <bpt i="0" x="0">&lt;e0&gt;</bpt>apply<ept i="0">&lt;/e0&gt;</ept> a value by calling either <bpt i="1" x="1">&lt;c1&gt;</bpt>resolve<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>reject<ept i="2">&lt;/c2&gt;</ept>, which then dispatches the value to be processed to the computation tree.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T133747Z" creationid="shibukawa.yoshiki" creationdate="20150415T133718Z">
        <seg>deferredは、<bpt i="1" x="1">&lt;c1&gt;</bpt>resolve<ept i="1">&lt;/c1&gt;</ept>もしくは<bpt i="2" x="2">&lt;c2&gt;</bpt>reject<ept i="2">&lt;/c2&gt;</ept>を呼び出すことで、値を<bpt i="0" x="0">&lt;e0&gt;</bpt>適用<ept i="0">&lt;/e0&gt;</ept>することができます。その値は計算木に渡って処理されていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The deferred object returned by <bpt i="0" x="0">&lt;c0&gt;</bpt>m.deferred<ept i="0">&lt;/c0&gt;</ept> has two methods: <bpt i="1" x="1">&lt;c1&gt;</bpt>resolve<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>reject<ept i="2">&lt;/c2&gt;</ept>, and one property called <bpt i="3" x="3">&lt;c3&gt;</bpt>promise<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134006Z" creationid="shibukawa.yoshiki" creationdate="20150415T134006Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.deferred<ept i="0">&lt;/c0&gt;</ept>関数が返すdeferredオブジェクトは、<bpt i="1" x="1">&lt;c1&gt;</bpt>resolve<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>reject<ept i="2">&lt;/c2&gt;</ept>の2つのメソッドと、<bpt i="3" x="3">&lt;c3&gt;</bpt>promise<ept i="3">&lt;/c3&gt;</ept>と呼ばれるプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The dependency injector</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045846Z" creationid="shibukawa.yoshiki" creationdate="20150412T154242Z">
        <seg>依存性注入(Dependency Injection)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The description gets crossed out via CSS if the task is marked as done.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T160832Z" creationid="shibukawa.yoshiki" creationdate="20150408T160832Z">
        <seg>タスクが完了したとマークされると、CSSを通じて説明が消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The deserialized object</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140000Z" creationid="shibukawa.yoshiki" creationdate="20150502T140000Z">
        <seg>デシリアライズしたオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The difference with the modified version is that <bpt i="0" x="0">&lt;c0&gt;</bpt>add<ept i="0">&lt;/c0&gt;</ept> no longer takes an argument.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152436Z" creationid="shibukawa.yoshiki" creationdate="20150408T152436Z">
        <seg>変更前のコードと異なっているのは<bpt i="0" x="0">&lt;c0&gt;</bpt>add<ept i="0">&lt;/c0&gt;</ept>メソッドの引数がなくなった点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The difference, aside from avoiding an anonymous function, is that the <bpt i="0" x="0">&lt;c0&gt;</bpt>m.withAttr<ept i="0">&lt;/c0&gt;</ept> idiom also takes care of catching the correct event target and selecting the appropriate source of the data - i.e. whether it should come from a Javascript property or from <bpt i="1" x="1">&lt;c1&gt;</bpt>DOMElement::getAttribute()<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151145Z" creationid="shibukawa.yoshiki" creationdate="20150408T151145Z">
        <seg>無名関数の使用を避ける以外の違いとしては、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.withAttr<ept i="0">&lt;/c0&gt;</ept>を使うと、正しいイベントターゲットや、適切なデータソースを選んでくれます。例えば、その入力ソースがJavaScriptのプロパティか、<bpt i="1" x="1">&lt;c1&gt;</bpt>DOMElement::getAttribute()<ept i="1">&lt;/c1&gt;</ept>かといった違いを識別して、適切な動作をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The different between <bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.render<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> is that a component rendered via <bpt i="3" x="3">&lt;c3&gt;</bpt>m.mount<ept i="3">&lt;/c3&gt;</ept> auto-redraws automatically when event handlers are triggered, whereas components rendered via <bpt i="4" x="4">&lt;c4&gt;</bpt>m.render<ept i="4">&lt;/c4&gt;</ept> do not.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125206Z" creationid="shibukawa.yoshiki" creationdate="20150502T125206Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.render<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>の違いは、<bpt i="3" x="3">&lt;c3&gt;</bpt>m.mount<ept i="3">&lt;/c3&gt;</ept>の場合は自動再描画システムがイベントハンドラから起動されるが、<bpt i="4" x="4">&lt;c4&gt;</bpt>m.render<ept i="4">&lt;/c4&gt;</ept>は起動しない点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The easiest way to polyfill these features is to include this script:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014737Z" creationid="shibukawa.yoshiki" creationdate="20150417T014614Z">
        <seg>次のスクリプト(polyfillと呼ばれる互換性向上コード)を読み込ませるのがもっとも簡単な補完方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The effort to make the table paginated, searchable or filterable can improve the user experience in addition to solving the performance problem both on redraws and on initial page load.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143606Z" creationid="shibukawa.yoshiki" creationdate="20150412T143606Z">
        <seg>テーブルをページ分割したり、ソートやフィルタ可能にすると、ユーザエクスペリエンスが向上するだけでなく、再描画と初期のページロードの両方のパフォマンスの問題が解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The end result is that Mithril waits for all requests to complete before attempting to redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154538Z" creationid="shibukawa.yoshiki" creationdate="20150416T154538Z">
        <seg>すべてのリクエストが完了するのを待って、Mithrilは再描画を行おうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The end result is that you can call <bpt i="6" x="6">&lt;c6&gt;</bpt>m.request<ept i="6">&lt;/c6&gt;</ept> and other integrated data services seamlessly, and Mithril will wait for all of the asynchronous operations to complete before attempting to redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190821Z" creationid="shibukawa.yoshiki" creationdate="20150411T190821Z">
        <seg>これによって、<bpt i="6" x="6">&lt;c6&gt;</bpt>m.request<ept i="6">&lt;/c6&gt;</ept>や他のデータサービスとの統合をシームレスに行えるようになっています。Mithrilはすべての非同期操作が完了するのをまってから再描画を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines three routes, to be rendered in <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;body&gt;<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002804Z" creationid="shibukawa.yoshiki" creationdate="20150410T002804Z">
        <seg>次のサンプルは、&lt;body&gt;のレンダリングをする、3つのラウトを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows a contrived redraw counter.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125842Z" creationid="shibukawa.yoshiki" creationdate="20150413T125842Z">
        <seg>次のサンプルは、再描画のカウントを表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows a convoluted series of AJAX requests implemented with a third party library.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010751Z" creationid="shibukawa.yoshiki" creationdate="20150412T010751Z">
        <seg>次のサンプルには、サードパーティライブラリを使った複雑に入り組んだAJAXリクエストのかたまりがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows a route that takes a <bpt i="0" x="0">&lt;c0&gt;</bpt>userID<ept i="0">&lt;/c0&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003111Z" creationid="shibukawa.yoshiki" creationdate="20150410T003111Z">
        <seg>次のサンプルは<bpt i="0" x="0">&lt;c0&gt;</bpt>userID<ept i="0">&lt;/c0&gt;</ept>パラメータを取るラウトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows a route that takes an <bpt i="0" x="0">&lt;c0&gt;</bpt>userID<ept i="0">&lt;/c0&gt;</ept> parameter</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153431Z" creationid="shibukawa.yoshiki" creationdate="20150414T153431Z">
        <seg>次のサンプルは<bpt i="0" x="0">&lt;c0&gt;</bpt>userID<ept i="0">&lt;/c0&gt;</ept>パラメータを取るラウトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows a simple component that integrates with the <bpt i="0" x="0">&lt;a0&gt;</bpt>select2 library<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021607Z" creationid="shibukawa.yoshiki" creationdate="20150412T014035Z">
        <seg>次のサンプルは、<bpt i="0" x="0">&lt;a0&gt;</bpt>select2ライブラリ<ept i="0">&lt;/a0&gt;</ept>(jQuery用の拡張版&lt;select&gt;タグを提供するライブラリ)を統合した、シンプルなコンポーネントの例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows a variation of the contacts app where <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactForm<ept i="0">&lt;/c0&gt;</ept> is responsible for saving.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T113524Z" creationid="shibukawa.yoshiki" creationdate="20150502T030623Z">
        <seg>次のサンプルは、連絡先アプリの別バージョンで、<bpt i="0" x="0">&lt;c0&gt;</bpt>ContactForm<ept i="0">&lt;/c0&gt;</ept>が保存の責務を担っているバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows how to configure a request where the server expects requests to have a <bpt i="0" x="0">&lt;c0&gt;</bpt>Content-Type: application/json<ept i="0">&lt;/c0&gt;</ept> header</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182219Z" creationid="shibukawa.yoshiki" creationdate="20150414T182219Z">
        <seg>下記の例は、サーバがリクエストとして<bpt i="0" x="0">&lt;c0&gt;</bpt>Content-Type: application/json<ept i="0">&lt;/c0&gt;</ept>ヘッダを期待しているときに、それを行うための方法を示したサンプルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows how to receive a plain string from a txt file.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T175346Z" creationid="shibukawa.yoshiki" creationdate="20150410T175346Z">
        <seg>次のサンプルはテキストファイルをそのままプレーンな文字列として受ける取る方法を紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows how to use a SubtreeDirective object to create a static header that doesn't incur diff costs once it has been rendered.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124343Z" creationid="shibukawa.yoshiki" creationdate="20150416T124343Z">
        <seg>下記の例は静的なヘッダーに対してサブツリーディレクティブをどのように使用するかのサンプルです。このようにすることで、一度レンダリングされた後は差分検出のコストが発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The examples in this site usually conflate different MVC layers together for the sake of readability, but normally it's recommended that each layer on a module be in different files.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015128Z" creationid="shibukawa.yoshiki" creationdate="20150421T015128Z">
        <seg>このサイトのサンプルは、読みやすさのために異なるMVCレイヤーを1つのファイルにまとめていますが、レイヤーごとにファイルを分割するのが推奨されるスタイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The exception monitor</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015810Z" creationid="shibukawa.yoshiki" creationdate="20150415T015810Z">
        <seg>例外モニタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The existence of the component only becomes known to the diff engine at the time when the template is rendered.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093533Z" creationid="shibukawa.yoshiki" creationdate="20150502T093533Z">
        <seg>差分検知エンジンは、テンプレートをレンダリングする時にのみ、コンポーネントの存在を検知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first and most obvious thing you may have noticed in the view layer is that the view is not written in HTML.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013054Z" creationid="shibukawa.yoshiki" creationdate="20150409T013054Z">
        <seg>これがもっともはっきりと気づいてもらいやすい点が、ビューがHTMLに書かれていないという点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first parameter after the component object is meant to be used as an attribute map and should be an object (e.g. <bpt i="0" x="0">&lt;c0&gt;</bpt>{name: "world"}<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T080026Z" creationid="shibukawa.yoshiki" creationdate="20150502T080026Z">
        <seg>コンポーネントオブジェクトの後の最初のパラメータは属性のマップで、<bpt i="0" x="0">&lt;c0&gt;</bpt>{name: "world"}<ept i="0">&lt;/c0&gt;</ept>などのオブジェクトを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example illustrates this pattern:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081054Z" creationid="shibukawa.yoshiki" creationdate="20150502T081054Z">
        <seg>次のサンプルはこのパターンを説明しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following topics are good places to start a deeper dive.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T015805Z" creationid="shibukawa.yoshiki" creationdate="20150409T015805Z">
        <seg>Mithrilについてより深く知りたい場合には次のトピックが良い出発点になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The goal of the framework is to make application code discoverable, readable and maintainable, and hopefully help you become an even better developer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141806Z" creationid="shibukawa.yoshiki" creationdate="20150407T141806Z">
        <seg>このフレームワークのゴールは、アプリケーションコードの探索しやすさ、読みやすさ、メンテナンス性を向上させ、あなたがすばらしい開発者になる手助けをすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The implications of saving are left to the parent component to handle.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T010840Z" creationid="shibukawa.yoshiki" creationdate="20150502T010840Z">
        <seg>保存の操作については、親のコンポーネントに残してあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initialization code defines a <bpt i="0" x="0">&lt;c0&gt;</bpt>change<ept i="0">&lt;/c0&gt;</ept> event handler.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134001Z" creationid="shibukawa.yoshiki" creationdate="20150412T134001Z">
        <seg>初期化コードは<bpt i="0" x="0">&lt;c0&gt;</bpt>change<ept i="0">&lt;/c0&gt;</ept>イベントハンドラを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key for each child must be unique among a list of sibling DOM elements, but it does not need to be globally unique.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142205Z" creationid="shibukawa.yoshiki" creationdate="20150413T142205Z">
        <seg>リストの子の兄弟のDOMエレメントのキーはユニークでなければなりませんが、アプリケーション全体でグローバルにユニークである必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key is defined in the <bpt i="1" x="1">&lt;c1&gt;</bpt>li<ept i="1">&lt;/c1&gt;</ept>, which is the closest element to the <bpt i="2" x="2">&lt;c2&gt;</bpt>items<ept i="2">&lt;/c2&gt;</ept> array, not directly on the <bpt i="3" x="3">&lt;c3&gt;</bpt>input<ept i="3">&lt;/c3&gt;</ept>, even though we want to track focus on the input.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T143904Z" creationid="shibukawa.yoshiki" creationdate="20150413T143904Z">
        <seg>キーは、<bpt i="2" x="2">&lt;c2&gt;</bpt>items<ept i="2">&lt;/c2&gt;</ept>配列に一番近いエレメントの<bpt i="1" x="1">&lt;c1&gt;</bpt>li<ept i="1">&lt;/c1&gt;</ept>エレメントに設定します。フォーカスを維持したいのは<bpt i="3" x="3">&lt;c3&gt;</bpt>input<ept i="3">&lt;/c3&gt;</ept>エレメントですが、このエレメントに直接キーを設定することはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The list can have todo items added to it via the <bpt i="1" x="1">&lt;c1&gt;</bpt>push<ept i="1">&lt;/c1&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151931Z" creationid="shibukawa.yoshiki" creationdate="20150407T151931Z">
        <seg>配列の方は<bpt i="1" x="1">&lt;c1&gt;</bpt>push<ept i="1">&lt;/c1&gt;</ept>メソッドを使ってTodoの項目を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The lowest level rendering method</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153918Z" creationid="shibukawa.yoshiki" creationdate="20150412T153918Z">
        <seg>低レベルのレンダリングの方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The macro takes regular Mithril templates like the one below:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144911Z" creationid="shibukawa.yoshiki" creationdate="20150412T144911Z">
        <seg>このマクロは下記のような通常のMithrilのテンプレートを受け取ります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The main difference between Angular templates and Mithril templates is that Angular templates follow the tradition of being defined in HTML.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025135Z" creationid="shibukawa.yoshiki" creationdate="20150420T025135Z">
        <seg>一番大きな違いは、AngularとMithrilのテンプレートです。AngularのテンプレートはHTMLの中に定義するという、伝統的な方法を取っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The methods can be called to dispatch a value to the promise tree.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T134114Z" creationid="shibukawa.yoshiki" creationdate="20150415T134114Z">
        <seg>これらのメソッドを呼ぶと、promise木に値を送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The mock object used by Mithril for its own test suite <bpt i="2" x="2">&lt;a2&gt;</bpt>can be found in the development repo<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160830Z" creationid="shibukawa.yoshiki" creationdate="20150416T160830Z">
        <seg>Mithril自身がテストで使っているモックは<bpt i="2" x="2">&lt;a2&gt;</bpt>開発リポジトリ<ept i="2">&lt;/a2&gt;</ept>の中にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The most interesting component is <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactsWidget<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002616Z" creationid="shibukawa.yoshiki" creationdate="20150502T002616Z">
        <seg>もっとも興味深いコンポーネントは<bpt i="0" x="0">&lt;c0&gt;</bpt>ContactsWidget<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The most relevant difference is that Vue uses <bpt i="0" x="0">&lt;a0&gt;</bpt>browser features that don't work (and cannot be made to work) in Internet Explorer 8 and lower<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110137Z" creationid="shibukawa.yoshiki" creationdate="20150420T110137Z">
        <seg>Mithrilともっとも異なる点は、<bpt i="0" x="0">&lt;a0&gt;</bpt>ViewがInernet Explorer 8以下では動作せず、代替のない機能を利用している点です<ept i="0">&lt;/a0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The most visible difference between React and Mithril is that React's <bpt i="0" x="0">&lt;e0&gt;</bpt>JSX<ept i="0">&lt;/e0&gt;</ept> syntax does not run natively in the browser, whereas Mithril's uncompiled templates do.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T100217Z" creationid="shibukawa.yoshiki" creationdate="20150420T100045Z">
        <seg>見た目で一番大きくことなるのは、ブラウザ上でそのままは動作しない<bpt i="0" x="0">&lt;e0&gt;</bpt>JSX<ept i="0">&lt;/e0&gt;</ept>という文法です。Mithrilのコンパイルしていないテンプレートはそのまま動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The name of a route parameter</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170816Z" creationid="shibukawa.yoshiki" creationdate="20150414T170816Z">
        <seg>ラウトパラメータの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The name of the querystring key that defines the name of the callback function to be called by the response.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014619Z" creationid="shibukawa.yoshiki" creationdate="20150415T014619Z">
        <seg>レスポンス受け取るコールバック関数を定義する、クエリー文字列の名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new strategy will apply to the next scheduled redraw, if any.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T130855Z" creationid="shibukawa.yoshiki" creationdate="20150416T130855Z">
        <seg>これを設定すると、次にスケジュールされている再描画の時点から、新しい方法が適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next step is to write a view so users can interact with the application.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040836Z" creationid="shibukawa.yoshiki" creationdate="20150502T040836Z">
        <seg>次に、ユーザとアプリケーションがインタラクションするためのビューを書きましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The observer pattern</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T180155Z" creationid="shibukawa.yoshiki" creationdate="20150501T180155Z">
        <seg>オブザーバパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The only reason I talked about partial application here was to make you aware of that technique, since it becomes useful when dealing with parameterized event handlers.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152718Z" creationid="shibukawa.yoshiki" creationdate="20150408T152718Z">
        <seg>部分適用を使って説明したのは、単にこのようなテクニックが使えるということを紹介する目的でした。これを使うと、パラメータを持つイベントハンドラの可能性が広がります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The only reasonable course of action to prevent the potential null reference exceptions in this case is to add the existence check in the source code.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172853Z" creationid="shibukawa.yoshiki" creationdate="20150415T172853Z">
        <seg>このような問題を防ぐ唯一の方法は、null参照例外が発生する可能性のあるすべての箇所に存在チェックを追加する方法しかありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The optional <bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept> function creates an object that may be used in the following recommended ways:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061513Z" creationid="shibukawa.yoshiki" creationdate="20150502T061513Z">
        <seg>オプションの<bpt i="0" x="0">&lt;c0&gt;</bpt>controller<ept i="0">&lt;/c0&gt;</ept>関数は、次のように使われるオブジェクトを作成することが期待されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The other side of the coin is still supported: if a developer needs to signal an exceptional condition within a promise callback, they can manually throw a <bpt i="0" x="0">&lt;c0&gt;</bpt>new Error<ept i="0">&lt;/c0&gt;</ept> (for example, if a validation rule failed, and there should be an error message displayed to the user).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173349Z" creationid="shibukawa.yoshiki" creationdate="20150415T173349Z">
        <seg>もちろん、コインの反対側の標準のPromise/A+の仕様もサポートされています。バリデーションの失敗があってエラーメッセージを表示しなければならない場合など、開発者がpromiseのコールバックの中で例外の発生を知らせなければならない場合は、<bpt i="0" x="0">&lt;c0&gt;</bpt>new Error<ept i="0">&lt;/c0&gt;</ept>で作成した例外を投げて、それを受け取ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The params in this doc refer to properties of the `ctrl` argument
@param {Object} data - the data with which to populate the &lt;option&gt; list
@param {number} value - the id of the item in `data` that we want to select
@param {function(Object id)} onchange - the event handler to call when the selection changes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T021530Z" creationid="shibukawa.yoshiki" creationdate="20150412T014315Z">
        <seg>このドキュメントのパラメータは、`ctrl`引数のプロパティです
@param {Object} data - &lt;option&gt;リストを実行したいデータ
@param {number} value - `data`内の、選択したいアイテムのID
@param {function(Object id)} onchange - 選択が変更された時に呼び出されるイベントハンドラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The performance tests in the homepage show execution times for parsing and evaluation of Mithril's code, compared to some popular frameworks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113646Z" creationid="shibukawa.yoshiki" creationdate="20150417T113646Z">
        <seg>ホームページのパフォーマンステストでは、Mithrilと他の有名なフレームワークで、コードのパースと評価にかかる時間の比較をしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The promise object is actually a getter-setter function that gets populated when the promise is fulfilled.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135159Z" creationid="shibukawa.yoshiki" creationdate="20150415T135159Z">
        <seg>promiseオブジェクトは実際のgetter-setter関数であるため、promiseが果たされると、値が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The promise of the deferred object that is resolved when all input promises have been resolved</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180934Z" creationid="shibukawa.yoshiki" creationdate="20150415T180934Z">
        <seg>入力に渡されたすべてのpromiseが解決したときに解決されるpromise。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The reason Mithril waits for all asynchronous services to complete before redrawing is to avoid wasteful browser repaints, and to minimize the need for null reference checks in templates.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154844Z" creationid="shibukawa.yoshiki" creationdate="20150416T154844Z">
        <seg>Mithrilがすべての非同期サービスの待ち合わせをするのは、何度もムダなブラウザ再描画を行わないようにしたり、テンプレート内でnull参照チェックを行う回数を減らす、という理由によるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The response object (or the child items if this object is an Array) will be passed as a parameter to the class constructor defined by <bpt i="0" x="0">&lt;c0&gt;</bpt>type<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013750Z" creationid="shibukawa.yoshiki" creationdate="20150415T013750Z">
        <seg>レスポンスオブジェクト、もしくはレスポンスが配列の場合はその子供は、<bpt i="0" x="0">&lt;c0&gt;</bpt>type<ept i="0">&lt;/c0&gt;</ept>で定義されているクラスコンストラクタに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The rest of the code can be implemented using idioms we already covered.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153535Z" creationid="shibukawa.yoshiki" creationdate="20150408T153535Z">
        <seg>残りのコードは、これまで説明してきたテクニックで書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return value of the <bpt i="3" x="3">&lt;c3&gt;</bpt>controller<ept i="3">&lt;/c3&gt;</ept> function is passed to the <bpt i="4" x="4">&lt;c4&gt;</bpt>view<ept i="4">&lt;/c4&gt;</ept> as its first argument.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072010Z" creationid="shibukawa.yoshiki" creationdate="20150502T072010Z">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>controller<ept i="3">&lt;/c3&gt;</ept>関数の返り値は、<bpt i="4" x="4">&lt;c4&gt;</bpt>view<ept i="4">&lt;/c4&gt;</ept>関数の最初の引数として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return value of the controller function is passed to the view function as its first argument.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125510Z" creationid="shibukawa.yoshiki" creationdate="20150502T125510Z">
        <seg>controller関数の返り値は、view関数の最初の引数として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return value of the view function is merely a plain Javascript data structure that represents a DOM tree.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072424Z" creationid="shibukawa.yoshiki" creationdate="20150502T072424Z">
        <seg>ビュー関数の返り値はDOMを表現したJavaScriptのデータ構造です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The returned VirtualElement is a Javascript data structure that represents the DOM element to be rendered by <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.render<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T160555Z" creationid="shibukawa.yoshiki" creationdate="20150413T160555Z">
        <seg>返されるVirtualElementは、DOMエレメントを表すデータ構造です。このデータ構造は<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.render<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を通じてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The returned getter-setter also implements the <bpt i="0" x="0">&lt;a0&gt;</bpt>promise<ept i="0">&lt;/a0&gt;</ept> interface (also known as a <bpt i="1" x="1">&lt;e1&gt;</bpt>thennable<ept i="1">&lt;/e1&gt;</ept>): this is the mechanism you should always use to queue operations to be performed on the data from the web service.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015523Z" creationid="shibukawa.yoshiki" creationdate="20150410T015523Z">
        <seg>返されるgetter-setterは<bpt i="0" x="0">&lt;a0&gt;</bpt>promise<ept i="0">&lt;/a0&gt;</ept>のインタフェース(<bpt i="1" x="1">&lt;e1&gt;</bpt>thennable<ept i="1">&lt;/e1&gt;</ept>とも呼ばれる)を持っています。この機能は、ウェブサービスからデータが帰ってきた後の操作をキューイングするのに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The returned getter-setter can be thought of as a box: you can pass this reference around cheaply, and you can "unwrap" its value when needed.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T014906Z" creationid="shibukawa.yoshiki" creationdate="20150410T014906Z">
        <seg>getter-setterを返すことは参照を安いコストでコード内に渡すことができて、値が必要になったときにデータの実体を取り出すことができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The returned string is a String object instance (as opposed to a string primitive) containing the same HTML content, and exposing a flag property for internal use within Mithril.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015545Z" creationid="shibukawa.yoshiki" creationdate="20150416T015545Z">
        <seg>返される文字列は文字列オブジェクトのインスタンス(文字列プリミティブではない)で、同じHTMLコンテンツと、Mithril内部で使用するフラグ属性を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The returned window is the same as what is passed in.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T162202Z" creationid="shibukawa.yoshiki" creationdate="20150416T162154Z">
        <seg>引数に渡されたのと同じwindowを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The root DOM element in a component's view must not be changed during the lifecycle of the component, otherwise undefined behavior will occur.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095939Z" creationid="shibukawa.yoshiki" creationdate="20150502T095939Z">
        <seg>コンポーネントのビューのルートのDOMエレメントはコンポーネントのライフサイクル内で変更してはいけません。未定義の動作をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The route to redirect to if the current URL does not match any of the defined routes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T155753Z" creationid="shibukawa.yoshiki" creationdate="20150414T155753Z">
        <seg>現在のURLが、どの定義されたラウトにもマッチしなかった時にリダイレクトされラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The route to redirect to.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171417Z" creationid="shibukawa.yoshiki" creationdate="20150414T171417Z">
        <seg>リダイレクト先のラウト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second one has a data binding to the <bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept> getter-setter of the Todo class instance.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153318Z" creationid="shibukawa.yoshiki" creationdate="20150408T153318Z">
        <seg>2つ目のタグは、Todoクラスのインスタンス<bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept> getter-setterへのバインディングが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second one is called if it completes with an error.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114500Z" creationid="shibukawa.yoshiki" creationdate="20150414T175019Z">
        <seg>2つ目のパラメータはエラーで完了したときに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second parameter is called if it completes with an error.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T114512Z" creationid="shibukawa.yoshiki" creationdate="20150410T124846Z">
        <seg>2つ目のパラメータはエラーで完了したときに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The serialized representation of the input data</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T171011Z" creationid="shibukawa.yoshiki" creationdate="20150414T171011Z">
        <seg>入力データのシリアライズ化表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The simplest server-side setup possible to support pathname mode is to serve the same content regardless of what URL is requested.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012822Z" creationid="shibukawa.yoshiki" creationdate="20150410T012822Z">
        <seg>pathnameモードを使用するためのサーバ設定の中で、一番簡単な方法は、どのURLが要求されても同じコンテンツを返すようにする方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The simplest use case of this feature is to implement functional value assignment via <bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept> (i.e. the same thing as above).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015909Z" creationid="shibukawa.yoshiki" creationdate="20150410T015842Z">
        <seg>この機能のもっとも簡単な使い方は、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept>を使って関数型的な値の割り当てを行うことです(上記のコードと等価です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string <bpt i="0" x="0">&lt;c0&gt;</bpt>johndoe<ept i="0">&lt;/c0&gt;</ept> is bound to the <bpt i="1" x="1">&lt;c1&gt;</bpt>:userID<ept i="1">&lt;/c1&gt;</ept> parameter, which can be retrieved programmatically in the controller via <bpt i="2" x="2">&lt;c2&gt;</bpt>m.route.param("userID")<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T004107Z" creationid="shibukawa.yoshiki" creationdate="20150410T003958Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>johndoe<ept i="0">&lt;/c0&gt;</ept>という文字列が<bpt i="1" x="1">&lt;c1&gt;</bpt>:userID<ept i="1">&lt;/c1&gt;</ept>パラメータに結び付けられます。このパラメータは、コントローラ内で<bpt i="2" x="2">&lt;c2&gt;</bpt>m.route.param("userID")<ept i="2">&lt;/c2&gt;</ept>というAPI呼び出しをするとプログラムから参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The table lists all the existing to-dos, if any.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153940Z" creationid="shibukawa.yoshiki" creationdate="20150408T153940Z">
        <seg>もし既存のToDoがある場合は、既存のすべてのToDoが表形式で出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The template is rendered as a child of the implicit <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;html&gt;<ept i="0">&lt;/c0&gt;</ept> element of the document.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153807Z" creationid="shibukawa.yoshiki" creationdate="20150408T153807Z">
        <seg>テンプレートは暗黙の<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;html&gt;<ept i="0">&lt;/c0&gt;</ept>要素としてレンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The text input saves its value to the <bpt i="0" x="0">&lt;c0&gt;</bpt>todo.vm.description<ept i="0">&lt;/c0&gt;</ept> getter-setter we defined earlier.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153841Z" creationid="shibukawa.yoshiki" creationdate="20150408T153841Z">
        <seg>テキスト入力は、値を、以前定義した<bpt i="0" x="0">&lt;c0&gt;</bpt>todo.vm.description<ept i="0">&lt;/c0&gt;</ept> getter-setter に保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The thennable mechanism is intended to be used in three ways:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123530Z" creationid="shibukawa.yoshiki" creationdate="20150410T123530Z">
        <seg>thennableの仕組みは主に以下の3ヶ所で使われることを想定しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The third argument for <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> allows you to map data to a virtual DOM element in a way that persists across redraws.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125558Z" creationid="shibukawa.yoshiki" creationdate="20150413T125558Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>の3番目の引数を使うと、再描画時に仮想のDOM要素を保持しておくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The tool allows you to write code like this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013900Z" creationid="shibukawa.yoshiki" creationdate="20150417T013900Z">
        <seg>このツールを使うと、次のようなコードが書けます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unwrapped data</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013018Z" creationid="shibukawa.yoshiki" creationdate="20150415T013018Z">
        <seg>unwrapされたデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The utility method <bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept> creates virtual DOM elements.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004251Z" creationid="shibukawa.yoshiki" creationdate="20150408T004251Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept>というユーティリティ関数はvirtual DOMの要素を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value that maps to the parameter specified by <bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T170834Z" creationid="shibukawa.yoshiki" creationdate="20150414T170834Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept>にマップされたパラメータの値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value that populates the returned getter-setter before the request completes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012356Z" creationid="shibukawa.yoshiki" creationdate="20150415T012356Z">
        <seg>リクエスト完了前に、この関数が返すgetter-setterが内部で保持する初期値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values that replace the dynamic parameters in a URL are available via <bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.param()<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165328Z" creationid="shibukawa.yoshiki" creationdate="20150414T165328Z">
        <seg>URLの中で動的パラメータを置き換えた値は、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.param()<ept i="0">&lt;/c0&gt;</ept>を通じて取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The vast majority of times, it's advisable to use <bpt i="2" x="2">&lt;c2&gt;</bpt>m.mount<ept i="2">&lt;/c2&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T100346Z" creationid="shibukawa.yoshiki" creationdate="20150502T100220Z">
        <seg>ほとんどの場合は、代わりに<bpt i="2" x="2">&lt;c2&gt;</bpt>m.mount<ept i="2">&lt;/c2&gt;</ept>を使うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The view function is run again whenever a redraw is required (i.e. whenever event handlers are triggered by user input).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072719Z" creationid="shibukawa.yoshiki" creationdate="20150502T072719Z">
        <seg>ユーザ入力イベントのハンドラが起動された時など、再描画が必要な時にview関数は何度も呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The virtual DOM data structure to which the config is applied to</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140052Z" creationid="shibukawa.yoshiki" creationdate="20150502T140052Z">
        <seg>configを適用する仮想DOMデータ構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The virtual DOM diffing algorithm has a weakness: a naive diff is not aware of the identity of DOM elements.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141044Z" creationid="shibukawa.yoshiki" creationdate="20150413T141006Z">
        <seg>仮想DOMの差分検知アルゴリズムには、DOM要素の厳密な同一性について判断できないという欠点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The way the redrawing engine defers redrawing is by keeping an internal counter that is incremented by <bpt i="4" x="4">&lt;c4&gt;</bpt>m.startComputation<ept i="4">&lt;/c4&gt;</ept> and decremented by <bpt i="5" x="5">&lt;c5&gt;</bpt>m.endComputation<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T190021Z" creationid="shibukawa.yoshiki" creationdate="20150411T190021Z">
        <seg>再描画エンジンは、内部のカウンタを使って再描画のタイミングを遅らせます。カウンタは<bpt i="4" x="4">&lt;c4&gt;</bpt>m.startComputation<ept i="4">&lt;/c4&gt;</ept>を呼び出すとインクリメントされ、<bpt i="5" x="5">&lt;c5&gt;</bpt>m.endComputation<ept i="5">&lt;/c5&gt;</ept>を呼び出すとデクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Then, to use Mithril, point a script tag to the downloaded file:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T170149Z" creationid="shibukawa.yoshiki" creationdate="20150407T170149Z">
        <seg>Mithrilを使う場合には、scriptタグを使って、ダウンロードしたファイルを参照します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are <bpt i="0" x="0">&lt;a0&gt;</bpt>different ways to organize components<ept i="0">&lt;/a0&gt;</ept> that can side-step the need for multiple redraws.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T094012Z" creationid="shibukawa.yoshiki" creationdate="20150502T094012Z">
        <seg>再描画が何度か走るのを避ける<bpt i="0" x="0">&lt;a0&gt;</bpt>コンポーネントの組み立て方<ept i="0">&lt;/a0&gt;</ept>もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are a couple of reasons why Mithril runs callbacks synchronously.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140627Z" creationid="shibukawa.yoshiki" creationdate="20150415T140627Z">
        <seg>Mithrilがコールバックを同期で実行しているにはいくつか理由があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are a few other technical caveats when nesting components:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T095608Z" creationid="shibukawa.yoshiki" creationdate="20150502T095608Z">
        <seg>コンポーネントのネスト時には、いくつか技術的な制約があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are a lot of different Javascript frameworks and evaluating their merits and shortcomings can be a daunting task.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015752Z" creationid="shibukawa.yoshiki" creationdate="20150417T015752Z">
        <seg>JavaScriptのフレームワーク同士で比較しても数多くの相違点があります。それぞれのフレームワークのメリット、欠点を評価するのは骨の折れる仕事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are some important semantic caveats for <bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw.strategy("none")<ept i="0">&lt;/c0&gt;</ept> that you should be aware of: Setting the strategy to <bpt i="1" x="1">&lt;c1&gt;</bpt>"none"<ept i="1">&lt;/c1&gt;</ept> only affects <bpt i="2" x="2">&lt;s2&gt;</bpt>synchronous<ept i="2">&lt;/s2&gt;</ept> redraws.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150506Z" creationid="shibukawa.yoshiki" creationdate="20150416T150411Z">
        <seg>注意すべきこととしては、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.redraw.strategy("none")<ept i="0">&lt;/c0&gt;</ept> で戦略を<bpt i="1" x="1">&lt;c1&gt;</bpt>"none"<ept i="1">&lt;/c1&gt;</ept>に設定しても、そのフレームで<bpt i="2" x="2">&lt;s2&gt;</bpt>同期的に行われる<ept i="2">&lt;/s2&gt;</ept>再描画にしか効果がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are three ways to render a component:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071629Z" creationid="shibukawa.yoshiki" creationdate="20150502T071629Z">
        <seg>コンポーネントを表示する方法は3通りあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two static methods: <bpt i="1" x="1">&lt;c1&gt;</bpt>list<ept i="1">&lt;/c1&gt;</ept> for retrieving a list of contacts, and <bpt i="2" x="2">&lt;c2&gt;</bpt>save<ept i="2">&lt;/c2&gt;</ept> to save a single contact.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T224217Z" creationid="shibukawa.yoshiki" creationdate="20150501T224217Z">
        <seg>これらには、データのリストを取得する<bpt i="1" x="1">&lt;c1&gt;</bpt>list<ept i="1">&lt;/c1&gt;</ept>メソッドと、単体の連絡先を取得する<bpt i="2" x="2">&lt;c2&gt;</bpt>save<ept i="2">&lt;/c2&gt;</ept>メソッドという2つの静的メソッドがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are, however, some limitations to the diff algorithm that require you to add <bpt i="0" x="0">&lt;a0&gt;</bpt>key attributes<ept i="0">&lt;/a0&gt;</ept> in some edge cases.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T020315Z" creationid="shibukawa.yoshiki" creationdate="20150416T020315Z">
        <seg>しかし、いくつかの特殊なケースをうまく処理するために、差分検知アルゴリズムに<bpt i="0" x="0">&lt;a0&gt;</bpt>key属性<ept i="0">&lt;/a0&gt;</ept>を渡す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There's a number of ways to improve Mithril performance for the rare cases where pages are too complex for their own good.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T142320Z" creationid="shibukawa.yoshiki" creationdate="20150412T142320Z">
        <seg>ページがその機能を実装するために複雑すぎる状況になっているという状況は稀ですが、その場合にMithrilのパフォーマンスを改善する方法はいくつｋもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There's a tool called <bpt i="0" x="0">&lt;a0&gt;</bpt>MSX by Jonathan Buchanan<ept i="0">&lt;/a0&gt;</ept> that allows you to write templates using HTML syntax, and then automatically compile them to Javascript when files change.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013750Z" creationid="shibukawa.yoshiki" creationdate="20150417T013750Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt> Jonathan Buchananが作成したMSX<ept i="0">&lt;/a0&gt;</ept> というツールがあります。これを使うとHTMLの文法を使ったテンプレートが作成できます。ファイルを変更すると自動でJavaScriptにコンパイルします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There's a type definition file that you can use to add Mithril support to Typescript</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014314Z" creationid="shibukawa.yoshiki" creationdate="20150417T014314Z">
        <seg>TypeScriptにMithrilサポートを追加する型定義ファイルもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There's just one caveat: while simply initializing multiple "islands" in this fashion works, their initialization calls are not aware of each other and can cause redraws too frequently.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141104Z" creationid="shibukawa.yoshiki" creationdate="20150412T140926Z">
        <seg>１つだけ注意すべきことがあるとしたら、単純にこれら複数の「島」を初期化してしまった時に、それぞれの初期化呼び出しがお互いを認識せずに、再描画処理が想定上に発生してしまう、ということを避けなければならない、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There's no idiomatic way to organize jQuery code in an MVC pattern and many frameworks were created specifically to overcome that shortcoming.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015357Z" creationid="shibukawa.yoshiki" creationdate="20150420T015357Z">
        <seg>MVCパターンをjQueryを使って実現するための共通の書き方といったものは存在しません。そのため、この足りないところを補うために数多くのフレームワークが作られました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There's no need for a parse-and-compile pre-processing step to turn strings containing HTML + templating syntax into working DOM elements.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013833Z" creationid="shibukawa.yoshiki" creationdate="20150409T013833Z">
        <seg>HTMLまじりの複雑な文字列を表示前に自前にパースしてコンパイルして、実際に表示されるDOM要素にするという大掛かりな仕事が必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, using the computation methods is recommended in order to reduce the amount of intermediate redraws that would otherwise occur as multiple asynchronous services are resolved.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T115205Z" creationid="shibukawa.yoshiki" creationdate="20150502T115205Z">
        <seg>そのため、複数の非同期アクセスが完了する前に再描画が即座に行われないようにするために、computationメソッドを使うほうが推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, you should ensure that templates have null checks in place to account for the possibility of variables being uninitialized when the forced redraw occurs.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130153Z" creationid="shibukawa.yoshiki" creationdate="20150502T130153Z">
        <seg>そのため、強制再描画時に、未初期化の変数アクセスが発生しないようにテンプレートでのnullチェックを確実に行うようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, you should not use <bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept> to modify controller and model values, if you expect these changes to render immediately.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125028Z" creationid="shibukawa.yoshiki" creationdate="20150413T125028Z">
        <seg>このため、コントローラやモデルの値など、すぐにレンダリングに反映したい変更をするのに<bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept>を使うのは適しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These components are designed to not interface with other components.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T014356Z" creationid="shibukawa.yoshiki" creationdate="20150502T014356Z">
        <seg>これらのコンポーネントはお互いのコンポーネントとやりとりをするようには設計されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These functions are internally called by Mithril when you initialize a component via <bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>m.mount<ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept> or <bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>m.route<ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>, and when you trigger event handlers that were created within templates with <bpt i="8" x="8">&lt;a8&gt;</bpt><bpt i="9" x="9">&lt;c9&gt;</bpt>m()<ept i="9">&lt;/c9&gt;</ept><ept i="8">&lt;/a8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125801Z" creationid="shibukawa.yoshiki" creationdate="20150502T125801Z">
        <seg>これらの関数は、<bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>m.mount<ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept>や<bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>m.route<ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>を通じてコンポーネントを初期化したり、<bpt i="8" x="8">&lt;a8&gt;</bpt><bpt i="9" x="9">&lt;c9&gt;</bpt>m()<ept i="9">&lt;/c9&gt;</ept><ept i="8">&lt;/a8&gt;</ept>を使って作られたテンプレート内のイベントハンドラを起動したときに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These hooks allow you to unwrap different parts of the response data depending on whether it succeed or failed.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174508Z" creationid="shibukawa.yoshiki" creationdate="20150410T174508Z">
        <seg>これらのフックを使うと、レスポンスが成功したかどうかによって、レスポンスデータの違う箇所をアンラップできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These methods are only intended to be used by people who are writing libraries that do things asynchronously, or when calling vanilla javascript asynchronous functions from template <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>config<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept> functions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153059Z" creationid="shibukawa.yoshiki" creationdate="20150416T153059Z">
        <seg>これらのメソッドは非同期のタスクを実行するライブラリを作成したり、素のJavaScriptの非同期関数をテンプレートの<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>config<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>関数から呼び出す人のみが使うことを想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These methods assume that the AJAX responses return contacts in JSON format, containing the same fields as the class.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T000018Z" creationid="shibukawa.yoshiki" creationdate="20150502T000018Z">
        <seg>このlistメソッドは、AJAXのレスポンスとして、クラスと同じ名前のフィールドを含むJSON形式で連絡先情報を返してくることを想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These two functions are here to illustrate the ability to expose APIs to component consumers that complement the component's user interface.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T032643Z" creationid="shibukawa.yoshiki" creationdate="20150502T032643Z">
        <seg>これらの2つの関数は、コンポーネント利用者にAPIを公開することで、コンポーネントのインタフェースを補完できることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They allow developers to encapsulate functionality into reusable units.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061224Z" creationid="shibukawa.yoshiki" creationdate="20150502T061224Z">
        <seg>コンポーネントの仕組みに従うってコーディングすると、再利用可能な、カプセル化された部品を作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They can be initialized and used like this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150835Z" creationid="shibukawa.yoshiki" creationdate="20150407T150835Z">
        <seg>これらのクラスは次のように初期化して使います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They do this because once the element is ready (and thus, has an accessible <bpt i="1" x="1">&lt;c1&gt;</bpt>innerHTML<ept i="1">&lt;/c1&gt;</ept> property), their rendering engines cannot backtrack to the parsing-stage if the script calls something like <bpt i="2" x="2">&lt;c2&gt;</bpt>document.write("&lt;/body&gt;")<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014356Z" creationid="shibukawa.yoshiki" creationdate="20150416T014356Z">
        <seg>一度HTMLエレメントの読み込みが完了して、 <bpt i="1" x="1">&lt;c1&gt;</bpt>innerHTML<ept i="1">&lt;/c1&gt;</ept> プロパティにアクセス可能になった後は、スクリプトが<bpt i="2" x="2">&lt;c2&gt;</bpt>document.write("&lt;/body&gt;")<ept i="2">&lt;/c2&gt;</ept>といった関数呼び出しをしたとしても、パースの段階に戻ることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Third-party promise library support</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133735Z" creationid="shibukawa.yoshiki" creationdate="20150414T133735Z">
        <seg>サードパーティのPromiseライブラリのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> statement is important, because this function may be called multiple times by Mithril's auto-redrawing system and we don't want to re-initialize select2 at every redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133941Z" creationid="shibukawa.yoshiki" creationdate="20150412T133941Z">
        <seg>この関数はMithrilの自動再描画システムから何度も呼び出されますし、描画のたびに何度もselect2を初期化するのはうれしくないため、この<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>文は大切です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows getter-setters to be passed directly as parameters to <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.request<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>, for example.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135657Z" creationid="shibukawa.yoshiki" creationdate="20150414T135657Z">
        <seg>これにより、getter-setterはそのまま<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.request<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>などのパラメータとして渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows named anchors (i.e. <bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;a href="#top"&gt;Back to top&lt;/a&gt;<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;a name="top"&gt;&lt;/a&gt;<ept i="2">&lt;/c2&gt;</ept>) to work on the page, but routing changes causes page refreshes in IE8, due to its lack of support for <bpt i="3" x="3">&lt;c3&gt;</bpt>history.pushState<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T005103Z" creationid="shibukawa.yoshiki" creationdate="20150410T005103Z">
        <seg>このモードを使うと、名前付きのアンカー(例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;a href="#top"&gt;トップに戻る&lt;/a&gt;<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;a name="top"&gt;&lt;/a&gt;<ept i="2">&lt;/c2&gt;</ept>)を使うことができますが、IE8の場合は<bpt i="3" x="3">&lt;c3&gt;</bpt>history.pushState<ept i="3">&lt;/c3&gt;</ept>のサポートがないため、ページリフレッシュが発生してしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows named anchors (i.e. <bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;a href="#top"&gt;Back to top&lt;/a&gt;<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;a name="top"&gt;&lt;/a&gt;<ept i="3">&lt;/c3&gt;</ept>) to work on the page, but routing changes causes page refreshes in IE8, due to its lack of support for <bpt i="4" x="4">&lt;c4&gt;</bpt>history.pushState<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T165955Z" creationid="shibukawa.yoshiki" creationdate="20150414T165955Z">
        <seg>このモードを使うと、名前付きのアンカー(例えば、<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;a href="#top"&gt;トップに戻る&lt;/a&gt;<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;a name="top"&gt;&lt;/a&gt;<ept i="3">&lt;/c3&gt;</ept>)を使うことができますが、IE8の場合は<bpt i="4" x="4">&lt;c4&gt;</bpt>history.pushState<ept i="4">&lt;/c4&gt;</ept>のサポートがないため、ページリフレッシュが発生してしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows swapping the implementation of the <bpt i="0" x="0">&lt;c0&gt;</bpt>saveContact<ept i="0">&lt;/c0&gt;</ept> handler without changing the <bpt i="1" x="1">&lt;c1&gt;</bpt>ContactForm<ept i="1">&lt;/c1&gt;</ept> component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031718Z" creationid="shibukawa.yoshiki" creationdate="20150502T031718Z">
        <seg>これにより、<bpt i="1" x="1">&lt;c1&gt;</bpt>ContactForm<ept i="1">&lt;/c1&gt;</ept>コンポーネントを変更することなく、<bpt i="0" x="0">&lt;c0&gt;</bpt>saveContact<ept i="0">&lt;/c0&gt;</ept>ハンドラの実装を変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows the developer to abstract away any aspect of the template at will.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002827Z" creationid="shibukawa.yoshiki" creationdate="20150413T002827Z">
        <seg>これによって開発者から見てテンプレートに対してあらゆる抽象化が行えるようなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows us to maintain input focus and plugin state correctly.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T141807Z" creationid="shibukawa.yoshiki" creationdate="20150413T141807Z">
        <seg>これを使うと、入力のフォーカスや、プラグインの状態を正しく維持することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows you to implement optimizations that avoid creating virtual DOM trees in favor of their cached counterparts, if you know they have not changed between redraws.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123810Z" creationid="shibukawa.yoshiki" creationdate="20150416T123810Z">
        <seg>もし再描画間で差分が発生していないことが明示的にわかっている場合は、キャッシュと対になる仮想DOMツリーの生成の手間が省けるため、処理を最適化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This also applies for asynchronous functions called from 3rd party libraries or from vanilla javascript, if they call this pair of functions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T154704Z" creationid="shibukawa.yoshiki" creationdate="20150416T154704Z">
        <seg>サードパーティのライブラリや、ネイティブJavaScriptのコードから非同期関数を使う時も、これらの関数のペアを呼ぶ場合は同じルールが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This approach means that developers can get discoverable codebases without necessarily getting locked into the framework.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T144943Z" creationid="shibukawa.yoshiki" creationdate="20150417T144943Z">
        <seg>これにより、開発者はフレームワークにロックインされることなく、オープンなコードベースを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This architecture can yield highly flexible and reusable code, but flexibility can also increase the cognitive load of the system (for example, you need to look at both the top-level module and <bpt i="0" x="0">&lt;c0&gt;</bpt>ContactList<ept i="0">&lt;/c0&gt;</ept> in order to know what is the data being displayed (and how it's being filtered, etc).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T012919Z" creationid="shibukawa.yoshiki" creationdate="20150502T012919Z">
        <seg>このアーキテクチャにすることで、高い柔軟性と再利用性の高井コードが得られますが、柔軟性が高いということはシステムを理解する負荷が高まるということです。どのようにデータが表示されるかを知るには、トップレベルのモジュールと、<bpt i="0" x="0">&lt;c0&gt;</bpt>ContactList<ept i="0">&lt;/c0&gt;</ept>の2つを見る必要があります。場合によってはどのようにフィルタされるかを知る必要もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This binds the <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> getter-setter to the text input.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T014947Z" creationid="shibukawa.yoshiki" creationdate="20150408T014947Z">
        <seg>このコードにより、<bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> getter-setterとテキスト入力が接続されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This can be done by simply calling <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> at the beginning, and <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> at the end of the function.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134514Z" creationid="shibukawa.yoshiki" creationdate="20150412T134514Z">
        <seg>統合するには関数の先頭で<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept>を呼び、関数の最後で<bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を呼び出すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This can get noticeably bulky when you look at thing like collections: you often need to implement insertion code and deletion code, in addition to a "draw everything" routine for performance.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T014351Z" creationid="shibukawa.yoshiki" creationdate="20150420T014351Z">
        <seg>「すべてを描画する」ルーチンに加えて、パフォーマンスを向上させるために、部品を追加する、削除するといったコードの実装が必要で、コード量がとても大きくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This comes with several benefits (proper error reporting, proper lexical scoping, etc.), while still allowing <bpt i="0" x="0">&lt;a0&gt;</bpt>HTML syntax to be used via a preprocessor tool<ept i="0">&lt;/a0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041323Z" creationid="shibukawa.yoshiki" creationdate="20150502T041323Z">
        <seg>このことには、エラー発生時のメッセージが分かりやすいとか、適切なレキシカルスコープが使えるなどのさまざまな利点があります。また、<bpt i="0" x="0">&lt;a0&gt;</bpt>HTML文法を使うことができるプリプロセッサツール<ept i="0">&lt;/a0&gt;</ept>も利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This cost might be less of a concern in single page apps, but not necessarily if the app is typically opened simultaneously in multiple tabs, or run on less powerful devices.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T113548Z" creationid="shibukawa.yoshiki" creationdate="20150417T113548Z">
        <seg>このコストは、シングルページアプリケーションでは影響は小さくなりますが、複数タブで同時に開かれたり、性能の低いデバイスで実行される場合はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This creates a new function with the parameter already set.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151345Z" creationid="shibukawa.yoshiki" creationdate="20150408T151345Z">
        <seg>このメソッドを使うと、パラメータがあらかじめ設定された、新しい関数を作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This design decision comes from experience with <bpt i="0" x="0">&lt;a0&gt;</bpt>DRY<ept i="0">&lt;/a0&gt;</ept> and the <bpt i="1" x="1">&lt;a1&gt;</bpt>"bus factor"<ept i="1">&lt;/a1&gt;</ept> of large, highly relational model layers.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032507Z" creationid="shibukawa.yoshiki" creationdate="20150421T014921Z">
        <seg>このデザインの原則は<bpt i="0" x="0">&lt;a0&gt;</bpt>DRY<ept i="0">&lt;/a0&gt;</ept>と、リレーショナルモデル層の<bpt i="1" x="1">&lt;a1&gt;</bpt>トラックナンバー<ept i="1">&lt;/a1&gt;</ept>の大きさから来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This deviation from the spec is there to make it easier for developers to find common logical errors such as typos that lead to null reference exceptions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T172449Z" creationid="shibukawa.yoshiki" creationdate="20150415T172340Z">
        <seg>仕様と異なるこの動作により、タイプミスによるnull参照例外などの一般的なエラーを開発者が簡単に見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures that data being accessed in the view isn't nullable as a result of asynchronous data not being available yet.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T235932Z" creationid="shibukawa.yoshiki" creationdate="20150414T235932Z">
        <seg>この仕組により、ビューが非同期データのデータにアクセスするときも、データがまだ利用できないために表示がおかしくなる、ということがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example is also available as a <bpt i="0" x="0">&lt;a0&gt;</bpt>jsFiddle<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163514Z" creationid="shibukawa.yoshiki" creationdate="20150408T163514Z">
        <seg>このサンプルは、<bpt i="0" x="0">&lt;a0&gt;</bpt>jsFiddle<ept i="0">&lt;/a0&gt;</ept>でも確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This flag is false the first time it runs on an element, and true on redraws that happen after the element has been created.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155231Z" creationid="shibukawa.yoshiki" creationdate="20150413T155231Z">
        <seg>そのエレメントに対して初めて実行される時はこのフラグがfalseに設定され、エレメントの作成後に再描画が発生してそこから呼ばれる時はtrueになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function initializes the <bpt i="2" x="2">&lt;c2&gt;</bpt>vm<ept i="2">&lt;/c2&gt;</ept> object with three members: <bpt i="3" x="3">&lt;c3&gt;</bpt>list<ept i="3">&lt;/c3&gt;</ept>, which is simply an array, <bpt i="4" x="4">&lt;c4&gt;</bpt>description<ept i="4">&lt;/c4&gt;</ept>, which is an <bpt i="5" x="5">&lt;c5&gt;</bpt>m.prop<ept i="5">&lt;/c5&gt;</ept> getter-setter function with an empty string as the initial value, and <bpt i="6" x="6">&lt;c6&gt;</bpt>add<ept i="6">&lt;/c6&gt;</ept>, which is a method that adds a new Todo instance to <bpt i="7" x="7">&lt;c7&gt;</bpt>list<ept i="7">&lt;/c7&gt;</ept> if an input description getter-setter is not an empty string.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20151106T113954Z" creationid="shibukawa.yoshiki" creationdate="20150407T162621Z">
        <seg>このコードは、3つのメンバーを持つ<bpt i="2" x="2">&lt;c2&gt;</bpt>vm<ept i="2">&lt;/c2&gt;</ept>オブジェクトを初期化しています。単純な配列の<bpt i="3" x="3">&lt;c3&gt;</bpt>list<ept i="3">&lt;/c3&gt;</ept>、初期値の文字列として空の文字列を渡された<bpt i="5" x="5">&lt;c5&gt;</bpt>m.prop<ept i="5">&lt;/c5&gt;</ept>のgetter-setter関数である<bpt i="4" x="4">&lt;c4&gt;</bpt>description<ept i="4">&lt;/c4&gt;</ept>、入力のdescription getter-setterが空の文字列でないときに、新しいTodoインスタンスを<bpt i="7" x="7">&lt;c7&gt;</bpt>list<ept i="7">&lt;/c7&gt;</ept>に登録する<bpt i="6" x="6">&lt;c6&gt;</bpt>add<ept i="6">&lt;/c6&gt;</ept>関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function overwrites the reference to the <bpt i="0" x="0">&lt;c0&gt;</bpt>window<ept i="0">&lt;/c0&gt;</ept> object that is used internally by Mithril.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T160616Z" creationid="shibukawa.yoshiki" creationdate="20150416T160616Z">
        <seg>この関数を使うと、Mithril内部で使われる<bpt i="0" x="0">&lt;c0&gt;</bpt>window<ept i="0">&lt;/c0&gt;</ept>オブジェクトを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function will be called with the value of the defined property as an argument.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140918Z" creationid="shibukawa.yoshiki" creationdate="20150414T140918Z">
        <seg>この関数は引数として定義されたプロパティの値とともに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This handler method can be assigned to properties like <bpt i="0" x="0">&lt;c0&gt;</bpt>onclick<ept i="0">&lt;/c0&gt;</ept>, or passed as callbacks to <bpt i="1" x="1">&lt;c1&gt;</bpt>addEventListener<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T141043Z" creationid="shibukawa.yoshiki" creationdate="20150414T141043Z">
        <seg>このハンドラメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>onclick<ept i="0">&lt;/c0&gt;</ept>などのプロパティに設定したり、<bpt i="1" x="1">&lt;c1&gt;</bpt>addEventListener<ept i="1">&lt;/c1&gt;</ept>にコールバックとして渡すことができるメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This has the benefit of cleaner syntax for writing static text, but it comes with the disadvantage of features getting awkwardly tied to HTML syntax, as well as providing poor debugging support.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T025712Z" creationid="shibukawa.yoshiki" creationdate="20150420T025712Z">
        <seg>この方式は静的なテキストを作成するのは書きやすいというメリットがありますが、HTMLの文法を密結合してしまっている欠点がありますし、デバッグもしやすいとは言えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This idiom can also be used to attach <bpt i="2" x="2">&lt;c2&gt;</bpt>onprogress<ept i="2">&lt;/c2&gt;</ept> event handlers.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182339Z" creationid="shibukawa.yoshiki" creationdate="20150414T182339Z">
        <seg>この方法は、<bpt i="2" x="2">&lt;c2&gt;</bpt>onprogress<ept i="2">&lt;/c2&gt;</ept>を付与するのにも使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a convenience method to compose virtual elements that can be rendered via <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.render()<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235212Z" creationid="shibukawa.yoshiki" creationdate="20150412T235212Z">
        <seg>この関数は仮想DOM要素を組み立てるための簡単なインタフェースを提供する関数です。この仮想DOM要素は<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.render()<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>メソッドを使ってレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a form of <bpt i="2" x="2">&lt;e2&gt;</bpt>lazy evaluation<ept i="2">&lt;/e2&gt;</ept>: it allows us to say "use this value later, when the event handler gets called".</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151857Z" creationid="shibukawa.yoshiki" creationdate="20150408T151857Z">
        <seg>このような形式を<bpt i="2" x="2">&lt;e2&gt;</bpt>遅延評価(lazy evaluation)<ept i="2">&lt;/e2&gt;</ept>と呼びます。これを使うと、「イベントハンドラが呼ばれて、本当に必要になったタイミングまで値の取得を遅らせよう」ということができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a getter-setter factory utility.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T133832Z" creationid="shibukawa.yoshiki" creationdate="20150414T133832Z">
        <seg>この関数は、getter-setterのファクトリ関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a high-level utility for working with web services, which allows writing asynchronous code relatively procedurally.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174738Z" creationid="shibukawa.yoshiki" creationdate="20150414T174738Z">
        <seg>この関数はウェブサービスと協調するための高度なユーティリティです。この機能を使うと、非同期で動作するコードを、比較的手続き的に記述することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a low-level method in Mithril.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T015830Z" creationid="shibukawa.yoshiki" creationdate="20150415T015830Z">
        <seg>これは、Mithrilの低レベルメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a problem particularly for frameworks that had breaking changes in the past: It's common to find answers in StackOverflow that are out-of-date and no longer work with the latest version of said frameworks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T114247Z" creationid="shibukawa.yoshiki" creationdate="20150417T114247Z">
        <seg>これは特に、過去の大きな変更があると問題になります。StackOverflowで見つけた解答が最新版のフレームワークでは動作しないということがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is an event handler factory.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140138Z" creationid="shibukawa.yoshiki" creationdate="20150414T140138Z">
        <seg>この関数はイベントハンドラを生成するファクトリ関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is good for framework adoption, but not necessarily ideal for team scalability and codebase discoverability.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T020356Z" creationid="shibukawa.yoshiki" creationdate="20150420T020356Z">
        <seg>これはフレームワーク適用の柔軟性を高める点では悪くないのですが、開発チームのスケーラビリティやコードベースの探索のしやすさの点で理想的とはいえません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is in stark contrast to the ActiveRecord pattern of other frameworks, where model entities are largely object representations of database entities and these entities are manipulated in controllers in an ad-hoc field-by-field fashion, and then "committed" via a <bpt i="0" x="0">&lt;c0&gt;</bpt>save<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T032841Z" creationid="shibukawa.yoshiki" creationdate="20150421T032841Z">
        <seg>これは、他のフレームワークのActiveRecordパターンと大きく異なっています。ActiveRecordパターンのモデルエンティティは、データベースのエンティティのオブジェクト表現という側面が強く、アドホックにコントローラ内でフィード操作されて、最後に<bpt i="0" x="0">&lt;c0&gt;</bpt>save<ept i="0">&lt;/c0&gt;</ept>メソッドでコミットされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is known, appropriately, as the <bpt i="2" x="2">&lt;a2&gt;</bpt>observer pattern<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025130Z" creationid="shibukawa.yoshiki" creationdate="20150502T025130Z">
        <seg>これは<bpt i="2" x="2">&lt;a2&gt;</bpt>オブザーバパターン<ept i="2">&lt;/a2&gt;</ept>と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is perfectly valid: there are three asynchronous computations pending after the <bpt i="4" x="4">&lt;c4&gt;</bpt>jQuery.when<ept i="4">&lt;/c4&gt;</ept> method is called, and therefore, three pairs of <bpt i="5" x="5">&lt;c5&gt;</bpt>m.startComputation<ept i="5">&lt;/c5&gt;</ept> / <bpt i="6" x="6">&lt;c6&gt;</bpt>m.endComputation<ept i="6">&lt;/c6&gt;</ept> in play.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010103Z" creationid="shibukawa.yoshiki" creationdate="20150412T010103Z">
        <seg>このコードは完璧に正しいコードです。<bpt i="4" x="4">&lt;c4&gt;</bpt>jQuery.when<ept i="4">&lt;/c4&gt;</ept>が呼ばれた後に、そこから3組の<bpt i="5" x="5">&lt;c5&gt;</bpt>m.startComputation<ept i="5">&lt;/c5&gt;</ept> / <bpt i="6" x="6">&lt;c6&gt;</bpt>m.endComputation<ept i="6">&lt;/c6&gt;</ept>呼び出しがあるため、3つの非同期描画が遅延されて、バッチ処理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the default for going from one route to another.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143321Z" creationid="shibukawa.yoshiki" creationdate="20150416T143321Z">
        <seg>この動作はラウト間の遷移時のデフォルトの動作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the most potentially expensive method in Mithril and should not be used at a rate faster than the rate at which the native <bpt i="0" x="0">&lt;c0&gt;</bpt>requestAnimationFrame<ept i="0">&lt;/c0&gt;</ept> method fires (i.e. the rate at which browsers are comfortable calling recurring rendering-intensive code).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020309Z" creationid="shibukawa.yoshiki" creationdate="20150421T020309Z">
        <seg>m.redrawは、Mithrilの中でもっとも重い処理になりえる関数です。ネイティブの<bpt i="0" x="0">&lt;c0&gt;</bpt>requestAnimationFrame<ept i="0">&lt;/c0&gt;</ept>メソッドが起動されるよりも早いペースで呼び出すべきではありません。このメソッドは、レンダリングに関するコードを実行するのに、ブラウザにとって一番快適なインターバルを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the recommended way for views and models to exchange data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062126Z" creationid="shibukawa.yoshiki" creationdate="20150502T062126Z">
        <seg>これがMithrilの推奨する、ビューとモデルのデータの交換方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the value of the defined DOM element's property.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140943Z" creationid="shibukawa.yoshiki" creationdate="20150414T140943Z">
        <seg>これは定義されたDOMエレメントの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is to make the method compatible with virtual DOM elements' <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> attribute (see <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m()<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172538Z" creationid="shibukawa.yoshiki" creationdate="20150414T172538Z">
        <seg>これは、仮想DOMエレメント<bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>属性に対して、メソッドの互換性を維持するために使用します。<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m()<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>を参照して下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful for re-running ajax calls for different model entities.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085524Z" creationid="shibukawa.yoshiki" creationdate="20150502T085524Z">
        <seg>これは違うモデルエンティティに対してAJAX呼び出しを再実行した場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful if there are cleanup tasks that need to be run when an element is destroyed (e.g. clearing <bpt i="0" x="0">&lt;c0&gt;</bpt>setTimeout<ept i="0">&lt;/c0&gt;</ept>'s, etc)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130429Z" creationid="shibukawa.yoshiki" creationdate="20150413T130429Z">
        <seg>エレメントが破棄されるときに、なんらかの後片付けのタスクを実行したい時にはこの機能は便利です。例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>setTimeout<ept i="0">&lt;/c0&gt;</ept>を辞めるといったタスクがあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful when a <bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept> instantiates 3rd party classes and accesses the instance on redraws.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125737Z" creationid="shibukawa.yoshiki" creationdate="20150413T125737Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>config<ept i="1">&lt;/c1&gt;</ept>のコールバックがサードパーティのクラスのインスタンスを作成したり、再描画時にそのインスタンスにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful when the relevant data is either in a response header or the status field.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T013414Z" creationid="shibukawa.yoshiki" creationdate="20150415T013414Z">
        <seg>このオプションはレスポンスヘッダやステータスフィールドに必要なデータがある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful when using the <bpt i="0" x="0">&lt;c0&gt;</bpt>background<ept i="0">&lt;/c0&gt;</ept> option, in order to avoid the need for null checks in views that may be attempting to access the returned getter-setter before the asynchronous request resolves.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T012521Z" creationid="shibukawa.yoshiki" creationdate="20150415T012521Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>background<ept i="0">&lt;/c0&gt;</ept>オプションを使用するときにこのオプションを使用すると、リクエスト完了前にビューがgetter-setterにアクセスするときにnullチェックを行う手間が減ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful when we want to control access to certain properties in an object, as opposed to exposing all the fields in POJOs (plain old Javascript objects) for arbitrary processing.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170524Z" creationid="shibukawa.yoshiki" creationdate="20150410T170524Z">
        <seg>POJO(plain old JavaScript objects)の場合はすべてのフィールドが公開状態になってしまうため、この機能を使うとオブジェクト内のプロパティへのアクセス方法をコントロールしやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful, for example, if you declare a <bpt i="0" x="0">&lt;c0&gt;</bpt>canvas<ept i="0">&lt;/c0&gt;</ept> element and want to use the Javascript API to draw:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123454Z" creationid="shibukawa.yoshiki" creationdate="20150413T123454Z">
        <seg>この機能は、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>canvas<ept i="0">&lt;/c0&gt;</ept>エレメントを作り、JavaScriptの描画APIを使って絵を描く場合などに便利です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful, for example, if you received invalid JSON from the server in production and you want to display a message to the user saying that the server is offline.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181246Z" creationid="shibukawa.yoshiki" creationdate="20150414T181246Z">
        <seg>もしJSONとしては不正なレスポンスをプロダクション環境のサーバから受け取ったとして、ユーザに対してサーバがオフラインであるというメッセージを表示したいとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This key-value map should define a list of HTML attributes and their respective values.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153433Z" creationid="shibukawa.yoshiki" creationdate="20150413T153433Z">
        <seg>キー・バリューのマップはHTML属性とその値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This makes it easy to reason about the state of the UI and to test it.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T183527Z" creationid="shibukawa.yoshiki" creationdate="20150411T183527Z">
        <seg>これにより、UIの状態や状態のテストが簡単に行えるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This makes the href behave correctly regardless of which <bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.mode<ept i="0">&lt;/c0&gt;</ept> is selected.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013416Z" creationid="shibukawa.yoshiki" creationdate="20150410T013416Z">
        <seg>この書き方を使用すると、どの<bpt i="0" x="0">&lt;c0&gt;</bpt>m.route.mode<ept i="0">&lt;/c0&gt;</ept>が選択されていたとしても、期待通りの実行結果が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means it's possible for a view to attempt to use data before it is available.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001641Z" creationid="shibukawa.yoshiki" creationdate="20150415T001641Z">
        <seg>このオプションを有効にすると、データが利用可能になる前にビューがデータにアクセスしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that compiled templates don't need to parse the string in <bpt i="2" x="2">&lt;c2&gt;</bpt>m("div#foo")<ept i="2">&lt;/c2&gt;</ept> and they don't incur the cost of the function call.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144404Z" creationid="shibukawa.yoshiki" creationdate="20150412T144404Z">
        <seg>コンパイルされたテンプレートを使用する時は、<bpt i="2" x="2">&lt;c2&gt;</bpt>m("div#foo")<ept i="2">&lt;/c2&gt;</ept>といった文字列をパースする必要がなく、関数呼び出しのコストは発生しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that in the code below, the input on screen will overwritten by the model data any time a redraw happens:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015206Z" creationid="shibukawa.yoshiki" creationdate="20150413T015206Z">
        <seg>これはつまり、下記のサンプルのスクリーン上のテキスト入力の値は、モデルデータが変更されるたびに上書きされることを意味しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that just as you are able to bind the <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> attribute in an <bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;select&gt;<ept i="1">&lt;/c1&gt;</ept>, you are also able to bind the <bpt i="2" x="2">&lt;c2&gt;</bpt>selectedIndex<ept i="2">&lt;/c2&gt;</ept> property, if needed for whatever reason.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021929Z" creationid="shibukawa.yoshiki" creationdate="20150408T021929Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;select&gt;<ept i="1">&lt;/c1&gt;</ept>タグであれば、<bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>属性と結びつけることもできますし、用途によっては<bpt i="2" x="2">&lt;c2&gt;</bpt>selectedIndex<ept i="2">&lt;/c2&gt;</ept>プロパティとバインドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that the virtual dom tree may take two or more redraws (depending on how many nested asynchronous components there are) to be fully rendered.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093904Z" creationid="shibukawa.yoshiki" creationdate="20150502T093904Z">
        <seg>これによって非同期のネストされたコンポーネントの数次第で、完全なレンダリングが行われるまでに、何度か仮想DOMツリーの再描画処理が走る可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that typing something on the input and then re-rendering will clobber the text on screen.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015937Z" creationid="shibukawa.yoshiki" creationdate="20150408T015937Z">
        <seg>これは、何かしらのテキストを入力して、再レンダリングが実行されると、スクリーン上のテキストが破棄されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that we are avoiding the creation of the header subtree (and therefore skipping the diff algorithm) altogether, but it also means that dynamic variables will NOT be updated within the header.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124500Z" creationid="shibukawa.yoshiki" creationdate="20150416T124500Z">
        <seg>こうすると、ヘッダーに関するサブツリーが作られなくなり、差分アルゴリズムもスキップしますが、ヘッダ内の動的な変数が更新されることもなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This mechanism allows multiple components to be reloaded in response to non-idempotent operations.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T021537Z" creationid="shibukawa.yoshiki" creationdate="20150502T021537Z">
        <seg>この仕組みを使うと、状態を変更させるような操作に対して複数のコンポーネントをリロードさせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This mechanism is only intended to be used as a last resort optimization tool.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124016Z" creationid="shibukawa.yoshiki" creationdate="20150416T124016Z">
        <seg>この機能は、パフォーマンスの最適化のための最終手段として用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This mechanism is useful to clear timers and unsubscribe event handlers.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T015902Z" creationid="shibukawa.yoshiki" creationdate="20150414T015902Z">
        <seg>タイマーをクリアしたり、イベントハンドラをunsubscribeする場合に、この仕組みが便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method accepts two callbacks which process a value passed to the <bpt i="0" x="0">&lt;c0&gt;</bpt>resolve<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>reject<ept i="1">&lt;/c1&gt;</ept> methods, respectively, and pass the processed value to the returned promise</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T175631Z" creationid="shibukawa.yoshiki" creationdate="20150415T175631Z">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>resolve<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>reject<ept i="1">&lt;/c1&gt;</ept>メソッドに渡される値を受け取り、結果のpromiseに格納される値を処理して返す2つのコールバックを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method always returns the value of the internal store, regardless of whether it was updated or not.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140011Z" creationid="shibukawa.yoshiki" creationdate="20150414T140011Z">
        <seg>このメソッドは、値が更新されたかどうかにかかわらず、常に内部ストアの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method flags a string as trusted HTML.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013558Z" creationid="shibukawa.yoshiki" creationdate="20150416T013558Z">
        <seg>このメソッドは文字列に対して信用できるHTMLであるとフラグを立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method generates a DOM tree inside of a given HTML element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T015955Z" creationid="shibukawa.yoshiki" creationdate="20150416T015955Z">
        <seg>このメソッドは、DOMツリーを指定されたHTML属性内に定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method gets called every time an exception is thrown inside a promise callback.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180257Z" creationid="shibukawa.yoshiki" creationdate="20150415T180257Z">
        <seg>このメソッドはpromiseコールバックの中で例外が発生するたびに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method is meant to be used with a virtual element's <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013226Z" creationid="shibukawa.yoshiki" creationdate="20150410T013226Z">
        <seg>このメソッドを使うには、 <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>仮想エレメントのプロパティを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method is provided to decouple the browser's event model from the controller/logic model.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140435Z" creationid="shibukawa.yoshiki" creationdate="20150414T140435Z">
        <seg>このメソッドは、ブラウザのイベントモデルと、コントローラ/ロジックモデルを疎結合にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method overloads four different units of functionality:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152555Z" creationid="shibukawa.yoshiki" creationdate="20150414T152555Z">
        <seg>このメソッドは4つの異なる機能をオーバーロードしています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method passes a value to the <bpt i="0" x="0">&lt;c0&gt;</bpt>errorCallback<ept i="0">&lt;/c0&gt;</ept> of the deferred object's child promise</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180158Z" creationid="shibukawa.yoshiki" creationdate="20150415T180154Z">
        <seg>このメソッドは、deferredオブジェクトの子のpromiseの<bpt i="0" x="0">&lt;c0&gt;</bpt>errorCallback<ept i="0">&lt;/c0&gt;</ept>に値を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method passes a value to the <bpt i="0" x="0">&lt;c0&gt;</bpt>successCallback<ept i="0">&lt;/c0&gt;</ept> of the deferred object's child promise</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180143Z" creationid="shibukawa.yoshiki" creationdate="20150415T180143Z">
        <seg>このメソッドは、deferredオブジェクトの子のpromiseの<bpt i="0" x="0">&lt;c0&gt;</bpt>successCallback<ept i="0">&lt;/c0&gt;</ept>に値を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method takes a list of promises and returns a promise that resolves when all promises in the input list have resolved.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T180614Z" creationid="shibukawa.yoshiki" creationdate="20150415T180533Z">
        <seg>このメソッドはリストに入ったpromiseを受け取り、すべてのpromiseが果たされた時に解決するpromiseを解決します。￥</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This option is useful for running operations in the background (i.e. without user intervention).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T011826Z" creationid="shibukawa.yoshiki" creationdate="20150415T011826Z">
        <seg>この操作は、ユーザの操作によらず行われるバックグラウンドの操作を実行する場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This option is useful for web services that use uncommon conventions for defining jsonp callbacks (e.g. foo.com/?jsonpCallback=doSomething)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014719Z" creationid="shibukawa.yoshiki" creationdate="20150415T014719Z">
        <seg>foo.com/?jsonpCallback=doSomethingなど、一般的な規約とはことなるjsonpコールバック定義をさせるウェブサービスを章するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This optional compilation tool is merely "icing on the cake" that speeds up the Javascript run-time of templates (which is already fast, even without compilation - see the <bpt i="0" x="0">&lt;a0&gt;</bpt>performance section on the homepage<ept i="0">&lt;/a0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T144842Z" creationid="shibukawa.yoshiki" creationdate="20150412T144842Z">
        <seg>Mithirilは <bpt i="0" x="0">&lt;a0&gt;</bpt>トップページのパフォーマンスのセクション<ept i="0">&lt;/a0&gt;</ept>で既にお見せしているように、コンパイルなどしなくてもすでに高速です。このオプションのコンパイルツールは、いわば「ケーキの上のデコレーション」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This page aims to provide a comparison between Mithril and some of the most widely used frameworks, as well as some of the younger, but relevant ones.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T015911Z" creationid="shibukawa.yoshiki" creationdate="20150417T015911Z">
        <seg>このページではMithrilと他のよく使われるフレームワークの違いについて説明します。中には関連しているが、まだまだ若いものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This pattern is useful to decouple chains of dependencies (however care should be taken to avoid "come-from hell", i.e. difficulty in following a chains of events because they are too numerous and arbitrarily inter-dependent)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025524Z" creationid="shibukawa.yoshiki" creationdate="20150502T025524Z">
        <seg>このパターンは依存関係の鎖を分離するのに役立ちます。しかし、数多くの内部依存関係を持つことによって、イベントの連鎖を追いかけるのが難しくなる「地獄からやってくる」ケースに陥らないように注意する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This redirects to the URL <bpt i="0" x="0">&lt;c0&gt;</bpt>http://server/#/dashboard/johndoe<ept i="0">&lt;/c0&gt;</ept> and yields:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003359Z" creationid="shibukawa.yoshiki" creationdate="20150410T003359Z">
        <seg>これを実行すると、<bpt i="0" x="0">&lt;c0&gt;</bpt>http://server/#/dashboard/johndoe<ept i="0">&lt;/c0&gt;</ept>にリダイレクトして、下記のタグを挿入します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rendering technique is known as <bpt i="1" x="1">&lt;e1&gt;</bpt>virtual DOM diffing<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072607Z" creationid="shibukawa.yoshiki" creationdate="20150502T072604Z">
        <seg>このレンダリング技術は<bpt i="1" x="1">&lt;e1&gt;</bpt>仮想DOMの差分検知<ept i="1">&lt;/e1&gt;</ept>と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This renders the following markup:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013720Z" creationid="shibukawa.yoshiki" creationdate="20150408T013720Z">
        <seg>このメソッド呼び出しをすると、次のようなマークアップが生成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This returns the portion of the URL determined by <bpt i="1" x="1">&lt;c1&gt;</bpt>m.route.mode<ept i="1">&lt;/c1&gt;</ept> (minus the <bpt i="2" x="2">&lt;c2&gt;</bpt>?<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>#<ept i="3">&lt;/c3&gt;</ept> symbols for the <bpt i="4" x="4">&lt;c4&gt;</bpt>search<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>hash<ept i="5">&lt;/c5&gt;</ept> modes, respectively).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172128Z" creationid="shibukawa.yoshiki" creationdate="20150414T172128Z">
        <seg>この関数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.route.mode<ept i="1">&lt;/c1&gt;</ept>で決定されるURLのパーツ(マイナス<bpt i="2" x="2">&lt;c2&gt;</bpt>?<ept i="2">&lt;/c2&gt;</ept>もしくは<bpt i="3" x="3">&lt;c3&gt;</bpt>#<ept i="3">&lt;/c3&gt;</ept>シンボル - それぞれ<bpt i="4" x="4">&lt;c4&gt;</bpt>search<ept i="4">&lt;/c4&gt;</ept>モードと<bpt i="5" x="5">&lt;c5&gt;</bpt>hash<ept i="5">&lt;/c5&gt;</ept> モード時)を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This route would be selected if the URL was <bpt i="2" x="2">&lt;c2&gt;</bpt>/path/to/page/1<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>/path/to/page/test<ept i="3">&lt;/c3&gt;</ept>, etc</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T160207Z" creationid="shibukawa.yoshiki" creationdate="20150414T160207Z">
        <seg>このラウとは、<bpt i="2" x="2">&lt;c2&gt;</bpt>/path/to/page/1<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>/path/to/page/test<ept i="3">&lt;/c3&gt;</ept>といったURLが指定された場合に選択されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This should be either <bpt i="0" x="0">&lt;c0&gt;</bpt>window<ept i="0">&lt;/c0&gt;</ept> or a mock of the <bpt i="1" x="1">&lt;c1&gt;</bpt>window<ept i="1">&lt;/c1&gt;</ept> object.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T161447Z" creationid="shibukawa.yoshiki" creationdate="20150416T161447Z">
        <seg>この引数は<bpt i="0" x="0">&lt;c0&gt;</bpt>window<ept i="0">&lt;/c0&gt;</ept>もしくはモック<bpt i="1" x="1">&lt;c1&gt;</bpt>window<ept i="1">&lt;/c1&gt;</ept>オブジェクト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This special parameter allows you to call methods on the DOM element after it gets created.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123355Z" creationid="shibukawa.yoshiki" creationdate="20150413T123355Z">
        <seg>この特別なパラメータを使うと、DOMエレメントの精製後にその要素に対してメソッドが呼べるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This step is meant to be done in the controller layer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124319Z" creationid="shibukawa.yoshiki" creationdate="20150410T124319Z">
        <seg>このステップはコントローラレイヤ内で完結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This step is meant to be done in the model layer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T123925Z" creationid="shibukawa.yoshiki" creationdate="20150410T123925Z">
        <seg>このステップはモデルレイヤ内で完結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This step isn't required in order to use Mithril, but it's an easy way to squeeze a little bit more performance out of an application, without the need for code changes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143904Z" creationid="shibukawa.yoshiki" creationdate="20150412T143904Z">
        <seg>このステップはMithrilを使う上で必須のものではありませんが、コードを一切変更せずにアプリケーション外で簡単にパフォーマンスを少し向上させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This string should be a CSS rule that represents a DOM element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150546Z" creationid="shibukawa.yoshiki" creationdate="20150413T150546Z">
        <seg>DOMエレメントを表現するCSSルールの文字列を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This syntax allows you to bind intermediate results before piping them down for further processing, for example:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T020233Z" creationid="shibukawa.yoshiki" creationdate="20150410T020233Z">
        <seg>この文法を使うと、パイプ処理が次の処理を起動する前に中間結果を束縛することができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This tool is also available as a <bpt i="0" x="0">&lt;a0&gt;</bpt>Rails gem<ept i="0">&lt;/a0&gt;</ept>, created by Jordan Humphreys.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014137Z" creationid="shibukawa.yoshiki" creationdate="20150417T014137Z">
        <seg>このツールは、 Jordan Humphreysが作成した<bpt i="0" x="0">&lt;a0&gt;</bpt>Rails gem<ept i="0">&lt;/a0&gt;</ept>でも提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value can be programmatically changed in controllers and event handlers to modify the next redrawing strategy.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152459Z" creationid="shibukawa.yoshiki" creationdate="20150416T152459Z">
        <seg>この値は、コントローラとイベントハンドラの中で設定することができます。これは次に行われるの再描画の戦略にのみ作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This will allow the compiler to type-check calls to the Mithril API.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014405Z" creationid="shibukawa.yoshiki" creationdate="20150417T014405Z">
        <seg>コンパイラがMithril API呼び出しに対して型チェックが行えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This will provide all the polyfills required for the browser.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014706Z" creationid="shibukawa.yoshiki" creationdate="20150417T014706Z">
        <seg>このライブラリはブラウザで必要とされるすべての足りない機能を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To avoid surprises, be sure to change only attribute values, using <bpt i="1" x="1">&lt;c1&gt;</bpt>undefined<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>null<ept i="2">&lt;/c2&gt;</ept> as values if appropriate, rather than conditionally substituting attribute dictionaries altogether.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144324Z" creationid="shibukawa.yoshiki" creationdate="20150413T144324Z">
        <seg>想定外の事態を避けるには、<bpt i="1" x="1">&lt;c1&gt;</bpt>undefined<ept i="1">&lt;/c1&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>null<ept i="2">&lt;/c2&gt;</ept>を使って属性の値だけを変更するようにしてください。条件によって属性の辞書そのものを置き換えるコードは避けましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To compile a file, type:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150219Z" creationid="shibukawa.yoshiki" creationdate="20150412T150219Z">
        <seg>ファイルをコンパイルするには次のようにタイプします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To define a list of routes, you need to specify a host DOM element, a default route and a key-value map of possible routes and respective <bpt i="0" x="0">&lt;a0&gt;</bpt>components<ept i="0">&lt;/a0&gt;</ept> to be rendered.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135028Z" creationid="shibukawa.yoshiki" creationdate="20150502T135028Z">
        <seg>ラウトを定義する時は、ホストとなるDOM要素と、デフォルトのラウト、あとは遷移する可能性のあるラウトとそれをレンダリングするための<bpt i="0" x="0">&lt;a0&gt;</bpt>コンポーネント<ept i="0">&lt;/a0&gt;</ept>のキー・バリューのマップが必要となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To define a list of routes, you need to specify a host DOM element, a default route and a key-value map of possible routes and respective <bpt i="0" x="0">&lt;a0&gt;</bpt>modules<ept i="0">&lt;/a0&gt;</ept> to be rendered.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002722Z" creationid="shibukawa.yoshiki" creationdate="20150409T162838Z">
        <seg>ラウトを定義する時は、ホストとなるDOM要素と、デフォルトのラウト、あとは遷移する可能性のあるラウトとそれをレンダリングするための<bpt i="0" x="0">&lt;a0&gt;</bpt>モジュール<ept i="0">&lt;/a0&gt;</ept>のキー・バリューのマップが必要となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To illustrate the difference between Mithril and A+ promises, consider the code below:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140322Z" creationid="shibukawa.yoshiki" creationdate="20150415T140310Z">
        <seg>下記のコードを使用して、MithrilとA+ promisesの違いを紹介します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To implement flow control in Mithril views, we simply use Javascript Array methods:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152856Z" creationid="shibukawa.yoshiki" creationdate="20150408T152849Z">
        <seg>JavaScriptの配列のメソッドを使うだけで、Mithrilのビューでフローコントロールを実装することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To install SweetJS, NodeJS provides a command-line package manager tool.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150153Z" creationid="shibukawa.yoshiki" creationdate="20150412T150153Z">
        <seg>SweetJSをインストールするのに使うコマンドラインのパッケージマネージャは、NodeJSが提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To install it, go to its website and use the installer provided.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150117Z" creationid="shibukawa.yoshiki" creationdate="20150412T150117Z">
        <seg>NodeJSをインストールするには、NodeJSのウェブサイトに行き、提供されているインストーラを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To integrate synchronous code, call <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> at the beginning of the method, and <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> at the end.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193105Z" creationid="shibukawa.yoshiki" creationdate="20150411T193105Z">
        <seg>同期処理のコードと統合する場合は、メソッドの先頭で<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept>を呼んで、最後に<bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To maintain the identities of DOM elements, you need to add a <bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept> property to the direct children of the array that you're planning to modify.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T142044Z" creationid="shibukawa.yoshiki" creationdate="20150413T142044Z">
        <seg>DOM要素の識別子を維持するには、変更したい配列の子供に、<bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept>プロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make JSON-P requests, add the <bpt i="0" x="0">&lt;c0&gt;</bpt>dataType<ept i="0">&lt;/c0&gt;</ept> option instead of <bpt i="1" x="1">&lt;c1&gt;</bpt>method<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T234822Z" creationid="shibukawa.yoshiki" creationdate="20150414T234756Z">
        <seg>JSONPリクエストを行うには、<bpt i="1" x="1">&lt;c1&gt;</bpt>method<ept i="1">&lt;/c1&gt;</ept>ではなく、<bpt i="0" x="0">&lt;c0&gt;</bpt>dataType<ept i="0">&lt;/c0&gt;</ept>を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To optimize rendering, you should add a <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> call before the first widget initialization call, and a <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> after the last widget initialization call in each execution thread.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T141303Z" creationid="shibukawa.yoshiki" creationdate="20150412T141303Z">
        <seg>レンダリングを初期化するには、それぞれの実行スレッドの中で、最初のウィジェットの初期化の前に<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept>を呼び出し、最後のウィジェットの初期化の後に<bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を呼び出すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To prevent unloading when attempting to navigate away from a page, you can check the return value of <bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092352Z" creationid="shibukawa.yoshiki" creationdate="20150502T092352Z">
        <seg>他のページに遷移しようとしたときに、アンロードが中断されたかどうかを知るには、<bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount<ept i="1">&lt;/c1&gt;</ept>の返り値をチェックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To render a string as HTML, see <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.trust<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155543Z" creationid="shibukawa.yoshiki" creationdate="20150413T155543Z">
        <seg>文字列をHTMLとしてレンダリングしたい場合は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.trust<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To run the automation task, run the following command from the root folder of your project:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150823Z" creationid="shibukawa.yoshiki" creationdate="20150412T150823Z">
        <seg>自動化処理を実行するには、プロジェクトのルートフォルダで次のようにタイプします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To run the execution time tests below, click on their respective links, run the profiler from your desired browser's developer tools and measure the running time of a page refresh (Lower is better).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134936Z" creationid="shibukawa.yoshiki" creationdate="20150407T134936Z">
        <seg>下記の実行時間のテストを行う場合は、それぞれのリンクをクリックして、好きなブラウザの開発者ツールのプロファイラを起動してページリフレッシュの実行時間を計測してください(数値が少ないほうが良い)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To run the tests for each framework, click on the respective links.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135234Z" creationid="shibukawa.yoshiki" creationdate="20150407T135234Z">
        <seg>各々のフレームワークのテストを実行する場合は、それぞれのリンクをクリックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To unload a component without loading another component, you can simply call <bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept> with a <bpt i="1" x="1">&lt;c1&gt;</bpt>null<ept i="1">&lt;/c1&gt;</ept> as the component parameter:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091517Z" creationid="shibukawa.yoshiki" creationdate="20150502T091517Z">
        <seg>他のコンポーネントをロードせずにコンポーネントをアンロードする場合は、コンポーネントの引数として<bpt i="1" x="1">&lt;c1&gt;</bpt>null<ept i="1">&lt;/c1&gt;</ept>を<bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept>に渡せばできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use the HTML5 FormData object as the payload for a request, you need to override the <bpt i="0" x="0">&lt;c0&gt;</bpt>serialize<ept i="0">&lt;/c0&gt;</ept> option.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175359Z" creationid="shibukawa.yoshiki" creationdate="20150414T175359Z">
        <seg>HTML5 FormDataをリクエストのペイロードとして使うには、<bpt i="0" x="0">&lt;c0&gt;</bpt>serialize<ept i="0">&lt;/c0&gt;</ept>をオーバーライドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use the bleeding edge version from npm, use the following command:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000846Z" creationid="shibukawa.yoshiki" creationdate="20150408T000833Z">
        <seg>npmを使って最先端のバージョンをインストールするには、次のコマンドを使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Todos are self-contained and their data aren't tied to the DOM like in typical jQuery based code.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T234340Z" creationid="shibukawa.yoshiki" creationdate="20150408T234340Z">
        <seg>Todoのコードは他のコードなどへの依存もなく、疎結合でまとまっています。jQueryベースのコードと違って、DOMと密結合していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tools - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T013337Z" creationid="shibukawa.yoshiki" creationdate="20150417T013310Z">
        <seg>便利なツール - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Trusted HTML is allowed to render arbitrary, potentially invalid markup, as well as run arbitrary Javascript, and therefore the developer is responsible for either:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013853Z" creationid="shibukawa.yoshiki" creationdate="20150416T013728Z">
        <seg>信用されたHTMLは、そのままレンダリングされます。そのソースは不正なマークアップであったり、そのままJavaScriptとして実行されるものである場合もありますが、この次の項目の責任は開発者が負います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typescript Support</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014243Z" creationid="shibukawa.yoshiki" creationdate="20150417T014243Z">
        <seg>TypeScriptサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically <bpt i="4" x="4">&lt;c4&gt;</bpt>resolve<ept i="4">&lt;/c4&gt;</ept>/<bpt i="5" x="5">&lt;c5&gt;</bpt>reject<ept i="5">&lt;/c5&gt;</ept> are called asynchronously after the <bpt i="6" x="6">&lt;c6&gt;</bpt>then<ept i="6">&lt;/c6&gt;</ept> method is called, so normally this difference does not matter.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T140610Z" creationid="shibukawa.yoshiki" creationdate="20150415T140533Z">
        <seg>一般的には、<bpt i="4" x="4">&lt;c4&gt;</bpt>resolve<ept i="4">&lt;/c4&gt;</ept>/<bpt i="5" x="5">&lt;c5&gt;</bpt>reject<ept i="5">&lt;/c5&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt>then<ept i="6">&lt;/c6&gt;</ept>メソッドが呼ばれた後に非同期で呼ばれます。一般的にはこの差はそれほど大きな問題ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically this is required in three situations:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T125458Z" creationid="shibukawa.yoshiki" creationdate="20150410T125447Z">
        <seg>一般的に、この機能は以下の3つの場面で必要となります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically, <bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept> don't need to be called from application space.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T152936Z" creationid="shibukawa.yoshiki" creationdate="20150416T152936Z">
        <seg>多くの場合、アプリケーション空間から<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>を呼ぶ必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically, it's used in conjunction with <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.prop<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> to implement data binding in the view-to-model direction.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140249Z" creationid="shibukawa.yoshiki" creationdate="20150414T140249Z">
        <seg>一般的に、この関数は<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.prop<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>と組み合わせて、ビューからモデル方向のデータバインディングを作成するのに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically, model entities are reusable and live outside of components (e.g. <bpt i="0" x="0">&lt;c0&gt;</bpt>var User = ...<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040711Z" creationid="shibukawa.yoshiki" creationdate="20150502T040711Z">
        <seg>モデルの実体は再利用可能なため、コンポーネントの外で定義されることが多いです (例: <bpt i="0" x="0">&lt;c0&gt;</bpt>var User = ...<ept i="0">&lt;/c0&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically, this rate is around 60 calls per second.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020327Z" creationid="shibukawa.yoshiki" creationdate="20150421T020327Z">
        <seg>通常は一秒間に60回呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically, when separating MVC layers, it's common that the namespace declaration be in the model layer, since this is usually the most used dependency for the other layers.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015353Z" creationid="shibukawa.yoshiki" creationdate="20150421T015353Z">
        <seg>一般的に、MVCレイヤーを分割する場合は、モデルレイヤー内で名前空間を定義すべきです。モデルレイヤーは他の全てのレイヤーが依存するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically, you should not even be using inline styles to begin with (unless you are dynamically changing them).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013449Z" creationid="shibukawa.yoshiki" creationdate="20150413T013449Z">
        <seg>一般的に動的に値を変更する時以外は、インラインでのスタイル設定は使用すべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unchecked Error Handling</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T141001Z" creationid="shibukawa.yoshiki" creationdate="20150415T141001Z">
        <seg>チェックしていないエラーのハンドリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike some frameworks, Mithril tries very hard to avoid locking you into a web of dependencies: you can use as <bpt i="0" x="0">&lt;e0&gt;</bpt>little<ept i="0">&lt;/e0&gt;</ept> of the framework as you need.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142104Z" creationid="shibukawa.yoshiki" creationdate="20150407T142104Z">
        <seg>他のフレームワークと異なり、Mithrilはクモの巣のような依存関係にとらわれないようにするために多大な努力を払っています。フレームワーク内の<bpt i="0" x="0">&lt;e0&gt;</bpt>必要な部分<ept i="0">&lt;/e0&gt;</ept>だけを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unloading components</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T050641Z" creationid="shibukawa.yoshiki" creationdate="20150502T050641Z">
        <seg>コンポーネントのアンロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Until the promise is resolved, the value of the prop will resolve to <bpt i="0" x="0">&lt;c0&gt;</bpt>undefined<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135403Z" creationid="shibukawa.yoshiki" creationdate="20150414T135403Z">
        <seg>promiseが解決されるまでは、propの値は<bpt i="0" x="0">&lt;c0&gt;</bpt>undefined<ept i="0">&lt;/c0&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unwrapping Response Data</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170850Z" creationid="shibukawa.yoshiki" creationdate="20150410T170850Z">
        <seg>レスポンスデータの展開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updating the value of the description in the model updates the DOM input when Mithril redraws.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015040Z" creationid="shibukawa.yoshiki" creationdate="20150408T015040Z">
        <seg>モデルの中のdescriptionの値を更新すると、Mithirlが再描画を行ってDOMのテキスト入力を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Usage</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154314Z" creationid="shibukawa.yoshiki" creationdate="20150412T154314Z">
        <seg>使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Usage of keys</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020816Z" creationid="shibukawa.yoshiki" creationdate="20150421T020816Z">
        <seg>キーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Usage of m.redraw</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015757Z" creationid="shibukawa.yoshiki" creationdate="20150421T015757Z">
        <seg>m.redrawの使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount()<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> or <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>m.route()<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept> to activate a component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130004Z" creationid="shibukawa.yoshiki" creationdate="20150502T130004Z">
        <seg>コンポーネントのアクティベートには、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount()<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>か、<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>m.route()<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Useful Tools</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T141024Z" creationid="shibukawa.yoshiki" creationdate="20150407T141024Z">
        <seg>便利なツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Useful for adding request headers and when using XHR2 features, such as the XMLHttpRequest's <bpt i="2" x="2">&lt;c2&gt;</bpt>upload<ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014152Z" creationid="shibukawa.yoshiki" creationdate="20150415T014152Z">
        <seg>この関数を使うと、リクエストヘッダを追加したり、XMLHttpRequestの<bpt i="2" x="2">&lt;c2&gt;</bpt>upload<ept i="2">&lt;/c2&gt;</ept>プロパティなどXHR2の機能を呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using Different Data Transfer Formats</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174826Z" creationid="shibukawa.yoshiki" creationdate="20150410T174826Z">
        <seg>異なるデータ転送フォーマットを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using HTML entities</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T160200Z" creationid="shibukawa.yoshiki" creationdate="20150412T160200Z">
        <seg>HTMLエンティティを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using JSON-P</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T234820Z" creationid="shibukawa.yoshiki" creationdate="20150414T174700Z">
        <seg>JSONPの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using bleeding edge from NPM</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000758Z" creationid="shibukawa.yoshiki" creationdate="20150408T000758Z">
        <seg>NPMで最先端のバージョンを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using variable data formats</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174611Z" creationid="shibukawa.yoshiki" creationdate="20150414T174611Z">
        <seg>可変データ・フォーマットの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Usually it's recommended that you store application state outside of components (either in a <bpt i="0" x="0">&lt;a0&gt;</bpt>view-model<ept i="0">&lt;/a0&gt;</ept> or in the top-level component in the case of nested components).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T082350Z" creationid="shibukawa.yoshiki" creationdate="20150502T082350Z">
        <seg>通常は、アプリケーションの状態は、<bpt i="0" x="0">&lt;a0&gt;</bpt>ビューモデル<ept i="0">&lt;/a0&gt;</ept>か、ネストされたコンポーネントの場合は最上位のコンポーネント以外のコンポーネントに持たせるべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Utilities to integrate asynchronous contexts to the rendering system</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T154215Z" creationid="shibukawa.yoshiki" creationdate="20150412T154215Z">
        <seg>非同期のコンテキストをMithrilのレンダリングシステムに統合するためのユーティリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Values' types should match the expected type for the respective attribute.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153600Z" creationid="shibukawa.yoshiki" creationdate="20150413T153600Z">
        <seg>型は値の、それぞれの属性が期待する型とマッチする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variadic routes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T152313Z" creationid="shibukawa.yoshiki" creationdate="20150414T152313Z">
        <seg>可変個引数のラウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>View</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004128Z" creationid="shibukawa.yoshiki" creationdate="20150408T004128Z">
        <seg>ビュー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>View Layer Paradigm</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T145622Z" creationid="shibukawa.yoshiki" creationdate="20150417T145622Z">
        <seg>ビューレイヤーパラダイム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>View-Model</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T152214Z" creationid="shibukawa.yoshiki" creationdate="20150407T152214Z">
        <seg>ビュー・モデル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>View-models are also responsible for handling business logic that revolves around UI-specific restrictions.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T153025Z" creationid="shibukawa.yoshiki" creationdate="20150407T153025Z">
        <seg>ビューモデルはUI固有の制約に関するビジネスロジックを処理する責任を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Views in Mithril use a virtual DOM diff implementation, which sidesteps performance problems related to opaque dirty-checking and excessive browser repaint that are present in some frameworks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T021414Z" creationid="shibukawa.yoshiki" creationdate="20150409T014712Z">
        <seg>Mithrilのビューは仮想DOMの差分実装を使用していて、いくつかのフレームワークが持っている不透明要素のダーティチェックやパフォーマンス上の問題といった問題を解決しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Virtual DOM diffing and compilable templates</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T134014Z" creationid="shibukawa.yoshiki" creationdate="20150407T134014Z">
        <seg>Virtual DOM差分更新と、コンパイル可能なテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Vue is a relatively new templating engine, but it boasts impressive results in its performance benchmark.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T105928Z" creationid="shibukawa.yoshiki" creationdate="20150420T105928Z">
        <seg>Vueは比較的新しいテンプレートエンジンですが、パフォーマンスのベンチマークでは目覚ましい結果を残しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Vue's implementation cleverly hijacks array methods, but it should be noted that Javascript Arrays cannot be truly subclassed and as such, Vue suffers from abstraction leaks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T110434Z" creationid="shibukawa.yoshiki" creationdate="20150420T110434Z">
        <seg>Vueの実装は巧妙に配列のメソッドをハイジャックします。JavaScriptの配列をきちんとサブクラス化することが難しくなるため、抽象化の漏れに直面することがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Warning: this section is likely biased.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015053Z" creationid="shibukawa.yoshiki" creationdate="20150420T015053Z">
        <seg>注意: このセクションの説明にはバイアスがかかっているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can append an ellipsis (<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>) to the name of a route argument to allow it to match URL snippets that contain slashes:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T153907Z" creationid="shibukawa.yoshiki" creationdate="20150414T153907Z">
        <seg>省略記号(<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>)をラウトの引数の名前に付けると、スラッシュを含むURLにマッチさせることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We declare this outside of the <bpt i="2" x="2">&lt;c2&gt;</bpt>select2.view<ept i="2">&lt;/c2&gt;</ept> function to avoid cluttering the template.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T133638Z" creationid="shibukawa.yoshiki" creationdate="20150412T133638Z">
        <seg>テンプレートが散乱するのを避けるために、<bpt i="2" x="2">&lt;c2&gt;</bpt>select2.view<ept i="2">&lt;/c2&gt;</ept>関数の外側にこの関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We only evaluate the getter-setter to get its value in the controller method.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151744Z" creationid="shibukawa.yoshiki" creationdate="20150408T151744Z">
        <seg>Mithrilは、getter-setterをcontrollerメソッド内でしか評価しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll see how to define a component in a bit.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135132Z" creationid="shibukawa.yoshiki" creationdate="20150502T135132Z">
        <seg>どのようにコンポーネントを定義するか見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We'll see how to define a module in a bit.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T002911Z" creationid="shibukawa.yoshiki" creationdate="20150410T002911Z">
        <seg>どのようにモジュールを定義するか見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Web Services</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140740Z" creationid="shibukawa.yoshiki" creationdate="20150407T140740Z">
        <seg>ウェブサービス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Web Services - Mithril</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013833Z" creationid="shibukawa.yoshiki" creationdate="20150410T013833Z">
        <seg>ウェブサービス - Mithril</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Weekly articles on how to use Mithril to its full potential.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T135705Z" creationid="shibukawa.yoshiki" creationdate="20150407T135705Z">
        <seg>Mithrilのポテンシャルを引き出す使い方を紹介するブログです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>What is Mithril?</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T140447Z" creationid="shibukawa.yoshiki" creationdate="20150407T132200Z">
        <seg>Mithrilとは？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="0" x="0">&lt;a0&gt;</bpt>integrating with third party libraries<ept i="0">&lt;/a0&gt;</ept>, you might find that you need to call asynchronous methods from outside of Mithril's API.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T004432Z" creationid="shibukawa.yoshiki" creationdate="20150412T004432Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>サードパーティ製のライブラリを統合する時に<ept i="0">&lt;/a0&gt;</ept>、MithrilのAPIの外で非同期メソッドが使っているものもあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept> is called, the controller function runs, and its return value is returned by the <bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount<ept i="1">&lt;/c1&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T125637Z" creationid="shibukawa.yoshiki" creationdate="20150502T125637Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept>が呼ばれると、controller関数が実行されて、それが<bpt i="1" x="1">&lt;c1&gt;</bpt>m.mount<ept i="1">&lt;/c1&gt;</ept>の返り値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a attribute name expects different types for the value in HTML and Javascript, the Javascript type should be used.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153800Z" creationid="shibukawa.yoshiki" creationdate="20150413T153800Z">
        <seg>もし、指定された属性名がHTMLとJavaScriptで異なる型を期待している場合は、JavaScriptの型が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a component has asynchronous payloads and they are queued by the <bpt i="0" x="0">&lt;a0&gt;</bpt>auto-redrawing system<ept i="0">&lt;/a0&gt;</ept>, its view is NOT rendered until all asynchronous operations complete.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093644Z" creationid="shibukawa.yoshiki" creationdate="20150502T093644Z">
        <seg>もしコンポーネントが非同期のロードを行っていて、<bpt i="0" x="0">&lt;a0&gt;</bpt>再描画システム<ept i="0">&lt;/a0&gt;</ept>のカウンター操作を行っている場合は、非同期操作が完了するまでは再描画が行われることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When calling multiple background AJAX requests, it's recommended that you use <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.sync<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> to batch redraw once at the end of all requests, as opposed to repeatedly redrawing after every request:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T134537Z" creationid="shibukawa.yoshiki" creationdate="20150502T134537Z">
        <seg>複数のバックグラウンドのAJAXリクエストを行った場合は、個別のリクエストの完了後に再描画を行うのではなく、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.sync<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を使って待ち合わせを行い、一度だけ再描画を行うのが推奨です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When components aren't nested, Mithril waits for all asynchronous tasks to complete, but when components are nested, a component's parent view renders before the component completes its asynchronous tasks.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093241Z" creationid="shibukawa.yoshiki" creationdate="20150502T093241Z">
        <seg>コンポーネントがネストされていないとMithrilはすべての非同期タスクが完了するのを待ちますが、ネストされていると非同期タスクの完了前に親コンポーネントが再描画することがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When computation methods are used dilligently and religiously, templates are never redrawn with incomplete data.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T115359Z" creationid="shibukawa.yoshiki" creationdate="20150502T115359Z">
        <seg>computationメソッドを使うと、未完了のデータをテンプレートが利用することがなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When dealing with asynchronous functions, you must call [<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>] if you want the asynchronous payload to affect the view.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135455Z" creationid="shibukawa.yoshiki" creationdate="20150415T135455Z">
        <seg>非同期関数を使用して、その非同期で取得してきた値をビューに反映させたい時は、[<bpt i="0" x="0">&lt;c0&gt;</bpt>m.startComputation<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>m.endComputation<ept i="1">&lt;/c1&gt;</ept>]を呼ぶ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When refactoring is unavoidable, the developer can simply replace the <bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept> call with an appropriate getter-setter implementation, instead of having to grep for API usage across the entire application.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002313Z" creationid="shibukawa.yoshiki" creationdate="20150409T002313Z">
        <seg>リファクタリングが避けられなくなったら、<bpt i="0" x="0">&lt;c0&gt;</bpt>m.prop<ept i="0">&lt;/c0&gt;</ept>呼び出しを、適切なgetter-setter実装に置き換えるだけで済みます。プログラム全体をgrepしてAPIを使っている箇所を検索して置き換える必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the URL matches a route, the respective component's controller is instantiated and passed as a parameter to the view.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135208Z" creationid="shibukawa.yoshiki" creationdate="20150502T135208Z">
        <seg>URLがラウトにマッチすると、対応するコンポーネントのコントローラがインスタンス化されて、引数としてビューに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the URL matches a route, the respective module's controller is instantiated and passed as a parameter to the view.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003820Z" creationid="shibukawa.yoshiki" creationdate="20150410T003820Z">
        <seg>URLがラウトにマッチすると、対応するモジュールのコントローラがインスタンス化されて、引数としてビューに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the component's asynchronous operations complete, another redraw is triggered and the entire template tree is evaluated again.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T093753Z" creationid="shibukawa.yoshiki" creationdate="20150502T093753Z">
        <seg>コンポーネントの非同期操作が完了すると、他の再描画が起動されて、テンプレートのツリー全体を再び再評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the flag is set to "all", Mithril throws away the current view and redraws from scratch.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T140607Z" creationid="shibukawa.yoshiki" creationdate="20150416T140607Z">
        <seg>このフラグが"all"に設定されると、Mithrilは現在のビューをすべて破棄し、ゼロから再描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the flag is set to "diff", Mithril performs a diff between the old view and the new view and applies patches to the DOM only where needed.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143423Z" creationid="shibukawa.yoshiki" creationdate="20150416T143423Z">
        <seg>このフラグが"diff"に設定されると、Mithrilは古いビューと新しいビューの間の差分の検知を行い必要な箇所にだけ差分を適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the flag is set to "none", Mithril skips the next redraw.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143445Z" creationid="shibukawa.yoshiki" creationdate="20150416T143445Z">
        <seg>フラグが"none"に設定されるとMithrilは次の再描画をスキップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When updates happen, the template is not wholly re-rendered - only the changes are applied.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T160905Z" creationid="shibukawa.yoshiki" creationdate="20150408T160905Z">
        <seg>更新が発生した場合は、全体の再描画は行われずに、変更があった箇所だけ更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When using the <bpt i="0" x="0">&lt;a0&gt;</bpt>router<ept i="0">&lt;/a0&gt;</ept>, a route change recreates the DOM tree from scratch in order to unload plugins from the previous page.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T130655Z" creationid="shibukawa.yoshiki" creationdate="20150413T130655Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>router<ept i="0">&lt;/a0&gt;</ept>を使用している時は、ラウトが変更されると、前のページで使用されていたプラグインをアンロードするために、DOMツリーがスクラッチから再生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When we get there, I'll explain why we're passing description as an argument instead of simply using OOP-style member association.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163625Z" creationid="shibukawa.yoshiki" creationdate="20150407T163439Z">
        <seg>準備が整ったところで、なぜこのサンプルではオブジェクト指向プログラミングのスタイルのメンバーの関連付けを行わずに、descriptionを引数として渡すのかを説明しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whether routing uses location hash, querystring or pathname</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T153641Z" creationid="shibukawa.yoshiki" creationdate="20150412T153641Z">
        <seg>ラウティングがハッシュ、クエリー文字列、パス名のどのモードを使用するか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whether this is the first time we are running this function on this element.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T155116Z" creationid="shibukawa.yoshiki" creationdate="20150413T155116Z">
        <seg>関数がこのエレメントに対して実行されるのが初回かどうかを表すフラグです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While Mithril doesn't dictate how to organize your code, it does provide some recommendations for structuring it.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T014003Z" creationid="shibukawa.yoshiki" creationdate="20150421T014003Z">
        <seg>Mithrilは、手取り足取りコードを構造化させることはありませんが、アプリケーションの構造として推奨していることがいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While Mithril technically does support this use case, relying on multiple redraw passes degrades performance and makes it possible to code yourself into an infinite execution loop situation, which is extremely difficult to debug.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T135828Z" creationid="shibukawa.yoshiki" creationdate="20150412T135828Z">
        <seg>Mithrilは技術的にこのユースケースをサポートしていないため、再描画が何度も行われてパフォーマンスが低下したりしますし、場合によってはアプリケーションコードが無限ループして、デバッグが極めて難しい状況になったりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While at first glance, it may seem expensive to run a global redraw every time data changes, Mithril makes it possible to do this efficiently thanks to its fast diffing algorithm, which only updates the DOM where it needs to be updated.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T184052Z" creationid="shibukawa.yoshiki" creationdate="20150411T184052Z">
        <seg>初めて見るとデータ変更があるたびに全体を再描画するのは高コストに見えると思いますが、変更のあるDOMだけを更新するという高速な差分アルゴリズムを使い、Mithrilでは効率的にこれを行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While both basic assignment syntax and thennable syntax can be used to the same effect, typically it's recommended that you use the assignment syntax in the first example whenever possible, as it's easier to read.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T022931Z" creationid="shibukawa.yoshiki" creationdate="20150410T022931Z">
        <seg>代入構文も、thennableを使った構文も同じ結果になりますが、前者の例の方が読みやすいため、何か制約がない限りはこちらを使用する方がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While both basic assignment syntax and thennable syntax can be used to the same effect, typically it's recommended that you use the assignment syntax whenever possible, as it's easier to read.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174926Z" creationid="shibukawa.yoshiki" creationdate="20150414T174926Z">
        <seg>代入構文も、thennableを使った構文も同じ結果になりますが、前者の例の方が読みやすいため、何か制約がない限りはこちらを使用する方がおすすめです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While superficially this may seem like an odd design, this actually has a lot of benefits:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T013155Z" creationid="shibukawa.yoshiki" creationdate="20150409T013155Z">
        <seg>ぱっと見ると、これはとても奇妙な設計に見えますが、実際には多くのメリットがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While this decision allows better API discoverability, the trade-off is that we're largely giving up on custom constraints and behavior.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T003021Z" creationid="shibukawa.yoshiki" creationdate="20150409T003021Z">
        <seg>既に慣れ親しんでいるAPIが使えるようになったトレードオフとして、カスタムの動作を行うことができなくなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With this, we can make the <bpt i="0" x="0">&lt;c0&gt;</bpt>onclick<ept i="0">&lt;/c0&gt;</ept> binding on the template <bpt i="1" x="1">&lt;e1&gt;</bpt>much<ept i="1">&lt;/e1&gt;</ept> simpler:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152559Z" creationid="shibukawa.yoshiki" creationdate="20150408T152559Z">
        <seg>これにより、テンプレートの<bpt i="0" x="0">&lt;c0&gt;</bpt>onclick<ept i="0">&lt;/c0&gt;</ept>バインディングを<bpt i="1" x="1">&lt;e1&gt;</bpt>もっとシンプルに<ept i="1">&lt;/e1&gt;</ept>書くことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With those methods and properties, it creates a template that can consume model data and call controller methods to affect the model.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T062103Z" creationid="shibukawa.yoshiki" creationdate="20150502T062103Z">
        <seg>これらのメソッドとプロパティを使い、モデルデータを利用したり、モデルを変化させるコントローラのメソッドを呼んだりするテンプレートを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Yes, this is valid HTML 5!</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T142725Z" creationid="shibukawa.yoshiki" creationdate="20150407T142725Z">
        <seg>そうです。これは完全なHTML5です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You are encouraged to use CSS selectors to define virtual elements.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T235303Z" creationid="shibukawa.yoshiki" creationdate="20150412T235303Z">
        <seg>仮想エレメントを定義するときはCSSセレクタを使うのが推奨です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You are responsible for ensuring that templates aren't too big to render efficiently.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T020812Z" creationid="shibukawa.yoshiki" creationdate="20150421T020812Z">
        <seg>そのため、テンプレートが大きくなりすぎないようにして、レンダリングを効率よく行うことが大切です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can <bpt i="0" x="0">&lt;a0&gt;</bpt>download a zip of the latest version version here<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T164534Z" creationid="shibukawa.yoshiki" creationdate="20150407T164534Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>ここから<ept i="0">&lt;/a0&gt;</ept>最新バージョンのzipアーカイブをダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also <bpt i="6" x="6">&lt;a6&gt;</bpt>learn how the redrawing system works here<ept i="6">&lt;/a6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015009Z" creationid="shibukawa.yoshiki" creationdate="20150413T015009Z">
        <seg>また、<bpt i="6" x="6">&lt;a6&gt;</bpt>こちらのドキュメントで再描画システムがどのように動くのか<ept i="6">&lt;/a6&gt;</ept>学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also configure individual elements to always be diffed, instead of recreated from scratch (even across route changes), by using the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>ctx.retain<ept i="1">&lt;/c1&gt;</ept> flag<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T133256Z" creationid="shibukawa.yoshiki" creationdate="20150502T133256Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>ctx.retain<ept i="1">&lt;/c1&gt;</ept>フラグ<ept i="0">&lt;/a0&gt;</ept>を使うと、個別のエレメントに対してラウトの変更であっても、常に差分検知を行わずに再生成させないように指示することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also find Mithril in <bpt i="0" x="0">&lt;a0&gt;</bpt>cdnjs<ept i="0">&lt;/a0&gt;</ept> and <bpt i="1" x="1">&lt;a1&gt;</bpt>jsDelivr<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T165214Z" creationid="shibukawa.yoshiki" creationdate="20150407T165214Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>cdnjs<ept i="0">&lt;/a0&gt;</ept>と<bpt i="1" x="1">&lt;a1&gt;</bpt>jsDelivr<ept i="1">&lt;/a1&gt;</ept>の中から取得することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also fork the latest stable project <bpt i="0" x="0">&lt;a0&gt;</bpt>directly from Github<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T000257Z" creationid="shibukawa.yoshiki" creationdate="20150408T000257Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>Githubから直接<ept i="0">&lt;/a0&gt;</ept>、最新の安定版のプロジェクトをフォークすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also specify what attribute to bind.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T021800Z" creationid="shibukawa.yoshiki" creationdate="20150408T021800Z">
        <seg>また、どの属性と結びつけるかも自由に設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use it to attach events to other elements (for example, <bpt i="0" x="0">&lt;c0&gt;</bpt>window.onresize<ept i="0">&lt;/c0&gt;</ept>), but you should remove such event handlers via <bpt i="1" x="1">&lt;c1&gt;</bpt>ctx.onunload<ept i="1">&lt;/c1&gt;</ept> to avoid surprises.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124451Z" creationid="shibukawa.yoshiki" creationdate="20150502T124451Z">
        <seg>この機能を使って、<bpt i="0" x="0">&lt;c0&gt;</bpt>window.onresize<ept i="0">&lt;/c0&gt;</ept>などのイベントを他のエレメントに付与することもできますが、その場合はトラブルを避けるために<bpt i="1" x="1">&lt;c1&gt;</bpt>ctx.onunload<ept i="1">&lt;/c1&gt;</ept> を使って確実にイベントハンドラを削除してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use more complex CSS selectors:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000233Z" creationid="shibukawa.yoshiki" creationdate="20150413T000233Z">
        <seg>より複雑なCSSセレクタを使用することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use other polyfills to support these features in IE7.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014826Z" creationid="shibukawa.yoshiki" creationdate="20150417T014826Z">
        <seg>IE7をサポートするためには他のPolyfillが使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use the <bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept> function to PREVENT a component from being unloaded in the context of a route change (i.e. to alert a user to save their changes before navigating away from a page)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091917Z" creationid="shibukawa.yoshiki" creationdate="20150502T091917Z">
        <seg>ラウターの変更のコンテキスト内で<bpt i="0" x="0">&lt;c0&gt;</bpt>onunload<ept i="0">&lt;/c0&gt;</ept>関数を使うことで、モジュールがアンロードされるのを中断することができます。これはページ移動前にデータ変更することを警告する時などに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use the <bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept> syntax to add CSS classes and the <bpt i="2" x="2">&lt;c2&gt;</bpt>#<ept i="2">&lt;/c2&gt;</ept> to add an id.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004414Z" creationid="shibukawa.yoshiki" creationdate="20150408T004414Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept>文法を使ってCSSのクラスを追加したり、<bpt i="2" x="2">&lt;c2&gt;</bpt>#<ept i="2">&lt;/c2&gt;</ept>を使ってidを追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can alternatively include only specific polyfills:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014716Z" creationid="shibukawa.yoshiki" creationdate="20150417T014716Z">
        <seg>特定の</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can bind a pre-existing getter-setter by passing it in as a parameter to a <bpt i="1" x="1">&lt;c1&gt;</bpt>.then<ept i="1">&lt;/c1&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015957Z" creationid="shibukawa.yoshiki" creationdate="20150410T015957Z">
        <seg>あらかじめ作成したgetter-setterを<bpt i="1" x="1">&lt;c1&gt;</bpt>.then<ept i="1">&lt;/c1&gt;</ept>メソッドの引数で渡して束縛することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define a non-HTML-standard attribute called <bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123308Z" creationid="shibukawa.yoshiki" creationdate="20150413T123308Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>config<ept i="0">&lt;/c0&gt;</ept>という名前のHTML標準ではない属性を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can even build components that take other components as first-class-citizen parameters!</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T014444Z" creationid="shibukawa.yoshiki" creationdate="20150409T014444Z">
        <seg>他のコンポーネントを一級市民のパラメータとして受け取るようなコンポーネントも実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can find the <bpt i="0" x="0">&lt;a0&gt;</bpt>Javascript syntax for all the CSS rules here<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013815Z" creationid="shibukawa.yoshiki" creationdate="20150413T013815Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>JavaScript文法におけるCSSのルールはこちら<ept i="0">&lt;/a0&gt;</ept>で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can get around this issue by using <bpt i="0" x="0">&lt;c0&gt;</bpt>extract<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175650Z" creationid="shibukawa.yoshiki" creationdate="20150414T175650Z">
        <seg>この問題を回避するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>extract<ept i="0">&lt;/c0&gt;</ept>を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can learn more about how redrawing heuristics work <bpt i="0" x="0">&lt;a0&gt;</bpt>here<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T161935Z" creationid="shibukawa.yoshiki" creationdate="20150408T161935Z">
        <seg>どのように再描画の仕組みが動作するかは<bpt i="0" x="0">&lt;a0&gt;</bpt>こちら<ept i="0">&lt;/a0&gt;</ept>のドキュメントでより詳しく知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can learn more about keys <bpt i="1" x="1">&lt;a1&gt;</bpt>here<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T090840Z" creationid="shibukawa.yoshiki" creationdate="20150502T090840Z">
        <seg>キーについては<bpt i="1" x="1">&lt;a1&gt;</bpt>ここで<ept i="1">&lt;/a1&gt;</ept>学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can optionally pre-compile templates that use <bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept> by running the <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>template-compiler.sjs<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> macro with <bpt i="3" x="3">&lt;a3&gt;</bpt>Sweet.js<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T143744Z" creationid="shibukawa.yoshiki" creationdate="20150412T143744Z">
        <seg><bpt i="3" x="3">&lt;a3&gt;</bpt>Sweet.js<ept i="3">&lt;/a3&gt;</ept>と一緒に<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>template-compiler.sjs<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>マクロを実行すると、<bpt i="0" x="0">&lt;c0&gt;</bpt>m()<ept i="0">&lt;/c0&gt;</ept>を使用するテンプレートをプリコンパイルすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override this by providing <bpt i="1" x="1">&lt;c1&gt;</bpt>serialize<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>deserialize<ept i="2">&lt;/c2&gt;</ept> options:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174941Z" creationid="shibukawa.yoshiki" creationdate="20150410T174941Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>serialize<ept i="1">&lt;/c1&gt;</ept>オプションと、<bpt i="2" x="2">&lt;c2&gt;</bpt>deserialize<ept i="2">&lt;/c2&gt;</ept>オプションを提供すると、この動作を変更することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can pre-compile Mithril templates to make them run faster.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014212Z" creationid="shibukawa.yoshiki" creationdate="20150417T014212Z">
        <seg>Mithirlのテンプレートは事前にコンパイルすることでさらに高速にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can programmatically redirect to another page.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T012943Z" creationid="shibukawa.yoshiki" creationdate="20150410T012943Z">
        <seg>APIを使用して他のページにリダイレクトすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can read more about the <bpt i="0" x="0">&lt;a0&gt;</bpt>promise exception monitor here<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181922Z" creationid="shibukawa.yoshiki" creationdate="20150414T181922Z">
        <seg>詳細については、<bpt i="0" x="0">&lt;a0&gt;</bpt>こちらのpromiseの例外モニタ<ept i="0">&lt;/a0&gt;</ept>を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can read more about the <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>m.prop<ept i="3">&lt;/c3&gt;</ept> getter-setter utility here<ept i="2">&lt;/a2&gt;</ept> and the <bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>m.withAttr<ept i="5">&lt;/c5&gt;</ept> event handler factory here<ept i="4">&lt;/a4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T014927Z" creationid="shibukawa.yoshiki" creationdate="20150413T014927Z">
        <seg>詳細の情報は<bpt i="2" x="2">&lt;a2&gt;</bpt>こちらの<bpt i="3" x="3">&lt;c3&gt;</bpt>m.prop<ept i="3">&lt;/c3&gt;</ept> getter-setterユーティリティ<ept i="2">&lt;/a2&gt;</ept>と、<bpt i="4" x="4">&lt;a4&gt;</bpt>こちらの<bpt i="5" x="5">&lt;c5&gt;</bpt>m.withAttr<ept i="5">&lt;/c5&gt;</ept>イベントハンドラ<ept i="4">&lt;/a4&gt;</ept>で読むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can see that our classes above fit the criteria: they have all the methods and properties that they need to be assembled into a meaningful state.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T151742Z" creationid="shibukawa.yoshiki" creationdate="20150407T151742Z">
        <seg>上記のサンプルのモデルクラスは、この基準を満たしていることがわかるでしょう。意味のある状態を構成するのに必要なメソッドとプロパティを十分に備えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can set inline styles like this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013132Z" creationid="shibukawa.yoshiki" creationdate="20150413T013132Z">
        <seg>次のようにインラインでスタイルを設定できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can specify an initial value for the <bpt i="2" x="2">&lt;c2&gt;</bpt>m.request<ept i="2">&lt;/c2&gt;</ept> getter-setter in order to avoid having to write defensive code against potential null reference exceptions:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001757Z" creationid="shibukawa.yoshiki" creationdate="20150415T001757Z">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>m.request<ept i="2">&lt;/c2&gt;</ept>に渡すgetter-setterに初期値を渡すという防衛的なコーディングを行えば、null参照例外が発生する可能性を抑えられます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can unescape trusted HTML strings by using <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.trust<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020947Z" creationid="shibukawa.yoshiki" creationdate="20150413T020947Z">
        <seg>信頼できるHTML文字列をエスケープを抑える時は<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.trust<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use Mithril to create SVG documents (as long as you don't need to support browsers that don't support SVG natively).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T140726Z" creationid="shibukawa.yoshiki" creationdate="20150413T140726Z">
        <seg>ネイティブでSVGをサポートしていないブラウザをサポートしたくないと思わない限り、Mithrilを使ってSVGドキュメントを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use both HTML and Javascript attribute names.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T153453Z" creationid="shibukawa.yoshiki" creationdate="20150413T153453Z">
        <seg>HTMLとJavaScriptの両方の属性名を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use it by adding a reference to your Typescript files.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150417T014336Z" creationid="shibukawa.yoshiki" creationdate="20150417T014336Z">
        <seg>これを使用するには、TypeScriptファイルに参照を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use simple tag selectors to make templates resemble HTML:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000004Z" creationid="shibukawa.yoshiki" creationdate="20150413T000004Z">
        <seg>シンプルなタグセレクタを使って、HTMLに似たテンプレートを作成できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use task automation tools such as GruntJS to concatenate the files back together for production.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015208Z" creationid="shibukawa.yoshiki" creationdate="20150421T015208Z">
        <seg>GruntJSのようなタスク自動化ツールを使って、リリース環境向けにファイルを1つにまとめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the view-model like this:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T163701Z" creationid="shibukawa.yoshiki" creationdate="20150407T163701Z">
        <seg>ビュー・モデルは次のように使えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this mechanism to attach custom event listeners to controller methods (for example, when integrating with third party libraries), but you are responsible for making sure the integration with Mithril's autoredrawing system is in place.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T125403Z" creationid="shibukawa.yoshiki" creationdate="20150413T125403Z">
        <seg>この機能を使うと、サードパーティのライブラリを統合する時などに、コントローラのメソッドを呼び出すようなカスタムのイベントハンドラを登録できます。ただし、Mithrilの自動描画システムがきちんと働くようにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can, however, use CSS syntax when defining style rules as inline strings:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013928Z" creationid="shibukawa.yoshiki" creationdate="20150413T013928Z">
        <seg>インラインの文字列を使うことで、CSS文法を使ってスタイルルールを定義することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can, of course, nest virtual elements:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000541Z" creationid="shibukawa.yoshiki" creationdate="20150413T000541Z">
        <seg>もちろん、ネストされた仮想エレメントも作成できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You don't need to call <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.mount<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> to initialize your components if you define a list of routes - <bpt i="3" x="3">&lt;c3&gt;</bpt>m.route<ept i="3">&lt;/c3&gt;</ept> calls it for you.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135114Z" creationid="shibukawa.yoshiki" creationdate="20150502T135114Z">
        <seg>ラウトのリストを定義した場合は、モジュールの初期化をするために<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>m.mount<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>を呼ぶ必要はありません。<bpt i="3" x="3">&lt;c3&gt;</bpt>m.route<ept i="3">&lt;/c3&gt;</ept>が代わりに呼んでくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You don't need to change this flag to something else again later, since Mithril does that for you.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T143529Z" creationid="shibukawa.yoshiki" creationdate="20150416T143529Z">
        <seg>繰り返しになりますが、このフラグを設定する必要はありません。Mithrilが自動で行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You get the ability to automate linting, unit testing and minifying of the entire view layer.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T014412Z" creationid="shibukawa.yoshiki" creationdate="20150409T014304Z">
        <seg>自動文法チェック(lint)、ユニットテスト、ビューレイヤーのminifyといったことも可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may choose to declare the namespace in a separate file or have the build system generate it on demand, instead.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015503Z" creationid="shibukawa.yoshiki" creationdate="20150421T015503Z">
        <seg>ファイルごとに名前空間を用意するか、あるいはビルドシステムに名前空間を作らせるかは開発者の自由です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may return an XHR-like object (e.g. a XDomainRequest instance) to override the provided XHR instance altogether.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014402Z" creationid="shibukawa.yoshiki" creationdate="20150415T014402Z">
        <seg>この関数を使うと、Mithrilが生成したXHRインスタンスの代わりに、XDomainRequestインスタンスなど、XHRのように動作するまったく別のオブジェクトに置き換えることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You might also elect to maintain component state when it's not meaningful outside the scope of a single component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T083740Z" creationid="shibukawa.yoshiki" creationdate="20150502T083740Z">
        <seg>コンポーネント外で管理する意味がない場合は、コンポーネントの状態を維持することを選ぶことになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must add a pair of these calls for each asynchronous execution thread, unless the thread is already integrated.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T134545Z" creationid="shibukawa.yoshiki" creationdate="20150412T134545Z">
        <seg>もしスレッドの統合が終わっていなければ、これらの関数のペアをすべての非同期実行スレッドのコードに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You should always document integration components so that others can find out what attribute parameters can be used to initialize the component.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T140339Z" creationid="shibukawa.yoshiki" creationdate="20150412T140339Z">
        <seg>統合コンポーネントを作成するときは、常にドキュメントを作成し、他の人がコンポーネントの初期化時にどの属性パラメータが使用できるか分かるようにすべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You should always use keys if you need to sort lists, remove items from them or splice them in any way.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T150421Z" creationid="shibukawa.yoshiki" creationdate="20150413T150421Z">
        <seg>リストをソートしたり、要素を削除したり、スプライスする場合は常にキーを使用すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You should avoid grouping classes by the MVC layer they belong to, i.e. don't create three files called model.js, controllers.js and views.js.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T015612Z" creationid="shibukawa.yoshiki" creationdate="20150421T015612Z">
        <seg>MVCレイヤーそのものでクラスをグループ化するのはやめましょう。model.js、controllers.js、views.jsという名前のファイルは作ってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You should avoid instantiating controller classes from views.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150421T033729Z" creationid="shibukawa.yoshiki" creationdate="20150421T033729Z">
        <seg>ビューからコントr−ラのクラスのインスタンスを作成するのは避けましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You should not add the <bpt i="2" x="2">&lt;c2&gt;</bpt>callback<ept i="2">&lt;/c2&gt;</ept> querystring parameter; Mithril already does that internally.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T234856Z" creationid="shibukawa.yoshiki" creationdate="20150414T234818Z">
        <seg>通常のJSONPリクエストで必要になる<bpt i="2" x="2">&lt;c2&gt;</bpt>callback<ept i="2">&lt;/c2&gt;</ept>クエリー文字列パラメータを設定する必要はありません。Mithrilが内部で行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You should not use these methods if your code is intended to run repeatedly (e.g. by using <bpt i="0" x="0">&lt;c0&gt;</bpt>setInterval<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193428Z" creationid="shibukawa.yoshiki" creationdate="20150411T193428Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>setInterval<ept i="0">&lt;/c0&gt;</ept>を使う場合など、コードが別々に呼ばれるような場合はこれらのメソッドは使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You should use this method and implement similar ones when extracting values from a browser's Event object, instead of hard-coding the extraction code into controllers (or model methods).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T140631Z" creationid="shibukawa.yoshiki" creationdate="20150414T140631Z">
        <seg>Mithrilを使う場合には、このメソッドを使うか似たような機能を実装して、ブラウザのイベントオブジェクトからプログラムに使う値を取り出す操作を、コントローラやモデルにハードコードしないコーディングをしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You're probably starting to notice that Javascript has strong support for functional programming and that it allows us to naturally do things that can be clunky in other frameworks (e.g. looping inside a <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;dl&gt;/&lt;dt&gt;/&lt;dd&gt;<ept i="0">&lt;/c0&gt;</ept> construct).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153457Z" creationid="shibukawa.yoshiki" creationdate="20150408T153457Z">
        <seg>ここまでの説明でお気づきの通り、JavaScriptには、関数型プログラミングに対する強力なサポートが備わっています。これを使うと、他のフレームワークではなかなかうまく表現しづらいコードを、とても自然な形で記述することができます。例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;dl&gt;/&lt;dt&gt;/&lt;dd&gt;<ept i="0">&lt;/c0&gt;</ept>を構成するためにループを使うといったことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>])
}
//a configuration that persists across route changes
function persistent(el, isInit, context) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135053Z" creationid="shibukawa.yoshiki" creationdate="20150413T135053Z">
        <seg>])
}
//ラウトが変更されてもエレメントを保持する設定
function persistent(el, isInit, context) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>]);
};

//initialize the application
m.mount(document, {controller: todo.controller, view: todo.view});
&lt;/script&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T041817Z" creationid="shibukawa.yoshiki" creationdate="20150502T041817Z">
        <seg>]);
};

//アプリケーションの初期化
m.mount(document, {controller: todo.controller, view: todo.view});
&lt;/script&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>`id` is the the same as `value`
*/
Select2.config = function(ctrl) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045234Z" creationid="shibukawa.yoshiki" creationdate="20150502T045234Z">
        <seg>`id`は`value`と同じ
*/
Select2.config = function(ctrl) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>acknowledging that the string is authorized to run any code that may be contained within it.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T014058Z" creationid="shibukawa.yoshiki" creationdate="20150416T014058Z">
        <seg>文字列の中にどのような処理も可能なコードがある可能性があり、それに実行権限を与えることを認める。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>after saving the contact, it reloads the list (<bpt i="0" x="0">&lt;c0&gt;</bpt>.then(update.bind(this))<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T003126Z" creationid="shibukawa.yoshiki" creationdate="20150502T003126Z">
        <seg>保存が完了したらリストのリロードをする(<bpt i="0" x="0">&lt;c0&gt;</bpt>.then(update.bind(this))<ept i="0">&lt;/c0&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>an anchor element <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;a&gt;<ept i="0">&lt;/c0&gt;</ept> with an <bpt i="1" x="1">&lt;c1&gt;</bpt>href<ept i="1">&lt;/c1&gt;</ept> attribute that points to a route</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172255Z" creationid="shibukawa.yoshiki" creationdate="20150414T172255Z">
        <seg>ラウトを指す<bpt i="1" x="1">&lt;c1&gt;</bpt>href<ept i="1">&lt;/c1&gt;</ept>属性を持つ<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;a&gt;<ept i="0">&lt;/c0&gt;</ept>エレメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>an object that retains its state across redraws</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T140024Z" creationid="shibukawa.yoshiki" creationdate="20150502T140024Z">
        <seg>再描画間で状態を保持するオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>becomes:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002445Z" creationid="shibukawa.yoshiki" creationdate="20150409T002445Z">
        <seg>変更後:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>compile: {expand: true, cwd: ".", src: "**/*.js", dest: "destination-folder-goes-here/"}</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150721Z" creationid="shibukawa.yoshiki" creationdate="20150412T150655Z">
        <seg>compile: {expand: true, cwd: ".", src: "**/*.js", dest: "インストールフォルダはこちら/"}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>console.log("unloaded the div");</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124516Z" creationid="shibukawa.yoshiki" creationdate="20150502T124516Z">
        <seg>console.log("divをアンロード");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>console.log("unloaded!")</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092744Z" creationid="shibukawa.yoshiki" creationdate="20150502T092744Z">
        <seg>console.log("アンロード!")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>console.log("unloading home component");</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135632Z" creationid="shibukawa.yoshiki" creationdate="20150502T135632Z">
        <seg>console.log("ホームをアンロード");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>console.log("unloading my component");</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091634Z" creationid="shibukawa.yoshiki" creationdate="20150502T091634Z">
        <seg>console.log("MyComponentコンポーネントを削除しています");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>defining a list of routes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162201Z" creationid="shibukawa.yoshiki" creationdate="20150409T162201Z">
        <seg>ラウトのリストの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>else m.redraw.strategy("none") //otherwise, ignore
}})</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150258Z" creationid="shibukawa.yoshiki" creationdate="20150416T150258Z">
        <seg>else m.redraw.strategy("none") //そうでなければ無視する
}})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>http://en.wikipedia.org/wiki/Observer_pattern</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T025157Z" creationid="shibukawa.yoshiki" creationdate="20150502T025157Z">
        <seg>http://ja.wikipedia.org/wiki/Observer_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>if (!isInit) ctx.data = "foo" //we wish to initialize this only once, even if the route changes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130727Z" creationid="shibukawa.yoshiki" creationdate="20150502T130727Z">
        <seg>if (!isInit) ctx.data = "foo" //この初期化はラウトの変更に関わらず一度だけ実行したい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>if (!user.isAdmin) throw new Error("Sorry, you don't have permissions")</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173404Z" creationid="shibukawa.yoshiki" creationdate="20150415T173404Z">
        <seg>if (!user.isAdmin) throw new Error("もうしわけありません。権限がありません。")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>if (e.keyCode == 13) vm.save() //do things and re-render only if the `enter` key was pressed</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T150248Z" creationid="shibukawa.yoshiki" creationdate="20150416T150248Z">
        <seg>if (e.keyCode == 13) vm.save() //`enter`キーが押された時だけ再描画をする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>in model-level methods if client-side processing is needed to make the data useful for a controller or view.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175047Z" creationid="shibukawa.yoshiki" creationdate="20150414T175047Z">
        <seg>モデルレベルのメソッド内で、コントローラやビューに対して処理しやすい形式のデータへの変換をクライアント側で行わなければならない場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>in order to avoid the full-page recreation when changing routes, for the sake of performance of global 3rd party components.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130757Z" creationid="shibukawa.yoshiki" creationdate="20150502T130757Z">
        <seg>ラウト変更時に全画面の再構築を避けて、サードパーティのコンポーネントのパフォーマンス劣化を避ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>in order to prevent redraw when dealing with <bpt i="0" x="0">&lt;c0&gt;</bpt>keypress<ept i="0">&lt;/c0&gt;</ept> events where the event's keyCode is not of interest</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144741Z" creationid="shibukawa.yoshiki" creationdate="20150416T144741Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>keypress<ept i="0">&lt;/c0&gt;</ept>イベントで受け取ったキーコードが処理対象外だったので再描画を避けたい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>in the controller layer: to bind error messages</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174946Z" creationid="shibukawa.yoshiki" creationdate="20150414T174946Z">
        <seg>コントローラレイヤ内: エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>in the controller layer: to bind redirection code upon a condition</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174942Z" creationid="shibukawa.yoshiki" creationdate="20150414T174942Z">
        <seg>コントローラレイヤ内: 条件によって、リダイレクトするコードをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>in the controller, to bind error messages</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175057Z" creationid="shibukawa.yoshiki" creationdate="20150414T175057Z">
        <seg>コントローラ内で、エラーメッセージをバインドする場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>in the controller, to redirect after a model service resolves.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175053Z" creationid="shibukawa.yoshiki" creationdate="20150414T175053Z">
        <seg>コントローラ内で、モデルサービスが改良した後にリダイレクトさせたい場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>in the model layer: to process web service data in transformative ways (e.g. filtering a list based on a parameter that the web service doesn't support)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T174936Z" creationid="shibukawa.yoshiki" creationdate="20150414T174936Z">
        <seg>モデルレイヤ内: ウェブサービスから受信したデータを変換処理をする場合。例えばウェブサービス側でサポートしていないフィルタリングをクライアント側で行う場合など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>item.foreach(doSomething) //programmer error: typo will throw runtime error to the console</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T173033Z" creationid="shibukawa.yoshiki" creationdate="20150415T173033Z">
        <seg>item.foreach(doSomething) //プログラマのエラー: タイプミスによって実行時エラーがログに出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>jQuery is ubiquitous and has a large ecosystem, but it's not an MVC framework.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150420T015221Z" creationid="shibukawa.yoshiki" creationdate="20150420T015221Z">
        <seg>jQueryはどこでも使われ、巨大なエコシステムを構築しましたが、それ自身はMVCフレームワークではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m(".container"); //yields &lt;div class="container"&gt;&lt;/div&gt;

m("#layout"); //yields &lt;div id="layout"&gt;&lt;/div&gt;

m("a[name=top]"); //yields &lt;a name="top"&gt;&lt;/a&gt;

m("[contenteditable]"); //yields &lt;div contenteditable&gt;&lt;/div&gt;

m("a#google.external[href='http://google.com']", "Google"); //yields &lt;a id="google" class="external" href="http://google.com"&gt;Google&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000407Z" creationid="shibukawa.yoshiki" creationdate="20150413T000407Z">
        <seg>m(".container"); //&lt;div class="container"&gt;&lt;/div&gt;を作成

m("#layout"); //&lt;div id="layout"&gt;&lt;/div&gt;を作成

m("a[name=top]"); //&lt;a name="top"&gt;&lt;/a&gt;を作成

m("[contenteditable]"); //&lt;div contenteditable&gt;&lt;/div&gt;を作成

m("a#google.external[href='http://google.com']", "Google"); //&lt;a id="google" class="external" href="http://google.com"&gt;Google&lt;/a&gt;を作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("br"); //yields a virtual element that represents &lt;br&gt;

m("div", "Hello"); //yields &lt;div&gt;Hello&lt;/div&gt;

m("div", {class: "container"}, "Hello"); //yields &lt;div class="container"&gt;Hello&lt;/div&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000106Z" creationid="shibukawa.yoshiki" creationdate="20150413T000040Z">
        <seg>m("br"); //&lt;br&gt;を表現する仮想エレメントを作成

m("div", "Hello"); //&lt;div&gt;Hello&lt;/div&gt;を作成

m("div", {class: "container"}, "Hello"); //&lt;div class="container"&gt;Hello&lt;/div&gt;を作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("button", "Add"),</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T013733Z" creationid="shibukawa.yoshiki" creationdate="20150408T013733Z">
        <seg>m("button", "追加"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("button", {onclick: todo.vm.add}, "Add")</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T152603Z" creationid="shibukawa.yoshiki" creationdate="20150408T152603Z">
        <seg>m("button", {onclick: todo.vm.add}, "追加")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("button", {onclick: todo.vm.add}, "Add"),</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T153600Z" creationid="shibukawa.yoshiki" creationdate="20150408T153600Z">
        <seg>m("button", {onclick: todo.vm.add}, "追加"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("button[type=button]", {onclick: args.onsave.bind(this, contact)}, "Save")</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002039Z" creationid="shibukawa.yoshiki" creationdate="20150502T002039Z">
        <seg>m("button[type=button]", {onclick: args.onsave.bind(this, contact)}, "保存")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("button[type=button]", {onclick: ctrl.save.bind(this, contact)}, "Save")</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013724Z" creationid="shibukawa.yoshiki" creationdate="20150502T013724Z">
        <seg>m("button[type=button]", {onclick: ctrl.save.bind(this, contact)}, "保存")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("button[type=button]", {onclick: ctrl.save}, "Upload")</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034926Z" creationid="shibukawa.yoshiki" creationdate="20150502T034926Z">
        <seg>m("button[type=button]", {onclick: ctrl.save}, "アップロード")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("button[type=button]", {onkeypress: save}, "Save"),</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144902Z" creationid="shibukawa.yoshiki" creationdate="20150416T144902Z">
        <seg>m("button[type=button]", {onkeypress: save}, "保存"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("canvas", {config: draw})
]

//this creates the canvas element, and therefore, `isInitialized` is false
m.render(document.body, view);

//here, isInitialized is `true`
m.render(document.body, view);</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T123656Z" creationid="shibukawa.yoshiki" creationdate="20150413T123637Z">
        <seg>m("canvas", {config: draw})
]

//このメソッド呼び出しをすると、canvasエレメントが作られ、`initialized`がfalseに設定される
m.render(document.body, view);

//ここではisInitializedは`true`になる
m.render(document.body, view);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("div", "&amp;times;") //becomes &lt;div&gt;&amp;amp;times;&lt;/div&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020917Z" creationid="shibukawa.yoshiki" creationdate="20150413T020917Z">
        <seg>m("div", "&amp;times;") //&lt;div&gt;&amp;amp;times;&lt;/div&gt;になる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("div", data) : null<it pos="end" x="3">&lt;/c3&gt;</it>).</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T121036Z" creationid="shibukawa.yoshiki" creationdate="20150502T121036Z">
        <seg>m("div", data) : null<it pos="end" x="3">&lt;/c3&gt;</it>)を行う方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("div", m.trust("&amp;times;")) //becomes &lt;div&gt;&amp;times;&lt;/div&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T020953Z" creationid="shibukawa.yoshiki" creationdate="20150413T020953Z">
        <seg>m("div", m.trust("&amp;times;")) //&lt;div&gt;&amp;times;&lt;/div&gt;になる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("div", {"data-index": 1}); //yields &lt;div data-index="1"&gt;&lt;/div&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013113Z" creationid="shibukawa.yoshiki" creationdate="20150413T013113Z">
        <seg>m("div", {"data-index": 1}); //&lt;div data-index="1"&gt;&lt;/div&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("div", {class: "widget"}); //yields &lt;div class="widget"&gt;&lt;/div&gt;

m("div", {className: "widget"}); //yields &lt;div class="widget"&gt;&lt;/div&gt;

m("button", {onclick: alert}); //yields &lt;button&gt;&lt;/button&gt;, which alerts its event argument when clicked

//note this uses the Javascript syntax (uppercase "O") for `readonly`
//in order to set the boolean javascript property instead of the HTML attribute
m("input", {readOnly: true}); //yields &lt;input readonly /&gt;

//using the HTML attribute name will call `setAttribute`, which may not be what you want
m("input", {readonly: false}); //yields &lt;input readonly="false" /&gt;, which is still readonly</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013004Z" creationid="shibukawa.yoshiki" creationdate="20150413T012502Z">
        <seg>m("div", {class: "widget"}); //&lt;div class="widget"&gt;&lt;/div&gt;を生成

m("div", {className: "widget"}); //&lt;div class="widget"&gt;&lt;/div&gt;を生成

m("button", {onclick: alert}); //押されるとアラートを表示する&lt;button&gt;&lt;/button&gt;を生成

//`readonly`の設定にJavaScript文法(大文字の"O"になる)を使用
//HTML属性とは異なり、JavaScriptのプロパティではboolean型を使用する
m("input", {readOnly: true}); //yields &lt;input readonly /&gt;

//HTML属性名は`setAttribute`が使われるため期待と異なることがある
m("input", {readonly: false}); //&lt;input readonly="false" /&gt;は属性が存在するので読み込み専用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("div", {style: {border: "1px solid red"}}); //yields &lt;div style="border:1px solid red;"&gt;&lt;/div&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013140Z" creationid="shibukawa.yoshiki" creationdate="20150413T013140Z">
        <seg>m("div", {style: {border: "1px solid red"}}); //&lt;div style="border:1px solid red;"&gt;&lt;/div&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("div", {style: {textAlign: "center"}}); //yields &lt;div style="text-align:center;"&gt;&lt;/div&gt;
m("div", {style: {cssFloat: "left"}}); //yields &lt;div style="float:left;"&gt;&lt;/div&gt;

//this does not work
m("div", {style: {"text-align": "center"}});
m("div", {style: {float: "left"}});</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013720Z" creationid="shibukawa.yoshiki" creationdate="20150413T013711Z">
        <seg>m("div", {style: {textAlign: "center"}}); //&lt;div style="text-align:center;"&gt;&lt;/div&gt;を生成
m("div", {style: {cssFloat: "left"}}); //&lt;div style="float:left;"&gt;&lt;/div&gt;を生成

//これは動作しない
m("div", {style: {"text-align": "center"}});
m("div", {style: {float: "left"}});</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("div[style='text-align:center']"); //yields &lt;div style="text-align:center;"&gt;&lt;/div&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T013936Z" creationid="shibukawa.yoshiki" creationdate="20150413T013936Z">
        <seg>m("div[style='text-align:center']"); //&lt;div style="text-align:center;"&gt;&lt;/div&gt;を生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("h1", "Uploader demo"),</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034737Z" creationid="shibukawa.yoshiki" creationdate="20150502T034737Z">
        <seg>m("h1", "アップローダデモ"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("input", {config: plugin}) //assuming `plugin` initializes a 3rd party library</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144635Z" creationid="shibukawa.yoshiki" creationdate="20150416T144635Z">
        <seg>m("input", {config: plugin}) //`plugin`がサードパーティのライブラリを初期化するものとする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("label", "Email"),</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013644Z" creationid="shibukawa.yoshiki" creationdate="20150502T013644Z">
        <seg>m("label", "Eメール"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("label", "Name"),</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T013638Z" creationid="shibukawa.yoshiki" creationdate="20150502T013638Z">
        <seg>m("label", "名前"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("label", "User:"),</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045319Z" creationid="shibukawa.yoshiki" creationdate="20150502T045319Z">
        <seg>m("label", "ユーザ:"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("li", "item 1"),</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000609Z" creationid="shibukawa.yoshiki" creationdate="20150413T000609Z">
        <seg>m("li", "アイテム 1"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("li", "item 2"),
]);

/*
yields
&lt;ul&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000638Z" creationid="shibukawa.yoshiki" creationdate="20150413T000614Z">
        <seg>m("li", "アイテム 2"),
]);

/*
これが作成される:
&lt;ul&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("p", "Drag and drop a file below.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T034853Z" creationid="shibukawa.yoshiki" creationdate="20150502T034853Z">
        <seg>m("p", "ファイルをここにドロップしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m("td", "task description"),</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T004223Z" creationid="shibukawa.yoshiki" creationdate="20150408T004223Z">
        <seg>m("td", "タスクの説明"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.endComputation(); //call `endComputation` at the end of everything</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010827Z" creationid="shibukawa.yoshiki" creationdate="20150412T010827Z">
        <seg>m.endComputation(); //すべての処理の後に`endComputation`を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.endComputation(); //call `endComputation` at the end of the callback</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193004Z" creationid="shibukawa.yoshiki" creationdate="20150411T193004Z">
        <seg>m.endComputation(); //`endComputation`はコールバックの最後で呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.endComputation(); //call after everything else in the event handler
}</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193139Z" creationid="shibukawa.yoshiki" creationdate="20150411T193139Z">
        <seg>m.endComputation(); //イベントハンドラの最後で、他の処理よりも後に呼ぶ
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.endComputation(); //call after everything else in the event handler
})</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150501T175402Z" creationid="shibukawa.yoshiki" creationdate="20150501T175402Z">
        <seg>m.endComputation(); //イベントハンドラの最後で、他の処理よりも後に呼ぶ
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.endComputation(); //redraw regardless of whether `doStuff` threw errors</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T153543Z" creationid="shibukawa.yoshiki" creationdate="20150416T153543Z">
        <seg>m.endComputation(); //`doStuff`が例外を投げたとしても再描画が行われる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.redraw(true) // force</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T151342Z" creationid="shibukawa.yoshiki" creationdate="20150416T151342Z">
        <seg>m.redraw(true) // 強制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.render(document.body, m("br")); //puts a &lt;br&gt; in &lt;body&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T000216Z" creationid="shibukawa.yoshiki" creationdate="20150413T000216Z">
        <seg>m.render(document.body, m("br")); //&lt;br&gt;タグを&lt;body&gt;に出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before everything else</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010808Z" creationid="shibukawa.yoshiki" creationdate="20150412T010808Z">
        <seg>m.startComputation(); //すべての処理の前に`startComputation`を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before the asynchronous AJAX request</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010127Z" creationid="shibukawa.yoshiki" creationdate="20150412T010127Z">
        <seg>m.startComputation(); //`startComputation`は非同期のAJAXリクエスト前に呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before the asynchronous `setTimeout`</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T192949Z" creationid="shibukawa.yoshiki" creationdate="20150411T192949Z">
        <seg>m.startComputation(); //`startComputation`は非同期の`setTimeout`の前に呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.startComputation(); //call `startComputation` before the asynchronous synchronization method</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T010333Z" creationid="shibukawa.yoshiki" creationdate="20150412T010333Z">
        <seg>m.startComputation(); //非同期の同期メソッドの前に`startComputation`を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>m.startComputation(); //call before everything else in the event handler</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150411T193124Z" creationid="shibukawa.yoshiki" creationdate="20150411T193124Z">
        <seg>m.startComputation(); //イベントハンドラの先頭で、他の処理よりも先に呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>making links in templates routed transparently and unobtrusively</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162425Z" creationid="shibukawa.yoshiki" creationdate="20150409T162425Z">
        <seg>テンプレート内でリンクを作ると、透過的であまり主張しないリンクが作成できる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>on initialization, it fetches the list of contacts (<bpt i="0" x="0">&lt;c0&gt;</bpt>this.contacts = Contact.list<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T002640Z" creationid="shibukawa.yoshiki" creationdate="20150502T002640Z">
        <seg>初期化時に連絡先のリストを取得します(<bpt i="0" x="0">&lt;c0&gt;</bpt>this.contacts = Contact.list()<ept i="0">&lt;/c0&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>onclick: ctrl.increment //view calls controller method on click</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071323Z" creationid="shibukawa.yoshiki" creationdate="20150502T071323Z">
        <seg>onclick: ctrl.increment //ビューはクリック時にコントローラメソッドを呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>programmatically redirecting between routes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T162257Z" creationid="shibukawa.yoshiki" creationdate="20150409T162257Z">
        <seg>ソースコードによる、ラウト間のリダイレクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>redirects to <bpt i="0" x="0">&lt;c0&gt;</bpt>http://server/#/dashboard/marysue<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T013048Z" creationid="shibukawa.yoshiki" creationdate="20150410T013048Z">
        <seg>このコードを実行すると、<bpt i="0" x="0">&lt;c0&gt;</bpt>http://server/#/dashboard/marysue<ept i="0">&lt;/c0&gt;</ept>にリダイレクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>return "Are you sure you want to leave?"</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T092416Z" creationid="shibukawa.yoshiki" creationdate="20150502T092416Z">
        <seg>return "本当に移動しますか？"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>return deferred.promise;
};

//asynchronous consumer
var greeting = greetAsync()
var processed = greeting.then(function(value) {return value + " world"})

console.log(greeting()) // undefined - because `deferred.resolve` has not been called yet

setTimeout(function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T135253Z" creationid="shibukawa.yoshiki" creationdate="20150415T135234Z">
        <seg>return deferred.promise;
};

//非同期の消費者
var greeting = greetAsync()
var processed = greeting.then(function(value) {return value + " world"})

console.log(greeting()) // undefined - `deferred.resolve`がまだ呼ばれてない

setTimeout(function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>return description;
}

//make it serializable
this.description.toJSON = function() {return description}

//set the value
this.description(data.description)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150409T002550Z" creationid="shibukawa.yoshiki" creationdate="20150409T002550Z">
        <seg>return description;
}

//シリアライズ可能にする
this.description.toJSON = function() {return description}

//値を設定
this.description(data.description)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>return m("h1", ctrl.greeting)
}

//render
m.mount(document.body, {controller: controller, view: view}) // renders <bpt i="1" x="1">&lt;h1&gt;</bpt>Hello<ept i="1">&lt;/h1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071612Z" creationid="shibukawa.yoshiki" creationdate="20150502T071612Z">
        <seg>return m("h1", ctrl.greeting)
}

//レンダリング
m.mount(document.body, {controller: controller, view: view}) // 表示: <bpt i="1" x="1">&lt;h1&gt;</bpt>Hello<ept i="1">&lt;/h1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>return m("h1", {config: Component1.config}, "test") //assume all routes display the same thing</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T130704Z" creationid="shibukawa.yoshiki" creationdate="20150502T130704Z">
        <seg>return m("h1", {config: Component1.config}, "test") //すべてのラウトが同じコンテンツを表示する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>return m("input", {oninput: m.withAttr("value", prop), value: prop()})
}

//a data store
var name = m.prop("")

//binding the data store in a view
input(name)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015709Z" creationid="shibukawa.yoshiki" creationdate="20150413T015709Z">
        <seg>return m("input", {oninput: m.withAttr("value", prop), value: prop()})
}

//データストア
var name = m.prop("")

//ビュー内のデータストアにバインディング
input(name)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>return m.request({method: "GET", url: "/user", type: User});
}

var users = User.list();
//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), `users` will contain a list of User instances
//i.e. users()[0].name() == "John"</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T170827Z" creationid="shibukawa.yoshiki" creationdate="20150410T170827Z">
        <seg>return m.request({method: "GET", url: "/user", type: User});
}

var users = User.list();
//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` はUserインスタンスのリストを格納します
//例: users()[0].name() == "John"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>return value
}

//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T130409Z" creationid="shibukawa.yoshiki" creationdate="20150410T130334Z">
        <seg>return value
}

//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>return vm
}())

//the controller defines what part of the model is relevant for the current page
//in our case, there's only one view-model that handles everything
todo.controller = function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163341Z" creationid="shibukawa.yoshiki" creationdate="20150408T163303Z">
        <seg>return vm
}())

//コントローラは、モデルの中のどの部分が、現在のページと関連するのかを定義している
//この場合は１つのビュー・モデルですべてを取り仕切っている
todo.controller = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>return {oninput: m.withAttr("value", prop), value: prop()}
}

//a data store
var name = m.prop("")

//binding the data store in a view
m("input", binds(name))</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T015607Z" creationid="shibukawa.yoshiki" creationdate="20150413T015549Z">
        <seg>return {oninput: m.withAttr("value", prop), value: prop()}
}

//データストア
var name = m.prop("")

//ビュー内のデータストアにバインド
m("input", binds(name))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>returns a promise that can bind callbacks which get called on completion of the AJAX request.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T014442Z" creationid="shibukawa.yoshiki" creationdate="20150415T014442Z">
        <seg>AJAXリクエストが完了したときに呼ばれるコールバックをバインドすることが可能なpromise。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>returns the currently active route</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172212Z" creationid="shibukawa.yoshiki" creationdate="20150414T172212Z">
        <seg>現在アクティブなラウトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>sanitizing the markup contained in the string, or</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T013916Z" creationid="shibukawa.yoshiki" creationdate="20150416T013916Z">
        <seg>サニタイズされたマークアップが文字列の中に含まれる、もしくは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>sjs -r -m /template-compiler.sjs -o &lt;output-filename&gt;.js &lt;input-filename&gt;.js</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150412T150236Z" creationid="shibukawa.yoshiki" creationdate="20150412T150236Z">
        <seg>sjs -r -m /template-compiler.sjs -o &lt;出力ファイル名&gt;.js &lt;入力ファイル名&gt;.js</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>temp: m.prop(10) // kelvin</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T081105Z" creationid="shibukawa.yoshiki" creationdate="20150502T081105Z">
        <seg>temp: m.prop(10) // ケルビン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>the list of HTML attributes changes, or</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135406Z" creationid="shibukawa.yoshiki" creationdate="20150413T135406Z">
        <seg>HTML属性のリストが変更されるか、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>the method does not run if this flag is set to true.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T172328Z" creationid="shibukawa.yoshiki" creationdate="20150414T172328Z">
        <seg>このフラグがtrueの場合はこのメソッドは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>the tag name changes, or</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135356Z" creationid="shibukawa.yoshiki" creationdate="20150413T135356Z">
        <seg>タグ名が変更されるか、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>the value of the element's id attribute changes</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T135422Z" creationid="shibukawa.yoshiki" creationdate="20150413T135422Z">
        <seg>エレメントのid属性が変更された場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>things: m.request({method: "GET", url: "/api/things/", data: args}) //slice the data in some way</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T084532Z" creationid="shibukawa.yoshiki" creationdate="20150502T084532Z">
        <seg>things: m.request({method: "GET", url: "/api/things/", data: args}) //何らかのルールでデータの一部を切り出し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>this.done = m.prop(false);
};

//the TodoList class is a list of Todo's
todo.TodoList = Array;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150427Z" creationid="shibukawa.yoshiki" creationdate="20150407T150427Z">
        <seg>this.done = m.prop(false);
};

//TodoListクラスはTodoのリスト
todo.TodoList = Array;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>this.done = m.prop(false);
};

//the TodoList class is a list of Todo's
todo.TodoList = Array;

//the view-model tracks a running list of todos,
//stores a description for new todos before they are created
//and takes care of the logic surrounding when adding is permitted
//and clearing the input after adding a todo to the list
todo.vm = (function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T162616Z" creationid="shibukawa.yoshiki" creationdate="20150408T162616Z">
        <seg>this.done = m.prop(false);
};

//TodoListクラスはtodoの配列
todo.TodoList = Array;

//ビュー・モデルは表示されているTodoのリストを管理し、
//作成が完了する前のTodoの説明を格納したり、
//作成が可能かどうかを判定するロジックや、
//Todoが追加された後にテキスト入力をクリアする責務を持つ
todo.vm = (function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>throw new Error("Server is offline")</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T181844Z" creationid="shibukawa.yoshiki" creationdate="20150414T181844Z">
        <seg>throw new Error("サーバがオフラインです")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>todo.vm.init()
}

//here's the view
todo.view = function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T163358Z" creationid="shibukawa.yoshiki" creationdate="20150408T163358Z">
        <seg>todo.vm.init()
}

//これがビュー
todo.view = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>todo.vm.init();

todo.vm.description(); // empty string
m.render(document, todo.view()); // input is blank

todo.vm.description("Write code"); //set the description in the controller
m.render(document, todo.view()); // input now says "Write code"</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T015242Z" creationid="shibukawa.yoshiki" creationdate="20150408T015204Z">
        <seg>todo.vm.init();

todo.vm.description(); // 空文字列
m.render(document, todo.view()); // テキスト入力もブランク

todo.vm.description("コードを書く"); // ビュー・モデルのdescriptionに値を設定
m.render(document, todo.view()); // テキスト入力に「コードを書く」が表示される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>var app = {}

//here's an example plugin that determines whether data has changes.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T124526Z" creationid="shibukawa.yoshiki" creationdate="20150416T124526Z">
        <seg>var app = {}

//どこのデータが変更されているかを決定するサンプルプラグイン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>var deferred = Q.defer()
var users = m.prop(deferred.promise)

users() // undefined

deferred.resolve("Hello")

//wait for next tick for Q's A+ compliant promise to actually resolve
setTimeout(function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T135547Z" creationid="shibukawa.yoshiki" creationdate="20150414T135547Z">
        <seg>var deferred = Q.defer()
var users = m.prop(deferred.promise)

users() // undefined

deferred.resolve("Hello")

//QのA+互換のPromiseが次のtickで解決するのを待つ
setTimeout(function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>var isDone = myTask.done(); //isDone == false

//mark as done
myTask.done(true); //true

//now it's done
isDone = myTask.done(); //isDone == true</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150958Z" creationid="shibukawa.yoshiki" creationdate="20150407T150958Z">
        <seg>var isDone = myTask.done(); //isDone == false

//完了にする
myTask.done(true); //true

//ここでは完了している
isDone = myTask.done(); //isDone == true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>var myTask = new todo.Todo({description: "Write code"});

//read the description
myTask.description(); //Write code

//is it done?</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150407T150920Z" creationid="shibukawa.yoshiki" creationdate="20150407T150920Z">
        <seg>var myTask = new todo.Todo({description: "コードを書く"});

//descriptionを取得する
myTask.description(); //コードを書く

//完了しているか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>var todo = {};

//for simplicity, we use this component to namespace the model classes

//the Todo class has two properties
todo.Todo = function(data) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T040737Z" creationid="shibukawa.yoshiki" creationdate="20150502T040737Z">
        <seg>var todo = {};

//例をシンプルにするために、このコンポーネントをモデルクラスの名前空間として利用する

//Todoクラスはプロパティを2つ持つ
todo.Todo = function(data) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>var transport = m.prop();

m.request({method: "POST", url: "/foo", config: transport});

//the `transport` getter-setter contains an instance of XMLHttpRequest
transport().abort();</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T182405Z" creationid="shibukawa.yoshiki" creationdate="20150414T182405Z">
        <seg>var transport = m.prop();

m.request({method: "POST", url: "/foo", config: transport});

//`transport` getter-setterにはXMLHttpRequestのインスタンスが含まれる。
transport().abort();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>var users = m.prop([]); //default value

m.request({method: "GET", url: "/user"}).then(users)
//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T020018Z" creationid="shibukawa.yoshiki" creationdate="20150410T020018Z">
        <seg>var users = m.prop([]); //default value

m.request({method: "GET", url: "/user"}).then(users)
//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>var users = m.prop([]); //default value
var doSomething = function() { /*...*/ }

m.request({method: "GET", url: "/user"}).then(users).then(doSomething)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T020302Z" creationid="shibukawa.yoshiki" creationdate="20150410T020302Z">
        <seg>var users = m.prop([]); //デフォルト値
var doSomething = function() { /*...*/ }

m.request({method: "GET", url: "/user"}).then(users).then(doSomething)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>var users = m.request({method: "GET", url: "/user"});

//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T015137Z" creationid="shibukawa.yoshiki" creationdate="20150410T015137Z">
        <seg>var users = m.request({method: "GET", url: "/user"});

//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>var vm = todo.vm

m("button", {onclick: vm.add.bind(vm, vm.description)}, "Add")</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150408T151232Z" creationid="shibukawa.yoshiki" creationdate="20150408T151232Z">
        <seg>var vm = todo.vm

m("button", {onclick: vm.add.bind(vm, vm.description)}, "追加")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>view: function() {}
};

//go to the default route (home)
m.route(document.body, "/", {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T135334Z" creationid="shibukawa.yoshiki" creationdate="20150502T135334Z">
        <seg>view: function() {}
};

//デフォルトラウト(home)に移動
m.route(document.body, "/", {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>when <bpt i="0" x="0">&lt;c0&gt;</bpt>save<ept i="0">&lt;/c0&gt;</ept> is called, it saves a contact (<bpt i="1" x="1">&lt;c1&gt;</bpt>Contact.save(contact)<ept i="1">&lt;/c1&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T003052Z" creationid="shibukawa.yoshiki" creationdate="20150502T003052Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>save<ept i="0">&lt;/c0&gt;</ept>が呼ばれると、連絡先を保存する(<bpt i="1" x="1">&lt;c1&gt;</bpt>Contact.save(contact)<ept i="1">&lt;/c1&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>when a new call to <bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept> updates the root DOM element of the component in question</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091104Z" creationid="shibukawa.yoshiki" creationdate="20150502T091104Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>m.mount<ept i="0">&lt;/c0&gt;</ept>関数が当たらたに呼ばれ、指定されたコンポーネントのルートのDOMエレメントが更新された時</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>when a route changes (if you are using <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.route<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091125Z" creationid="shibukawa.yoshiki" creationdate="20150502T091125Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>m.route<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を使ってラウトが変更された場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>yields:</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002425Z" creationid="shibukawa.yoshiki" creationdate="20150413T002425Z">
        <seg>生成される結果:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>{ onclick: function(e) { /*do stuff*/ } }</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T154827Z" creationid="shibukawa.yoshiki" creationdate="20150413T154827Z">
        <seg>{ onclick: function(e) { /*ハンドラの処理コード*/ } }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>{class: "active"} : {})

//use this idiom instead
m("li", {class: selected ?</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T144400Z" creationid="shibukawa.yoshiki" creationdate="20150413T144400Z">
        <seg>{class: "active"} : {})

//代わりにこのイディオムを使う
m("li", {class: selected ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>{id: 2, name: "Mary"}
]

//ajax and display a list of projects for John
m.render(document.body, ProjectList({key: people[0].id, value: people[0]})

//ajax and display a list of projects for Mary
m.render(document.body, ProjectList({key: people[1].id, value: people[1]})</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T085750Z" creationid="shibukawa.yoshiki" creationdate="20150502T085737Z">
        <seg>{id: 2, name: "Mary"}
]

//AJAXでデータを取得し、Johnのプロジェクト一覧を表示
m.render(document.body, ProjectList({key: people[0].id, value: people[0]})

//AJAXでデータを取得し、Maryのプロジェクト一覧を表示
m.render(document.body, ProjectList({key: people[1].id, value: people[1]})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>{title: "item 1", url: "/item1"}
];

m.render(document.body, [</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T123335Z" creationid="shibukawa.yoshiki" creationdate="20150416T123335Z">
        <seg>{title: "アイテム 1", url: "/item1"}
];

m.render(document.body, [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>{title: "item 1", url: "/item1"},</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002436Z" creationid="shibukawa.yoshiki" creationdate="20150413T002436Z">
        <seg>{title: "アイテム 1", url: "/item1"},</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>{title: "item 2", url: "/item2"},</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002438Z" creationid="shibukawa.yoshiki" creationdate="20150413T002438Z">
        <seg>{title: "アイテム 2", url: "/item2"},</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>{title: "item 3", url: "/item3"}
];

m.render(document.body, [</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150413T002442Z" creationid="shibukawa.yoshiki" creationdate="20150413T002442Z">
        <seg>{title: "アイテム 3", url: "/item3"}
];

m.render(document.body, [</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

//ContactList is the same as before
var ContactList = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031334Z" creationid="shibukawa.yoshiki" creationdate="20150502T031334Z">
        <seg>}
}

//ContactListは前の実装と同じ
var ContactList = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

//ContactList no longer calls `Contact.save`
var ContactForm = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T031314Z" creationid="shibukawa.yoshiki" creationdate="20150502T031314Z">
        <seg>}
}

//ContactListは`Contact.save`を呼ばない
var ContactForm = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

//components that use the menu above
var Home = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124906Z" creationid="shibukawa.yoshiki" creationdate="20150502T124906Z">
        <seg>}
}

//上記のメニューを使用するコンポーネント
var Home = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

//create a component whose controller and view functions receive some arguments
var component = m.component(MyComponent, {name: "world"}, "this is a test")

var ctrl = new component.controller() // logs "world", "this is a test"

m.render(document.body, component.view(ctrl)) // render the virtual DOM tree manually

//<it pos="begin" x="1">&lt;body&gt;&lt;h1&gt;</it>Hello world this is a test<ept i="1">&lt;/h1&gt;</ept>&lt;/body&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T075939Z" creationid="shibukawa.yoshiki" creationdate="20150502T075909Z">
        <seg>}
}

//controllerとviewが同じ値を受け取るコンポーネントを作成する
var component = m.component(MyComponent, {name: "world"}, "this is a test")

var ctrl = new component.controller() // 表示: "world", "this is a test"

m.render(document.body, component.view(ctrl)) // 手動で仮想DOMツリーをレンダリング

//<it pos="begin" x="1">&lt;body&gt;&lt;h1&gt;</it>Hello world this is a test<ept i="1">&lt;/h1&gt;</ept>&lt;/body&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

//end component



//usage
var Dashboard = {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045300Z" creationid="shibukawa.yoshiki" creationdate="20150502T045255Z">
        <seg>}
}

//コンポーネントの定義はここまで


//使用方法
var Dashboard = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

//in the view
demo.view = function(ctrl) {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150415T001806Z" creationid="shibukawa.yoshiki" creationdate="20150415T001806Z">
        <seg>}
}

//ビュー内
demo.view = function(ctrl) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

//setup routes to start w/ the `#` symbol
m.route.mode = "hash";

//define a route
m.route(document.body, "/dashboard/johndoe", {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T003247Z" creationid="shibukawa.yoshiki" creationdate="20150410T003247Z">
        <seg>}
}

//#記号から始まるラウトを使用するための設定
m.route.mode = "hash";

//ラウトの定義
m.route(document.body, "/dashboard/johndoe", {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

//view
var view = function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150416T144844Z" creationid="shibukawa.yoshiki" creationdate="20150416T144844Z">
        <seg>}
}

//ビュー
var view = function() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

m.mount(document.body, MyComponent)

//renders:
//&lt;a href="javascript:;"&gt;Count: 0&lt;/a&gt;
//
//the number increments when the link is clicked</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T071359Z" creationid="shibukawa.yoshiki" creationdate="20150502T071338Z">
        <seg>}
}

m.mount(document.body, MyComponent)

//以下のようにレンダリングされる
//&lt;a href="javascript:;"&gt;Count: 0&lt;/a&gt;
//
//リンクがクリックされるたびにカウンタがインクリメントされる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

m.mount(document.body, MyComponent) // renders <bpt i="1" x="1">&lt;h1&gt;</bpt>Hello<ept i="1">&lt;/h1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T072121Z" creationid="shibukawa.yoshiki" creationdate="20150502T072121Z">
        <seg>}
}

m.mount(document.body, MyComponent) // 表示: <bpt i="1" x="1">&lt;h1&gt;</bpt>Hello<ept i="1">&lt;/h1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
}

m.mount(document.body, MyComponent) // renders <bpt i="1" x="1">&lt;h1&gt;</bpt>Hello<ept i="1">&lt;/h1&gt;</ept> into &lt;body&gt;</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T061408Z" creationid="shibukawa.yoshiki" creationdate="20150502T061408Z">
        <seg>}
}

m.mount(document.body, MyComponent) // <it pos="begin" x="1">&lt;body&gt;に&lt;h1&gt;</it>Hello<ept i="1">&lt;/h1&gt;</ept>と表示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
});

//assuming the response is: `{data: [{name: "John"}, {name: "Mary"}], count: 2}`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T174638Z" creationid="shibukawa.yoshiki" creationdate="20150410T174638Z">
        <seg>}
});

//レスポンスには`{data: [{name: "John"}, {name: "Mary"}], count: 2}`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
};

/**
Select2 config factory.</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T045219Z" creationid="shibukawa.yoshiki" creationdate="20150502T045219Z">
        <seg>}
};

/**
Select2 configファクトリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
};

// mount on the same DOM element, replacing MyComponent
m.mount(document.body, AnotherComponent); // logs "unloading my component"</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T091736Z" creationid="shibukawa.yoshiki" creationdate="20150502T091736Z">
        <seg>}
};

// 同じDOMエレメントに対してマウントし、MyComponentを置き換え
m.mount(document.body, AnotherComponent); // ログ: "MyComponentコンポーネントを削除しています"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>}
};

m.render(document, m("div", {config: unloadable}));

m.render(document, m("a")); //logs `unloaded the div` and `alert` never gets called</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150502T124538Z" creationid="shibukawa.yoshiki" creationdate="20150413T130519Z">
        <seg>}
};

m.render(document, m("div", {config: unloadable}));

m.render(document, m("a")); //`divをアンロード`とログに表示されるが、`alert`は呼ばれない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>})

//assuming the response contains the following data: `[{name: "John"}, {name: "Mary"}]`
//then when resolved (e.g. in a view), the `users` getter-setter will contain a list of users
//i.e. users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150414T175232Z" creationid="shibukawa.yoshiki" creationdate="20150414T175232Z">
        <seg>})

//レスポンスには`[{name: "John"}, {name: "Mary"}]`というデータが格納されると想定
//そのため、ビューなどの中で解決されると、`users` getter-setterはユーザの配列を持ちます
//例: users() //[{name: "John"}, {name: "Mary"}, {name: "Jane"}]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>});
}

//controller
var controller = function() {</seg>
      </tuv>
      <tuv xml:lang="JA" changeid="shibukawa.yoshiki" changedate="20150410T124220Z" creationid="shibukawa.yoshiki" creationdate="20150410T124220Z">
        <seg>});
}

//コントローラ
var controller = function() {</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
